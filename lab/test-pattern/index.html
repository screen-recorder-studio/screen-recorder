<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRS Master Calibration Chart v4 (Crop/Trim Edition)</title>
    <style>
        :root {
            --bg-color: #050505;
            --theme-color: #00ffff; /* Dynamic */
            --grid-color: #333;
            --panel-bg: rgba(0,0,0,0.7);
        }
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background: var(--bg-color);
            color: #e0e0e0;
            font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
            user-select: none;
        }

        /* --- Layer 0: Coordinate Grid (Canvas) --- */
        #grid-canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            pointer-events: none;
        }

        /* --- Layer 1: Layout --- */
        .layout {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            grid-template-rows: 140px 1fr 180px;
            width: 100vw; height: 100vh;
            position: relative;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
            gap: 10px;
        }

        .panel {
            border: 1px solid var(--theme-color);
            background: var(--panel-bg);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: border-color 0.5s;
            backdrop-filter: blur(4px);
        }

        .label {
            position: absolute;
            top: 0; left: 0;
            background: var(--theme-color);
            color: #000;
            font-weight: bold;
            font-size: 10px;
            padding: 2px 6px;
            text-transform: uppercase;
            z-index: 20;
            transition: background 0.5s;
        }

        /* --- Zone 1: Bitrate Stress (Noise) --- */
        .noise-canvas { width: 100%; height: 100%; image-rendering: pixelated; }

        /* --- Zone 2: Color & Sync --- */
        .chroma-box { display: grid; grid-template-columns: 1fr 1fr; height: 100%; }
        .sync-visual {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-left: 1px solid #333; width: 100px;
        }
        .sync-indicator {
            width: 40px; height: 40px; background: #222; border: 2px solid #444; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 10px; color: #000; font-weight: bold;
        }
        .sync-active { background: #fff; box-shadow: 0 0 20px #fff; border-color: #fff; }
        .sync-text { margin-top: 5px; font-size: 9px; color: #888; }

        /* --- Zone 3: Jitter --- */
        .jitter-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: flex-end;
            opacity: 0.8;
        }
        .jitter-bar { flex: 1; margin-right: 1px; background: var(--theme-color); transition: background 0.5s; }
        .jitter-bad { background: #f00 !important; }

        /* --- Center Stage --- */
        .center-stage {
            grid-column: 2; grid-row: 2;
            position: relative;
            display: flex; align-items: center; justify-content: center;
        }
        .siemens-star {
            width: 80vh; height: 80vh;
            max-width: 90%; max-height: 90%;
            opacity: 0.9;
            /* Animation handled by JS now for sync */
        }

        .hud {
            position: absolute;
            background: rgba(0,0,0,0.85);
            border: 2px solid var(--theme-color);
            padding: 15px 30px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 8px;
            transition: border-color 0.5s;
        }
        .time-big { font-size: 3rem; font-weight: 700; color: #fff; font-feature-settings: "tnum"; margin-bottom: 5px; }
        .theme-phase { font-size: 10px; color: var(--theme-color); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 10px; transition: color 0.5s; }
        
        .binary-row { display: flex; gap: 3px; justify-content: center; height: 20px; }
        .bit { width: 10px; height: 100%; background: #222; border: 1px solid #444; }
        .bit.on { background: var(--theme-color); box-shadow: 0 0 5px var(--theme-color); border-color: #fff; }

        /* --- Bottom: Gradients & Motion --- */
        .motion-panel {
            grid-column: 1 / span 3;
            display: flex; flex-direction: column;
        }
        /* Stepped Ramp for Banding Check */
        .stepped-ramp {
            height: 30px; width: 100%; display: flex;
        }
        .ramp-step { flex: 1; height: 100%; }

        /* Smooth Ramp */
        .smooth-ramp {
            height: 20px; width: 100%;
            background: linear-gradient(to right, #000, #fff);
        }

        .ufo-track {
            flex: 1; position: relative; border-top: 1px solid #333; background: #111; overflow: hidden;
        }
        .ufo {
            position: absolute; top: 15px; height: 30px; width: 40px;
            background: var(--theme-color);
            border: 2px solid #fff;
            box-shadow: 0 0 10px var(--theme-color);
            transition: background 0.5s;
        }
        /* Vertical Tearing Check Lines */
        .tear-line { position: absolute; top:0; bottom:0; width:1px; background:rgba(255,255,255,0.3); }

        /* Start Overlay */
        #start {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
        }
        h1 { color: var(--theme-color); margin-bottom: 10px; }
        .specs { color: #666; font-size: 12px; margin-top: 20px; text-align: center; line-height: 1.6; }
    </style>
</head>
<body>

    <div id="start">
        <h1 style="color:#0ff">SRS BENCHMARK v4</h1>
        <p style="color:#fff">Click to Start • Enable Audio</p>
        <div class="specs">
            Features:<br>
            • Fullscreen Coordinate Grid (Crop Test)<br>
            • Temporal Color Cycling (Trim Test)<br>
            • Stereo Audio Separation (L/R)<br>
            • Main-Thread Optimized Noise<br>
            • Frame-Perfect Sync
        </div>
    </div>

    <!-- Background Grid for Crop Validation -->
    <canvas id="grid-canvas"></canvas>

    <div class="layout">
        
        <!-- 1. Entropy / Bitrate Stress -->
        <div class="panel">
            <div class="label">01 ENCODER STRESS</div>
            <canvas id="noise" class="noise-canvas"></canvas>
            <div style="position:absolute; bottom:2px; right:5px; font-size:9px; color:#fff; background:rgba(0,0,0,0.5); padding:2px;">
                PRE-CALC BUFFER
            </div>
        </div>

        <!-- 2. Chroma & Audio Visual -->
        <div class="panel" style="grid-column: 2; flex-direction: row;">
            <div style="flex:1; display:flex; flex-direction:column;">
                <div class="label">02 CHROMA 4:2:0</div>
                <!-- Torture Test Colors -->
                <div style="flex:1; display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr; font-size:12px; font-weight:900; text-align:center;">
                    <div style="background:#0000ff; color:#ff0000; display:flex; align-items:center; justify-content:center;">RED/BLUE</div>
                    <div style="background:#ff0000; color:#00ffff; display:flex; align-items:center; justify-content:center;">CYAN/RED</div>
                    <div style="background:#000000; color:#ff0000; display:flex; align-items:center; justify-content:center;">RED/BLK</div>
                    <div style="background:#00ff00; color:#ff00ff; display:flex; align-items:center; justify-content:center;">MAG/GRN</div>
                </div>
            </div>
            
            <!-- Stereo Sync -->
            <div class="sync-visual">
                <div class="label">03 AUDIO</div>
                <div class="sync-indicator" id="ind-left" style="margin-bottom:5px;">L</div>
                <div class="sync-indicator" id="ind-right">R</div>
                <div class="sync-text">STEREO CHECK</div>
            </div>
        </div>

        <!-- 3. Jitter -->
        <div class="panel">
            <div class="label">04 RENDER JITTER</div>
            <div style="flex:1; position:relative;" id="jitterGraph">
                <div class="jitter-container" id="jitterBars"></div>
            </div>
            <div style="text-align:right; padding:2px; font-size:9px; color:#888;">
                RED > 33ms (Drop)
            </div>
        </div>

        <!-- 4. Dynamic Aliasing (Zone Plate) -->
        <div class="panel">
            <div class="label">05 DYNAMIC ZONE</div>
            <canvas id="zone" style="width:100%; height:100%;"></canvas>
        </div>

        <!-- 5. Center Stage -->
        <div class="center-stage">
            <svg class="siemens-star" id="star" viewBox="-500 -500 1000 1000"></svg>
            
            <div class="hud">
                <div class="theme-phase" id="phase-name">PHASE 1: BLUE</div>
                <div class="time-big" id="tc">00:00:000</div>
                <div class="binary-row" id="bits"></div>
                
                <div style="margin-top:10px; font-size:10px; color:#888; display:flex; justify-content:space-between;">
                    <span>FRAME: <b id="fn" style="color:#fff">0</b></span>
                    <span>FPS: <b id="fps" style="color:#fff">0</b></span>
                </div>
            </div>
        </div>

        <!-- 6. Color Banding -->
        <div class="panel">
            <div class="label">06 BIT DEPTH</div>
            <div class="stepped-ramp" id="rampSteps">
                <!-- JS will fill 32 steps -->
            </div>
            <div style="height:20px; background:linear-gradient(to right, #000, #fff); margin-top:5px;"></div>
            <div style="font-size:9px; color:#666; text-align:center; margin-top:2px;">
                Top: 32-Step Quantized (Check Banding) | Btm: Smooth
            </div>
        </div>

        <!-- 7. Motion & Crop Check -->
        <div class="panel motion-panel">
            <div class="label">07 MOTION & TEARING</div>
            <div class="ufo-track">
                <div class="tear-line" style="left:25%"></div>
                <div class="tear-line" style="left:50%"></div>
                <div class="tear-line" style="left:75%"></div>
                <div class="ufo" id="ufo"></div>
            </div>
        </div>

    </div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            colors: [
                { hex: '#00ffff', name: 'CYAN / BLUE' },   // 0-10s
                { hex: '#00ff00', name: 'GREEN' },         // 10-20s
                { hex: '#ff0000', name: 'RED' },           // 20-30s
                { hex: '#ffff00', name: 'YELLOW' }         // 30-40s
            ],
            cycleDuration: 10000, // 10s per color
            noiseInterval: 2, // Update noise every N frames (save CPU)
            ufoSpeed: 1 // loops per 2s
        };

        // --- 1. Audio Engine (Stereo) ---
        let audioCtx, oscLeft, oscRight, gainLeft, gainRight, pannerLeft, pannerRight;
        let isAudioInit = false;

        function initAudio() {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            
            // Left Channel (Low Pitch 440Hz)
            oscLeft = audioCtx.createOscillator();
            oscLeft.frequency.value = 440;
            gainLeft = audioCtx.createGain();
            gainLeft.gain.value = 0;
            pannerLeft = audioCtx.createStereoPanner();
            pannerLeft.pan.value = -1; // Full Left
            oscLeft.connect(gainLeft).connect(pannerLeft).connect(audioCtx.destination);
            oscLeft.start();

            // Right Channel (High Pitch 880Hz)
            oscRight = audioCtx.createOscillator();
            oscRight.frequency.value = 880;
            gainRight = audioCtx.createGain();
            gainRight.gain.value = 0;
            pannerRight = audioCtx.createStereoPanner();
            pannerRight.pan.value = 1; // Full Right
            oscRight.connect(gainRight).connect(pannerRight).connect(audioCtx.destination);
            oscRight.start();

            isAudioInit = true;
        }

        function triggerBeep(side) {
            if(!isAudioInit) return;
            const now = audioCtx.currentTime;
            const targetGain = side === 'left' ? gainLeft : gainRight;
            
            // Cancel previous schedule to avoid overlap artifacts
            targetGain.gain.cancelScheduledValues(now);
            targetGain.gain.setValueAtTime(0, now);
            targetGain.gain.linearRampToValueAtTime(0.1, now + 0.01);
            targetGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        }

        // --- 2. Background Grid (Canvas) ---
        const gridCanvas = document.getElementById('grid-canvas');
        const gridCtx = gridCanvas.getContext('2d');

        function drawGrid() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            gridCanvas.width = w;
            gridCanvas.height = h;
            
            gridCtx.clearRect(0,0,w,h);
            gridCtx.font = '9px monospace';
            gridCtx.fillStyle = '#444';
            gridCtx.strokeStyle = '#222';
            gridCtx.lineWidth = 1;

            // Draw Lines & Text
            for (let x = 0; x < w; x += 50) {
                const isMajor = x % 100 === 0;
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, h);
                gridCtx.strokeStyle = isMajor ? '#333' : '#1a1a1a';
                gridCtx.stroke();
            }
            for (let y = 0; y < h; y += 50) {
                const isMajor = y % 100 === 0;
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(w, y);
                gridCtx.strokeStyle = isMajor ? '#333' : '#1a1a1a';
                gridCtx.stroke();
            }

            // Draw Coordinates at Intersections (every 100px)
            gridCtx.fillStyle = '#666';
            for(let x=0; x<w; x+=100) {
                for(let y=0; y<h; y+=100) {
                    if(x===0 && y===0) continue;
                    gridCtx.fillText(`${x},${y}`, x + 2, y + 10);
                }
            }
        }
        window.addEventListener('resize', drawGrid);

        // --- 3. Optimized Noise (Pre-calculated) ---
        const nCvs = document.getElementById('noise');
        const nCtx = nCvs.getContext('2d', {alpha:false});
        let noiseFrames = [];
        let noiseIdx = 0;

        function initNoise() {
            // Create small buffer and scale up (Pixelated) for performance
            // But for bitrate stress, we want 1:1 pixels.
            // Compromise: 4 frames of Full HD noise consumes RAM but saves CPU.
            // Let's use a smaller buffer (e.g., 640x360) and scale up. 
            // It still destroys compression algorithms effectively.
            const w = 640; 
            const h = 360;
            nCvs.width = w; nCvs.height = h;
            
            for(let f=0; f<4; f++) {
                const id = nCtx.createImageData(w, h);
                const buf = new Uint32Array(id.data.buffer);
                for(let i=0; i<buf.length; i++) {
                    buf[i] = 0xFF000000 | (Math.random()*0xFFFFFF);
                }
                noiseFrames.push(id);
            }
        }
        initNoise();

        // --- 4. Dynamic Zone Plate ---
        const zCvs = document.getElementById('zone');
        const zCtx = zCvs.getContext('2d');
        let zPhase = 0;
        
        function drawZone() {
            // Draw once, animate phase later? 
            // Actually, calculating Zone Plate JS per frame is heavy.
            // Let's draw a static high-res one, and just PAN it.
            // A moving texture is enough to test temporal aliasing.
            const w = 300, h = 150;
            zCvs.width = w; zCvs.height = h;
            const id = zCtx.createImageData(w, h);
            const d = id.data;
            const cx = w/2, cy = h/2;
            
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const r = Math.sqrt((x-cx)**2 + (y-cy)**2);
                    // Add phase shift
                    const v = 127 + 127 * Math.sin(r*r*0.1 + zPhase);
                    const i = (y*w+x)*4;
                    d[i]=v; d[i+1]=v; d[i+2]=v; d[i+3]=255;
                }
            }
            zCtx.putImageData(id, 0, 0);
        }

        // --- 5. Siemens Star Generator ---
        function makeStar() {
            const svg = document.getElementById('star');
            const segs = 36;
            for(let i=0; i<segs; i++) {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const a1 = (i * 360/segs) * Math.PI/180;
                const a2 = ((i+0.5) * 360/segs) * Math.PI/180;
                const R = 500;
                path.setAttribute("d", `M0,0 L${Math.cos(a1)*R},${Math.sin(a1)*R} A${R},${R} 0 0,1 ${Math.cos(a2)*R},${Math.sin(a2)*R} Z`);
                path.setAttribute("fill", "#fff");
                svg.appendChild(path);
            }
        }
        makeStar();

        // --- 6. Stepped Ramp ---
        function initRamp() {
            const el = document.getElementById('rampSteps');
            for(let i=0; i<32; i++) {
                const d = document.createElement('div');
                d.className = 'ramp-step';
                const val = Math.floor((i/31)*255);
                d.style.background = `rgb(${val},${val},${val})`;
                el.appendChild(d);
            }
        }
        initRamp();

        // --- 7. Binary Bits ---
        const bitEls = [];
        const bitsContainer = document.getElementById('bits');
        for(let i=0; i<16; i++){
            const d = document.createElement('div');
            d.className = 'bit';
            bitsContainer.appendChild(d);
            bitEls.push(d);
        }

        // --- 8. Jitter Bars ---
        const jContainer = document.getElementById('jitterBars');
        const jBars = [];
        const MAX_BARS = 60;
        for(let i=0; i<MAX_BARS; i++) {
            const b = document.createElement('div');
            b.className = 'jitter-bar';
            jContainer.appendChild(b);
            jBars.push(b);
        }
        let jIdx = 0;

        // --- MAIN LOOP ---
        let startT = null;
        let lastT = 0;
        let frames = 0;
        let fpsC = 0, lastFpsT = 0;
        
        const elTc = document.getElementById('tc');
        const elFn = document.getElementById('fn');
        const elFps = document.getElementById('fps');
        const elPhase = document.getElementById('phase-name');
        const elUfo = document.getElementById('ufo');
        const elStar = document.getElementById('star');
        const elIndL = document.getElementById('ind-left');
        const elIndR = document.getElementById('ind-right');

        function loop(t) {
            if(!startT) startT = t;
            const delta = t - lastT;
            lastT = t;
            const elapsed = t - startT;

            // A. Temporal Color Coding (Trim Test)
            const cycleIdx = Math.floor(elapsed / CONFIG.cycleDuration) % CONFIG.colors.length;
            const theme = CONFIG.colors[cycleIdx];
            document.documentElement.style.setProperty('--theme-color', theme.hex);
            elPhase.innerText = `PHASE ${cycleIdx+1}: ${theme.name}`;
            elPhase.style.color = theme.hex;

            // B. Jitter Graph
            const barH = Math.min(100, delta * 2); 
            const bar = jBars[jIdx];
            bar.style.height = barH + '%';
            bar.classList.toggle('jitter-bad', delta > 33);
            jIdx = (jIdx + 1) % MAX_BARS;

            // C. Timecode
            const m = Math.floor(elapsed/60000);
            const s = Math.floor((elapsed%60000)/1000);
            const ms = Math.floor(elapsed%1000);
            elTc.innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}:${ms.toString().padStart(3,'0')}`;

            // D. Binary Counter & Frame Info
            elFn.innerText = frames;
            const val = frames % 65536;
            for(let i=0; i<16; i++) {
                const on = (val >> (15-i)) & 1;
                bitEls[i].classList.toggle('on', !!on);
            }

            // E. Noise (Throttled)
            if(frames % CONFIG.noiseInterval === 0) {
                nCtx.putImageData(noiseFrames[noiseIdx], 0, 0);
                noiseIdx = (noiseIdx + 1) % noiseFrames.length;
            }

            // F. Dynamic Zone Plate (Slow Phase Shift)
            // Updating pixel data every frame is too heavy. 
            // Just update it every 4th frame (15fps effective) to induce temporal aliasing without CPU kill
            if(frames % 4 === 0) {
                zPhase += 0.5;
                drawZone();
            }

            // G. Sync - Star Rotation (JS Driven now)
            // 1 revolution every 10 seconds (36 deg/s)
            const rot = (elapsed / 10000) * 360; 
            elStar.style.transform = `rotate(${rot}deg)`;

            // H. Sync - Audio Stereo Sweep
            // 0-500ms: Left, 1000-1500ms: Right, every 2s
            const audPhase = elapsed % 2000;
            if(audPhase < 100) { // Short blip
                if(!elIndL.classList.contains('sync-active')) {
                    elIndL.classList.add('sync-active');
                    triggerBeep('left');
                }
            } else {
                elIndL.classList.remove('sync-active');
            }

            if(audPhase > 1000 && audPhase < 1100) {
                if(!elIndR.classList.contains('sync-active')) {
                    elIndR.classList.add('sync-active');
                    triggerBeep('right');
                }
            } else {
                elIndR.classList.remove('sync-active');
            }

            // I. Motion UFO
            // Linear loop 0-100% every 2s
            const ufoP = (elapsed % 2000) / 2000;
            elUfo.style.left = (ufoP * 100) + '%';

            // FPS Calc
            fpsC++;
            if(t - lastFpsT >= 1000) {
                elFps.innerText = fpsC;
                fpsC = 0;
                lastFpsT = t;
            }

            frames++;
            requestAnimationFrame(loop);
        }

        document.getElementById('start').onclick = function() {
            this.style.display = 'none';
            drawGrid(); // Init grid
            initAudio();
            requestAnimationFrame(loop);
        };

    </script>
</body>
</html>