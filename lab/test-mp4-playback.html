<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP4 æ’­æ”¾é—®é¢˜è¯Šæ–­</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        .warning { background-color: #fff3cd; color: #856404; }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        video {
            max-width: 100%;
            margin: 10px 0;
            border: 1px solid #ddd;
        }
        .file-info {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .hex-dump {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>ğŸ” MP4 æ’­æ”¾é—®é¢˜è¯Šæ–­</h1>
    <p>è¯Šæ–­ç”Ÿæˆçš„ MP4 æ–‡ä»¶ä¸ºä»€ä¹ˆæ— æ³•æ’­æ”¾</p>
    
    <div class="test-section">
        <h2>1. å½•åˆ¶æµ‹è¯•è§†é¢‘</h2>
        <button id="recordBtn" onclick="startRecording()">å¼€å§‹å½•åˆ¶</button>
        <button id="stopBtn" onclick="stopRecording()" disabled>åœæ­¢å½•åˆ¶</button>
        <div id="recordingResults"></div>
        <video id="originalVideo" controls style="display: none;"></video>
    </div>
    
    <div class="test-section">
        <h2>2. ç”Ÿæˆ MP4 æ–‡ä»¶</h2>
        <button id="generateBtn" onclick="generateMP4()" disabled>ç”Ÿæˆ MP4</button>
        <div id="generateResults"></div>
        <video id="mp4Video" controls style="display: none;"></video>
        <div id="mp4Info" class="file-info" style="display: none;"></div>
    </div>
    
    <div class="test-section">
        <h2>3. æ–‡ä»¶æ ¼å¼åˆ†æ</h2>
        <button id="analyzeBtn" onclick="analyzeFile()" disabled>åˆ†ææ–‡ä»¶æ ¼å¼</button>
        <div id="analysisResults"></div>
        <div id="hexDump" class="hex-dump" style="display: none;"></div>
    </div>
    
    <div class="test-section">
        <h2>4. æ’­æ”¾æµ‹è¯•</h2>
        <button id="testPlayBtn" onclick="testPlayback()" disabled>æµ‹è¯•æ’­æ”¾</button>
        <div id="playbackResults"></div>
    </div>
    
    <div class="test-section">
        <h2>5. ä¿®å¤å»ºè®®</h2>
        <div id="fixSuggestions"></div>
    </div>

    <!-- åŠ è½½å¿…è¦çš„è„šæœ¬ -->
    <script src="popup/canvas-mp4-transcoder.js"></script>

    <script>
        let currentWebMBlob = null;
        let currentMP4Blob = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let transcoder = null;

        // åˆå§‹åŒ–
        window.onload = function() {
            transcoder = new CanvasMP4Transcoder();
            console.log('ğŸ” MP4 æ’­æ”¾é—®é¢˜è¯Šæ–­é¡µé¢å·²åŠ è½½');
        };

        // å¼€å§‹å½•åˆ¶
        async function startRecording() {
            const resultsDiv = document.getElementById('recordingResults');
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');

            try {
                resultsDiv.innerHTML = '<div class="result info">è¯·æ±‚å±å¹•å½•åˆ¶æƒé™...</div>';

                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { width: 1280, height: 720 },
                    audio: false
                });

                const mimeType = getSupportedWebMMimeType();
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000
                });

                recordedChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    currentWebMBlob = new Blob(recordedChunks, { type: mimeType });
                    
                    const originalVideo = document.getElementById('originalVideo');
                    originalVideo.src = URL.createObjectURL(currentWebMBlob);
                    originalVideo.style.display = 'block';

                    resultsDiv.innerHTML += `
                        <div class="result success">
                            âœ… å½•åˆ¶å®Œæˆï¼<br>
                            æ–‡ä»¶å¤§å°: ${formatFileSize(currentWebMBlob.size)}<br>
                            MIME ç±»å‹: ${currentWebMBlob.type}
                        </div>
                    `;

                    // å¯ç”¨ç”ŸæˆæŒ‰é’®
                    document.getElementById('generateBtn').disabled = false;

                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                
                recordBtn.disabled = true;
                stopBtn.disabled = false;

                resultsDiv.innerHTML += `
                    <div class="result success">
                        ğŸ“¹ å¼€å§‹å½•åˆ¶ WebM æ ¼å¼
                    </div>
                `;

            } catch (error) {
                resultsDiv.innerHTML += `
                    <div class="result error">
                        å½•åˆ¶å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        }

        // åœæ­¢å½•åˆ¶
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // ç”Ÿæˆ MP4
        async function generateMP4() {
            if (!currentWebMBlob) {
                alert('è¯·å…ˆå½•åˆ¶è§†é¢‘');
                return;
            }

            const resultsDiv = document.getElementById('generateResults');
            const generateBtn = document.getElementById('generateBtn');

            generateBtn.disabled = true;
            resultsDiv.innerHTML = '<div class="result info">æ­£åœ¨ç”Ÿæˆ MP4...</div>';

            try {
                currentMP4Blob = await transcoder.transcodeToMP4(currentWebMBlob, {
                    backgroundConfig: {
                        color: '#ffffff',
                        padding: 60,
                        outputRatio: '16:9'
                    },
                    quality: 'high',
                    progressCallback: (percent, message) => {
                        console.log(`ç”Ÿæˆè¿›åº¦: ${percent}% - ${message}`);
                    }
                });

                // æ˜¾ç¤º MP4 è§†é¢‘
                const mp4Video = document.getElementById('mp4Video');
                mp4Video.src = URL.createObjectURL(currentMP4Blob);
                mp4Video.style.display = 'block';

                // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
                const mp4Info = document.getElementById('mp4Info');
                mp4Info.innerHTML = `
                    æ–‡ä»¶å¤§å°: ${formatFileSize(currentMP4Blob.size)}
                    MIME ç±»å‹: ${currentMP4Blob.type}
                    åˆ›å»ºæ—¶é—´: ${new Date().toLocaleString()}
                `;
                mp4Info.style.display = 'block';

                resultsDiv.innerHTML += `
                    <div class="result success">
                        âœ… MP4 ç”Ÿæˆå®Œæˆï¼<br>
                        æ–‡ä»¶å¤§å°: ${formatFileSize(currentMP4Blob.size)}<br>
                        MIME ç±»å‹: ${currentMP4Blob.type}
                    </div>
                `;

                // å¯ç”¨åˆ†ææŒ‰é’®
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('testPlayBtn').disabled = false;

            } catch (error) {
                resultsDiv.innerHTML += `
                    <div class="result error">
                        MP4 ç”Ÿæˆå¤±è´¥: ${error.message}
                    </div>
                `;
            } finally {
                generateBtn.disabled = false;
            }
        }

        // åˆ†ææ–‡ä»¶æ ¼å¼
        async function analyzeFile() {
            if (!currentMP4Blob) {
                alert('è¯·å…ˆç”Ÿæˆ MP4 æ–‡ä»¶');
                return;
            }

            const resultsDiv = document.getElementById('analysisResults');
            const hexDump = document.getElementById('hexDump');

            resultsDiv.innerHTML = '<div class="result info">æ­£åœ¨åˆ†ææ–‡ä»¶æ ¼å¼...</div>';

            try {
                // è¯»å–æ–‡ä»¶å¤´éƒ¨
                const arrayBuffer = await currentMP4Blob.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // åˆ†ææ–‡ä»¶ç­¾å
                const fileSignature = analyzeFileSignature(uint8Array);
                
                // ç”Ÿæˆåå…­è¿›åˆ¶è½¬å‚¨
                const hexDumpText = generateHexDump(uint8Array, 256); // å‰256å­—èŠ‚
                
                hexDump.innerHTML = hexDumpText;
                hexDump.style.display = 'block';

                resultsDiv.innerHTML = `
                    <div class="result ${fileSignature.isValid ? 'success' : 'error'}">
                        <strong>æ–‡ä»¶æ ¼å¼åˆ†æ:</strong><br>
                        æ–‡ä»¶ç­¾å: ${fileSignature.signature}<br>
                        æ£€æµ‹æ ¼å¼: ${fileSignature.detectedFormat}<br>
                        æ˜¯å¦æœ‰æ•ˆ: ${fileSignature.isValid ? 'âœ… æ˜¯' : 'âŒ å¦'}<br>
                        æ–‡ä»¶å¤§å°: ${formatFileSize(arrayBuffer.byteLength)}<br>
                        ${fileSignature.details}
                    </div>
                `;

            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="result error">
                        æ–‡ä»¶åˆ†æå¤±è´¥: ${error.message}
                    </div>
                `;
            }
        }

        // æµ‹è¯•æ’­æ”¾
        async function testPlayback() {
            if (!currentMP4Blob) {
                alert('è¯·å…ˆç”Ÿæˆ MP4 æ–‡ä»¶');
                return;
            }

            const resultsDiv = document.getElementById('playbackResults');
            resultsDiv.innerHTML = '<div class="result info">æ­£åœ¨æµ‹è¯•æ’­æ”¾...</div>';

            try {
                // åˆ›å»ºå¤šä¸ªæµ‹è¯•è§†é¢‘å…ƒç´ 
                const tests = [
                    { name: 'æµè§ˆå™¨åŸç”Ÿæ’­æ”¾', test: testNativePlayback },
                    { name: 'Video å…ƒç´ åŠ è½½', test: testVideoElementLoad },
                    { name: 'MediaSource å…¼å®¹æ€§', test: testMediaSourceCompatibility }
                ];

                let results = [];

                for (const { name, test } of tests) {
                    try {
                        const result = await test(currentMP4Blob);
                        results.push(`âœ… ${name}: ${result}`);
                    } catch (error) {
                        results.push(`âŒ ${name}: ${error.message}`);
                    }
                }

                resultsDiv.innerHTML = `
                    <div class="result info">
                        <strong>æ’­æ”¾æµ‹è¯•ç»“æœ:</strong><br>
                        ${results.join('<br>')}
                    </div>
                `;

                // ç”Ÿæˆä¿®å¤å»ºè®®
                generateFixSuggestions(results);

            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="result error">
                        æ’­æ”¾æµ‹è¯•å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        }

        // åˆ†ææ–‡ä»¶ç­¾å
        function analyzeFileSignature(uint8Array) {
            const first4Bytes = Array.from(uint8Array.slice(0, 4))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');
            
            const first8Bytes = Array.from(uint8Array.slice(0, 8))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');

            // æ£€æŸ¥å¸¸è§çš„è§†é¢‘æ–‡ä»¶ç­¾å
            if (uint8Array[0] === 0x1A && uint8Array[1] === 0x45 && 
                uint8Array[2] === 0xDF && uint8Array[3] === 0xA3) {
                return {
                    signature: first4Bytes,
                    detectedFormat: 'WebM/Matroska',
                    isValid: true,
                    details: 'è¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ WebM æ–‡ä»¶ï¼Œä½†è¢«æ ‡è®°ä¸º MP4'
                };
            }

            // MP4 æ–‡ä»¶é€šå¸¸ä»¥ ftyp box å¼€å§‹
            if (uint8Array[4] === 0x66 && uint8Array[5] === 0x74 && 
                uint8Array[6] === 0x79 && uint8Array[7] === 0x70) {
                return {
                    signature: first8Bytes,
                    detectedFormat: 'MP4',
                    isValid: true,
                    details: 'è¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ MP4 æ–‡ä»¶'
                };
            }

            return {
                signature: first8Bytes,
                detectedFormat: 'æœªçŸ¥',
                isValid: false,
                details: 'æ–‡ä»¶ç­¾åä¸åŒ¹é…ä»»ä½•å·²çŸ¥çš„è§†é¢‘æ ¼å¼'
            };
        }

        // ç”Ÿæˆåå…­è¿›åˆ¶è½¬å‚¨
        function generateHexDump(uint8Array, maxBytes = 256) {
            const bytes = uint8Array.slice(0, maxBytes);
            let dump = '';
            
            for (let i = 0; i < bytes.length; i += 16) {
                const offset = i.toString(16).padStart(8, '0');
                const hexBytes = [];
                const asciiBytes = [];
                
                for (let j = 0; j < 16; j++) {
                    if (i + j < bytes.length) {
                        const byte = bytes[i + j];
                        hexBytes.push(byte.toString(16).padStart(2, '0'));
                        asciiBytes.push(byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.');
                    } else {
                        hexBytes.push('  ');
                        asciiBytes.push(' ');
                    }
                }
                
                dump += `${offset}: ${hexBytes.join(' ')} |${asciiBytes.join('')}|\n`;
            }
            
            return dump;
        }

        // æµ‹è¯•åŸç”Ÿæ’­æ”¾
        function testNativePlayback(blob) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.src = URL.createObjectURL(blob);
                
                const timeout = setTimeout(() => {
                    reject(new Error('åŠ è½½è¶…æ—¶'));
                }, 5000);

                video.onloadedmetadata = () => {
                    clearTimeout(timeout);
                    URL.revokeObjectURL(video.src);
                    resolve(`æˆåŠŸåŠ è½½ï¼Œå°ºå¯¸: ${video.videoWidth}Ã—${video.videoHeight}`);
                };

                video.onerror = () => {
                    clearTimeout(timeout);
                    URL.revokeObjectURL(video.src);
                    reject(new Error('è§†é¢‘åŠ è½½å¤±è´¥'));
                };
            });
        }

        // æµ‹è¯• Video å…ƒç´ åŠ è½½
        function testVideoElementLoad(blob) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                
                video.oncanplay = () => {
                    resolve('å¯ä»¥æ’­æ”¾');
                };

                video.onerror = (e) => {
                    reject(new Error(`åŠ è½½é”™è¯¯: ${e.target.error?.message || 'æœªçŸ¥é”™è¯¯'}`));
                };

                video.src = URL.createObjectURL(blob);
                
                setTimeout(() => {
                    URL.revokeObjectURL(video.src);
                    reject(new Error('æµ‹è¯•è¶…æ—¶'));
                }, 3000);
            });
        }

        // æµ‹è¯• MediaSource å…¼å®¹æ€§
        function testMediaSourceCompatibility(blob) {
            return new Promise((resolve) => {
                if (!window.MediaSource) {
                    resolve('MediaSource API ä¸å¯ç”¨');
                    return;
                }

                const isSupported = MediaSource.isTypeSupported(blob.type);
                resolve(isSupported ? 'æ”¯æŒ MediaSource' : 'MediaSource ä¸æ”¯æŒæ­¤æ ¼å¼');
            });
        }

        // ç”Ÿæˆä¿®å¤å»ºè®®
        function generateFixSuggestions(testResults) {
            const suggestionsDiv = document.getElementById('fixSuggestions');
            
            const hasPlaybackIssues = testResults.some(result => result.includes('âŒ'));
            const isWebMFormat = testResults.some(result => result.includes('WebM'));

            let suggestions = [];

            if (hasPlaybackIssues) {
                suggestions.push('ğŸ”§ æ£€æµ‹åˆ°æ’­æ”¾é—®é¢˜ï¼Œå»ºè®®ä¿®å¤ï¼š');
                
                if (isWebMFormat) {
                    suggestions.push('â€¢ æ–‡ä»¶å®é™…ä¸Šæ˜¯ WebM æ ¼å¼ï¼Œä½†è¢«æ ‡è®°ä¸º MP4');
                    suggestions.push('â€¢ ä¿®å¤ MIME ç±»å‹è®¾ç½®');
                    suggestions.push('â€¢ ä½¿ç”¨æ­£ç¡®çš„æ–‡ä»¶æ‰©å±•å');
                }
                
                suggestions.push('â€¢ æ£€æŸ¥ MediaRecorder é…ç½®');
                suggestions.push('â€¢ éªŒè¯ç¼–ç å‚æ•°');
                suggestions.push('â€¢ è€ƒè™‘ä½¿ç”¨ä¸“ä¸šçš„è½¬ç åº“');
            } else {
                suggestions.push('âœ… æ–‡ä»¶æ ¼å¼æ­£å¸¸ï¼Œæ’­æ”¾æµ‹è¯•é€šè¿‡');
            }

            suggestionsDiv.innerHTML = `
                <div class="result ${hasPlaybackIssues ? 'warning' : 'success'}">
                    ${suggestions.join('<br>')}
                </div>
            `;
        }

        // è·å–æ”¯æŒçš„ WebM MIME ç±»å‹
        function getSupportedWebMMimeType() {
            const types = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm'
            ];

            for (const type of types) {
                if (MediaRecorder.isTypeSupported(type)) {
                    return type;
                }
            }
            return 'video/webm';
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
