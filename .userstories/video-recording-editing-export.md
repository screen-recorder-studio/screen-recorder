# Screen Recorder Studio - 用户故事文档

> **项目概述**: Screen Recorder Studio 是一个基于 Chrome 扩展的开源屏幕录制工具，采用 WebCodecs + OPFS 技术栈，提供从录制、编辑到导出的完整视频处理流程。
>
> **当前版本**: 支持 Tab（标签页）、Window（窗口）、Screen（屏幕）三种核心录制模式，配备 Studio 非破坏性编辑器和多格式导出能力。
>
> **技术亮点**: 突破浏览器内存限制，支持无限时长录制；窗口化加载实现大文件流畅预览；所见即所得的编辑与导出工作流。

---

## 📋 目录

1. [录制场景用户故事](#1-录制场景用户故事)
2. [编辑场景用户故事](#2-编辑场景用户故事)
3. [导出场景用户故事](#3-导出场景用户故事)
4. [存储与管理场景](#4-存储与管理场景)
5. [技术创新与解决的核心问题](#5-技术创新与解决的核心问题)

---

## 1. 录制场景用户故事

### 1.1 多模式录制 - 适配不同内容类型

**用户故事**:
> 作为一名**产品经理**，我需要录制不同类型的演示内容，包括整个屏幕、特定窗口或浏览器标签页，以便为不同场景制作合适的演示视频。

**解决的问题**:
- ✅ **屏幕录制 (Screen)**: 录制整个桌面，适合系统级操作演示
- ✅ **窗口录制 (Window)**: 录制特定应用窗口，避免隐私泄露
- ✅ **标签页录制 (Tab)**: 录制浏览器标签页，适合 Web 应用演示

**技术实现**:
- 使用 Chrome Extension `desktopCapture` API 获取媒体流
- Offscreen Document 中调用 `getDisplayMedia` 并根据模式配置 `displaySurface` 参数
- 支持 Tab/Window/Screen 三种基础录制模式，简化用户选择

> **注**: 项目代码中保留了 Element（DOM 元素）和 Area（自定义区域）录制的底层实现（基于 RestrictionTarget/CropTarget API），但当前版本 UI 层面已隐藏这两种高级模式，聚焦于核心录制场景。

---

### 1.2 智能倒计时 - 准备充分再录制

**用户故事**:
> 作为一名**教育工作者**，我在开始录制前需要时间调整窗口布局、准备演示内容、切换到目标应用。我希望点击录制后有几秒钟的缓冲时间，并且有清晰的视觉和听觉提示告诉我录制何时开始，避免录制到准备过程。

**解决的问题**:
- ✅ **可配置倒计时**:
  - 支持 1-5 秒倒计时，用户可根据需求调整
  - 在 Popup 界面选择倒计时时长
  - 默认 3 秒，适合大多数场景
- ✅ **视觉与听觉反馈**:
  - **全屏倒计时显示**: 独立页面 (`countdown.html`) 全屏显示倒计时数字
  - **大号数字**: 清晰可见的倒计时数字（5 → 4 → 3 → 2 → 1）
  - **音频提示**: 每秒播放 beep 音效，倒计时结束时播放"开始"提示音
  - **颜色变化**: 倒计时数字颜色渐变，增强视觉反馈
- ✅ **状态持久化**:
  - 倒计时设置保存到 `chrome.storage.local`
  - 下次使用自动恢复上次选择的时长
  - 当前为本机持久化（`storage.local` 不跨设备同步；如需跨设备可改用 `chrome.storage.sync`）
- ✅ **统一体验**:
  - 所有录制模式（Tab/Window/Screen）共享统一倒计时流程
  - 倒计时期间可以自由操作其他窗口
  - 倒计时结束后自动关闭倒计时页面，开始录制
- ✅ **用户控制**:
  - 倒计时期间可以取消录制（关闭倒计时页面）
  - 支持跳过倒计时（设置为 0 秒）

**技术实现**:
- 倒计时在独立页面 (`countdown.html`) 中运行，避免干扰录制流程
- 使用 Web Audio API 生成 beep 音效（AudioContext + OscillatorNode）
- Background Service Worker 协调倒计时与录制启动
- 倒计时结束后通过消息通知 Service Worker 启动录制
- 倒计时页面自动关闭，释放资源

---

### 1.3 高性能编码 - WebCodecs 硬件加速

**用户故事**:
> 作为一名**内容创作者**，我需要录制高分辨率（4K）、高帧率（60fps）的视频，同时保持系统流畅运行，不能因为录制导致电脑卡顿。

**解决的问题**:
- ✅ **硬件加速编码**: 使用 WebCodecs API 调用 GPU 硬件编码器（VP9/H.264）
- ✅ **Worker 架构**: 编码任务在 Dedicated Worker 中执行，不阻塞主线程
- ✅ **实时性能监控**: 实时显示 FPS、码率、CPU 使用率
- ✅ **关键帧策略**: 每 2 秒强制插入关键帧（GOP=60 @ 30fps），平衡文件大小与随机访问性能

**技术实现**:
- `encoder-worker.ts` 使用 VideoEncoder API 进行帧编码
- `offscreen-main.ts` 在 Offscreen Document 中运行，利用 MV3 架构
- 码率自适应：根据分辨率和质量设置动态调整（4K 高保真文字预留足够码率）

---

### 1.4 无限时长录制 - OPFS 流式存储

**用户故事**:
> 作为一名**会议记录员**，我需要录制长达 1-2 小时的会议视频，传统方案会因内存不足而崩溃，我需要一个能够稳定录制长视频的工具。

**解决的问题**:
- ✅ **突破内存限制**: 使用 OPFS (Origin Private File System) 实时写入磁盘，避免内存溢出
- ✅ **流式追加写入**: 编码块实时追加到 `data.bin`，无需等待录制结束
- ✅ **崩溃恢复**: 即使浏览器崩溃，已写入的数据仍可恢复（通过 `meta.json` 标记完成状态）
- ✅ **索引分离**: `index.jsonl` 行式索引文件，支持快速时间定位

**技术实现**:
- `opfs-writer-worker.ts` 使用 SyncAccessHandle 进行同步写入（仅在 Worker 中可用）
- 存储结构：`rec_<session>/data.bin` + `index.jsonl` + `meta.json`
- 每 100 个 chunk 批量刷新索引，平衡性能与可靠性

---

### 1.5 暂停/恢复 - 灵活控制录制流程

**用户故事**:
> 作为一名**软件演示者**，我在录制过程中可能需要临时处理突发情况（如接电话、调整演示内容），需要暂停录制功能，而不是重新开始。

**解决的问题**:
- ✅ **无缝暂停/恢复**: 点击暂停后停止帧捕获，恢复后继续录制
- ✅ **状态同步**: 暂停状态在 UI（Popup/Control/SidePanel）间实时同步
- ✅ **时间戳连续性**: 暂停期间不写入帧，恢复后时间戳保持连续

**技术实现**:
- `isPaused` 状态通过 `STREAM_META` 消息广播
- 帧循环中检查 `isPaused` 标志，暂停时跳过编码

---

### 1.6 摄像头 + 语音录制 - 画中画讲解视频

**用户故事**:
> 作为一名**教育工作者**，我需要在录制屏幕操作的同时录制我的摄像头画面和语音讲解，并将它们合成到最终视频中（画中画效果），以便学生能够看到我的面部表情和听到我的讲解，增强教学效果和互动感。

**解决的问题**:
- ⏳ **摄像头录制**:
  - 使用 `getUserMedia({ video: true })` 获取摄像头流
  - 支持选择摄像头设备（前置/后置/外接）
  - 实时预览摄像头画面
  - 使用 `VideoEncoder` 编码为 VP9/H.264（720p 30fps）
  - 独立存储到 OPFS：`camera.bin` + `camera-index.jsonl`
- ⏳ **音频录制**:
  - 使用 `getUserMedia({ audio: true })` 获取麦克风流
  - 支持选择音频输入设备
  - 实时音量监控（可视化音量条）
  - 使用 `AudioEncoder` 编码为 Opus（192kbps 立体声）
  - 独立存储到 OPFS：`audio.bin` + `audio-index.jsonl`
- ⏳ **画中画合成**:
  - 在 Composite Worker 中将摄像头画面叠加到屏幕录制画面上
  - 支持 4 个位置：左下角/右下角/左上角/右上角
  - 可调整摄像头画面大小（小/中/大）
  - 可调整摄像头画面圆角和边框
  - 支持拖拽调整位置（编辑时）
- ⏳ **音画同步**:
  - 基于 `timestamp` 字段对齐视频和音频轨道
  - 自动处理时间戳偏移（摄像头/屏幕/音频可能不同步启动）
  - 导出时精确合成音视频轨道
- ⏳ **用户控制**:
  - 录制前选择是否启用摄像头/音频
  - 录制中可以临时关闭摄像头/静音
  - 编辑时可以隐藏摄像头画面
  - 编辑时可以调整音频音量

**技术实现**:
- `getUserMedia()` API 获取摄像头和麦克风流
- `VideoEncoder` 编码摄像头视频（独立编码器实例）
- `AudioEncoder` 编码音频（Opus 编解码器）
- OPFS 存储扩展：
  ```
  rec_<id>/
  ├── data.bin              # 屏幕录制视频数据
  ├── index.jsonl           # 屏幕录制视频索引
  ├── camera.bin            # 🆕 摄像头视频数据
  ├── camera-index.jsonl    # 🆕 摄像头视频索引
  ├── audio.bin             # 🆕 音频数据
  ├── audio-index.jsonl     # 🆕 音频索引
  └── meta.json             # 元数据（包含摄像头/音频配置）
  ```
- `composite-worker` 扩展：
  - 同时解码屏幕视频和摄像头视频
  - 在 Canvas 上合成画中画效果
  - 混合音频轨道（屏幕音频 + 麦克风音频）
- 存储开销估算：
  - 音频：约 1.4 MB/分钟（192kbps Opus）
  - 摄像头视频：约 5-10 MB/分钟（720p 30fps VP9）
  - 总增量：约 6.4-11.4 MB/分钟

**依赖关系**:
- 对应可行性分析中的 **F-1 (真人出镜)** 和 **F-2 (画中画合成)**
- 预计工作量：7-11 天（摄像头录制）+ 17-24 天（画中画合成）= **24-35 天**

---

### 1.7 页面标注工具 - 实时标注重点内容

**用户故事**:
> 作为一名**技术博主**，我需要在录制网页教程时实时标注重点内容（圈选重要按钮、添加文字说明、绘制箭头指示），以便观众更容易理解关键信息和操作步骤，提升教程的清晰度和专业性。

**解决的问题**:
- ⏳ **标注工具栏**:
  - 在录制 Tab 时，页面左下角显示浮动工具栏
  - 包含 7 种标注工具：箭头、矩形、圆形、自由绘制、文字、高亮、模糊
  - 颜色选择器（预设 + 自定义）
  - 线宽调节器（1-10px）
  - 撤销/重做按钮
  - 清除所有标注按钮
- ⏳ **标注工具详解**:
  - **箭头**: 拖拽绘制箭头，指向重点内容
  - **矩形**: 拖拽绘制矩形框，圈选区域
  - **圆形**: 拖拽绘制圆形，突出显示
  - **自由绘制**: 鼠标轨迹路径，手绘标注
  - **文字**: 点击位置输入文本，添加说明
  - **高亮**: 半透明黄色矩形，高亮重点
  - **模糊**: 模糊区域，隐私保护（如隐藏敏感信息）
- ⏳ **标注时间控制**:
  - 每个标注可设置持续时间：
    - **永久显示**: 从创建时刻到视频结束
    - **5 秒**: 创建后显示 5 秒自动消失
    - **10 秒**: 创建后显示 10 秒自动消失
    - **自定义**: 手动设置持续时间
  - 标注自动记录创建时间戳
  - 编辑时可以调整标注的出现/消失时间
- ⏳ **Canvas 绘制层**:
  - 全屏透明 Canvas 覆盖在页面上（z-index: 2147483646）
  - 仅在绘制时启用 `pointer-events`，不干扰页面交互
  - 实时绘制标注，所见即所得
  - 标注完成后自动保存到 OPFS
- ⏳ **归一化坐标**:
  - 标注坐标使用 0-1 范围的相对坐标
  - 适配不同分辨率和窗口大小
  - 导出时根据实际分辨率计算像素坐标
- ⏳ **编辑与管理**:
  - 录制时可以删除已创建的标注
  - 编辑时可以调整标注的时间范围
  - 编辑时可以修改标注的样式（颜色、线宽）
  - 支持导出时隐藏所有标注

**技术实现**:
- Content Script 注入标注工具栏（仅在 Tab 录制模式下）
- 全屏 Canvas 绘制层，使用 2D Context 绘制标注
- OPFS 存储扩展：
  ```
  rec_<id>/
  ├── data.bin              # 视频数据
  ├── index.jsonl           # 视频索引
  ├── annotations.jsonl     # 🆕 标注数据
  └── meta.json             # 元数据
  ```
- `annotations.jsonl` 格式：
  ```jsonl
  {"id":"ann_1","tool":"rectangle","timestamp":1000000,"duration":5000000,"geometry":{"type":"rect","points":[{"x":0.1,"y":0.2},{"x":0.3,"y":0.4}]},"style":{"color":"#ff0000","lineWidth":3,"fillOpacity":0}}
  {"id":"ann_2","tool":"text","timestamp":2000000,"duration":0,"geometry":{"type":"text","points":[{"x":0.5,"y":0.5}],"text":"重点"},"style":{"color":"#00ff00","lineWidth":1,"fillOpacity":1}}
  {"id":"ann_3","tool":"arrow","timestamp":3000000,"duration":10000000,"geometry":{"type":"path","points":[{"x":0.2,"y":0.3},{"x":0.4,"y":0.5}]},"style":{"color":"#0000ff","lineWidth":2,"fillOpacity":0}}
  ```
- `composite-worker` 扩展：
  - 读取 `annotations.jsonl` 文件
  - 根据当前时间戳过滤可见标注
  - 在 Canvas 上绘制标注层
  - 叠加到视频帧上
- 存储开销：约 200-500 字节/标注，50 个标注约 10-25 KB

**依赖关系**:
- 对应可行性分析中的 **F-8 (页面标注工具)**
- 基于现有 Content Script (`src/extensions/content.ts`)
- 基于现有 Canvas 绘制能力 (`VideoCropPanel.svelte`)
- 预计工作量：**12-18 天**

---

### 1.8 鼠标轨迹录制 - 专业指针效果

**用户故事**:
> 作为一名**产品演示者**，我需要录制鼠标移动轨迹，并在编辑时能够切换不同的鼠标指针样式（默认箭头/手型/放大镜/自定义图片），以便制作更专业的产品演示视频，帮助观众清晰地跟随我的操作步骤。

**解决的问题**:
- ⏳ **自动鼠标轨迹录制**:
  - 使用 CaptureController API 自动捕获鼠标事件
  - 无需用户额外操作，录制时自动启用
  - 记录鼠标坐标（surfaceX, surfaceY）和时间戳
  - 检测鼠标是否在捕获区域内（isInside）
  - 高频采样（60fps），流畅轨迹
- ⏳ **鼠标指针样式库**:
  - **默认箭头**: 黑色箭头指针（系统默认样式）
  - **手型**: 手指点击图标（适合点击操作演示）
  - **放大镜**: 放大镜图标（适合细节查看）
  - **自定义**: 用户上传 PNG/SVG 图片作为指针
  - 每种样式支持调整大小（小/中/大）
- ⏳ **编辑时指针控制**:
  - 在 Studio 编辑器中选择指针样式
  - 实时预览指针效果
  - 调整指针大小和透明度
  - 支持隐藏/显示鼠标轨迹
  - 支持为不同时间段设置不同指针样式
- ⏳ **高级功能**:
  - **点击高亮**: 鼠标点击时显示圆形波纹动画
  - **轨迹淡化**: 鼠标移动轨迹渐隐效果
  - **焦点跟随**: 自动放大鼠标周围区域（配合 Zoom 功能）
- ⏳ **性能优化**:
  - 鼠标事件自动节流，避免过高采样率
  - 存储时压缩坐标数据（整数坐标）
  - 合成时预渲染指针图片，避免重复绘制

**技术实现**:
- CaptureController API（Chrome 109+）：
  ```typescript
  const captureController = new CaptureController()
  captureController.oncapturedmousechange = (event) => {
    const mouseEvent = {
      timestamp: performance.now() * 1000,  // 微秒
      x: event.surfaceX,
      y: event.surfaceY,
      isInside: event.surfaceX !== -1 && event.surfaceY !== -1
    }
    // 发送到 OPFS Writer
    mouseTrackWriter.postMessage({ type: 'append', event: mouseEvent })
  }

  const stream = await navigator.mediaDevices.getDisplayMedia({
    video: true,
    controller: captureController
  })
  ```
- OPFS 存储扩展：
  ```
  rec_<id>/
  ├── data.bin              # 视频数据
  ├── index.jsonl           # 视频索引
  ├── mouse.jsonl           # 🆕 鼠标轨迹数据
  └── meta.json             # 元数据
  ```
- `mouse.jsonl` 格式：
  ```jsonl
  {"timestamp":0,"x":100,"y":200,"isInside":true}
  {"timestamp":16666,"x":105,"y":205,"isInside":true}
  {"timestamp":33333,"x":110,"y":210,"isInside":true}
  {"timestamp":50000,"x":-1,"y":-1,"isInside":false}
  ```
- `composite-worker` 扩展：
  - 读取 `mouse.jsonl` 文件
  - 根据当前时间戳查找鼠标位置
  - 在 Canvas 上绘制鼠标指针
  - 支持多种指针样式（SVG/PNG）
- 指针绘制示例：
  ```typescript
  function drawMouseCursor(ctx: CanvasRenderingContext2D, x: number, y: number, style: MouseCursorStyle) {
    if (style.type === 'default') {
      // 绘制默认箭头指针
      ctx.fillStyle = '#000'
      ctx.strokeStyle = '#fff'
      ctx.lineWidth = 1
      ctx.beginPath()
      ctx.moveTo(x, y)
      ctx.lineTo(x, y + 20)
      ctx.lineTo(x + 7, y + 13)
      ctx.closePath()
      ctx.fill()
      ctx.stroke()
    } else if (style.type === 'custom' && style.imageUrl) {
      // 绘制自定义图片
      const img = await loadImage(style.imageUrl)
      ctx.drawImage(img, x, y, style.size, style.size)
    }
  }
  ```
- 存储开销：约 50 字节/事件，60fps × 300秒 = 18,000 事件 = **900 KB**
- 浏览器支持：Chrome 109+, Edge 109+

**依赖关系**:
- 对应可行性分析中的 **F-8 (鼠标轨迹录制)**
- 已验证可行性（`lab/CaptureController/`）
- 基于现有 OPFS 存储架构
- 预计工作量：**8-12 天**

---

## 2. 编辑场景用户故事

### 2.1 Studio 预览 - 大文件流畅预览

**用户故事**:
> 作为一名**视频编辑者**，我录制了一个 2GB、时长 1 小时的长视频，需要在浏览器中流畅预览和编辑。我希望打开 Studio 后能够立即开始播放，而不需要等待整个文件加载完成，并且在播放过程中不会因为内存不足而卡顿或崩溃。

**解决的问题**:
- ✅ **窗口化加载**:
  - 仅加载当前播放窗口的帧（默认 60 帧），而非全部视频
  - 首次打开时快速加载前 60 帧，立即可播放
  - 根据播放位置动态加载所需窗口
- ✅ **关键帧对齐**:
  - 自动从请求位置之前的最近关键帧开始加载
  - 确保解码器有完整的参考帧，避免解码错误
  - 索引文件记录关键帧位置，快速定位
- ✅ **滑动窗口**:
  - 播放到窗口边界时自动加载下一窗口
  - 预加载机制：提前加载下一窗口，实现无缝连续播放
  - 支持向前/向后播放，双向窗口管理
- ✅ **内存管理**:
  - 解码帧缓存上限 150 帧（约 5 秒 @ 30fps）
  - 超出上限自动释放最旧的帧（LRU 策略）
  - 防止内存溢出，确保长时间编辑稳定性
- ✅ **播放控制**:
  - 播放/暂停按钮
  - 时间轴拖拽跳转
  - 键盘快捷键：空格（播放/暂停）、左右箭头（逐帧）
  - 播放速度控制：0.25x、0.5x、1x、1.5x、2x
- ✅ **实时预览编辑效果**:
  - 所有编辑效果（Crop、Zoom、Background）实时应用到预览
  - 调整参数时立即看到效果
  - 非破坏性编辑，原始数据不变

**技术实现**:
- `opfs-reader-worker.ts` 按范围读取 `data.bin` 文件，解析 `index.jsonl` 定位帧
- `composite-worker` 管理解码帧缓存，使用 LRU 策略释放旧帧
- `VideoPreviewComposite.svelte` 协调窗口请求与播放控制
- `VideoDecoder` API 硬件加速解码，提升性能
- Canvas 渲染管线：解码 → Crop → Zoom → 合成背景 → 显示

---

### 2.2 视频裁剪 (Trim) - 精确剪辑时间范围

**用户故事**:
> 作为一名**教程制作者**，我录制了 10 分钟的视频，但只需要其中 2-5 分钟的片段。我需要在时间轴上精确选择起止时间，并且能够通过拖拽手柄或键盘方向键进行微调，确保裁剪点准确无误。

**解决的问题**:
- ✅ **可视化时间轴**: 拖拽式裁剪手柄，直观选择起止时间
- ✅ **帧级精度**: 支持按帧精确定位（基于帧率计算）
  - 方向键：±1 帧微调
  - Shift + 方向键：±10 帧快速调整
- ✅ **实时预览**:
  - 裁剪范围外的区域显示半透明遮罩
  - 拖拽手柄时自动跳转到对应时间点预览
  - 激活区域高亮显示
- ✅ **交互反馈**:
  - 手柄拖拽时显示当前时间
  - 最小时长限制（100ms），防止误操作
  - 边界自动限制，防止超出视频范围
- ✅ **非破坏性编辑**: 裁剪仅改变导出参数，原始 OPFS 数据保持完整

**技术实现**:
- `trim.svelte.ts` 管理裁剪状态（startMs/endMs/startFrame/endFrame）
- `Timeline.svelte` 提供交互式时间轴 UI，支持鼠标拖拽和键盘操作
- 导出时根据时间戳过滤帧，重新计算时间戳从 0 开始

---

### 2.3 视频裁切 (Crop) - 精确选择画面区域

**用户故事**:
> 作为一名**社交媒体运营者**，我需要将 16:9 的录屏视频裁切为 1:1 方形，以适配 Instagram 等平台的展示要求。我希望能够在静态画面上直观地选择裁切区域，通过拖拽调整位置和大小，并能锁定比例以保持一致性。

**解决的问题**:
- ✅ **源空间裁切**: 在原始视频分辨率空间下定义裁切区域，确保像素级精度
- ✅ **交互式编辑**:
  - **拖拽移动**: 点击裁切框内部拖动整体位置
  - **八向调整**: 四角 + 四边共 8 个调整手柄，自由调整大小
  - **键盘微调**: 方向键 ±1px 移动，Shift + 方向键 ±10px 快速移动
  - **数值输入**: 直接输入 X/Y/宽度/高度精确数值
- ✅ **比例控制**:
  - **比例锁定开关**: 点击锁定图标固定宽高比
  - **预设比例**: 一键应用 16:9、1:1、4:3、9:16 等常用比例
  - **自动居中**: 应用预设时自动居中裁切框
- ✅ **可视化辅助**:
  - 当前帧静态显示，避免播放干扰
  - 裁切框外区域半透明遮罩
  - 实时显示裁切区域尺寸和位置
  - 边界自动限制，防止超出视频范围
- ✅ **操作流程**:
  - 点击 "Crop" 按钮进入裁切模式
  - 调整裁切框到满意位置
  - 点击 "Apply" 应用，或 "Cancel" 取消
  - 点击 "Reset" 恢复到全画面

**技术实现**:
- `video-crop.svelte.ts` 管理裁切状态（像素/百分比双模式，自动同步）
- `VideoCropPanel.svelte` 提供静态帧上的裁切框交互 UI
- `composite-worker` 在渲染管线中执行实际裁切（源裁切 → Zoom → 合成）
- 裁切参数以百分比存储，适配不同分辨率导出

---

### 2.4 视频缩放 (Zoom) - 动态聚焦关键内容

**用户故事**:
> 作为一名**产品演示者**，我需要在视频的特定时间段放大某个按钮或文本区域，让观众清楚看到操作细节。我希望能够在时间轴上直观地创建缩放区间，点击视频画面设置焦点，并选择合适的缩放效果（平滑推进或瞬间放大）。

**解决的问题**:
- ✅ **时间区间管理**:
  - **创建区间**: 在时间轴 Zoom 轨道上点击创建默认 1500ms 区间
  - **调整区间**: 拖拽区间两端手柄调整起止时间
  - **移动区间**: 拖拽区间主体整体移动
  - **删除区间**: 点击区间内的删除按钮
  - **防重叠**: 自动检测区间重叠，拒绝创建冲突区间
- ✅ **焦点设置**:
  - **可视化选择**: 点击区间内的焦点按钮，在静态画面上点击设置焦点
  - **精确定位**: 拖拽焦点十字准星微调位置
  - **坐标空间**: 支持源空间（原始视频）/布局空间（含背景）两种坐标系
  - **实时预览**: 调整焦点时实时显示缩放效果
- ✅ **缩放参数**:
  - **缩放倍数**: 1.25x、1.5x、2.0x、2.5x、3.0x 可选
  - **缩放模式**:
    - **Dolly 模式**: 焦点移动到画面中心（适合特写/强调）
    - **Anchor 模式**: 焦点位置固定（适合教程/细节检查）
  - **缓动效果**:
    - **Smooth**: 平滑加速减速（easeInOutCubic）
    - **Linear**: 匀速运动
    - **Instant**: 瞬间跳转（无过渡）
  - **过渡时长**: 0ms、150ms、300ms、500ms、1000ms 可选
  - **背景同步**: 可选背景同步放大，创造"推进"效果
- ✅ **可视化反馈**:
  - 时间轴上显示所有 Zoom 区间（蓝色渐变块）
  - 区间编号标识，便于管理多个区间
  - 悬停显示区间时间范围
  - 播放时自动应用缩放效果

**技术实现**:
- `video-zoom.svelte.ts` 管理缩放区间列表和全局焦点
- `VideoFocusPanel.svelte` 提供焦点选择和参数配置 UI
- `Timeline.svelte` 提供 Zoom 轨道交互（创建/调整/删除区间）
- `composite-worker` 计算缓动插值，应用变换矩阵实时渲染

---

### 2.5 背景美化 - 专业视觉效果

**用户故事**:
> 作为一名**品牌营销人员**，我需要为录屏视频添加品牌色背景、圆角、阴影等效果，使视频更符合品牌视觉规范。我希望能够从预设模板中快速选择，也能够自定义每个参数以匹配精确的品牌色值。

**解决的问题**:
- ✅ **多种背景类型**:
  - **壁纸背景**:
    - 内置 20+ 高质量壁纸（风景、抽象、渐变等）
    - 分类浏览（Nature、Abstract、Gradient、Minimal）
    - 一键应用，自动适配视频尺寸
  - **渐变背景**:
    - 线性渐变（Linear）：可调节角度和颜色停靠点
    - 径向渐变（Radial）：从中心向外扩散
    - 锥形渐变（Conic）：旋转色轮效果
    - 多色渐变（Multi）：支持 3+ 颜色停靠点
    - 预设模板：20+ 精选渐变配色
  - **纯色背景**:
    - 分类预设（Basic、Light、Business、Creative）
    - 自定义颜色选择器
    - 常用品牌色快速访问
  - **图片背景**:
    - 用户上传自定义图片
    - 适配模式：Cover、Contain、Fill
    - 位置调整：Center、Top、Bottom、Left、Right
    - 模糊效果：0-20px 可调
    - 透明度：0-100% 可调
- ✅ **视频装饰**:
  - **Padding（边距）**:
    - 滑块调节：0-200px
    - 预设值：0、30、60、120、200px
    - 实时预览效果
  - **Border Radius（圆角）**:
    - 滑块调节：0-100px
    - 预设值：0、20、40、60、80px
    - 适合创建圆润视觉风格
  - **Shadow（阴影）**:
    - 开关控制：一键启用/禁用
    - 偏移量：X/Y 方向独立调节
    - 模糊半径：0-50px
    - 颜色选择器 + 透明度
    - 预设效果：Light、Standard、Deep、Distant
- ✅ **工作流程**:
  - 选择背景类型（Wallpaper/Gradient/Solid/Image）
  - 从预设中选择或自定义参数
  - 调整 Padding、Border Radius、Shadow
  - 实时预览效果
  - 导出时自动应用所有装饰

**技术实现**:
- `background-config.svelte.ts` 管理背景配置状态，支持配置历史恢复
- `BackgroundPicker/` 组件集：
  - `WallpaperPanel.svelte` - 壁纸选择
  - `GradientPanel.svelte` - 渐变配置
  - `SolidColorPanel.svelte` - 纯色选择
  - `ImageUploadPanel.svelte` - 图片上传
- `PaddingControl.svelte` / `BorderRadiusControl.svelte` / `ShadowControl.svelte` 提供装饰参数控件
- `composite-worker` 在 Canvas 上渲染背景、应用圆角和阴影
- 壁纸图片通过 `fetch` 加载并转换为 ImageBitmap，传递给 Worker

---

### 2.6 悬停预览 - 快速定位关键帧

**用户故事**:
> 作为一名**视频编辑者**，我需要在时间轴上快速浏览视频内容，找到需要编辑的关键帧。我希望鼠标悬停在时间轴上时就能看到对应画面，而不需要反复点击播放和暂停。

**解决的问题**:
- ✅ **鼠标悬停预览**:
  - 鼠标移动到时间轴上时，实时显示对应帧的画面
  - 预览画面包含所有编辑效果（Crop、Zoom、Background）
  - 帧对齐：自动对齐到最近的帧边界，确保预览准确
- ✅ **非破坏性**:
  - 预览不影响当前播放状态
  - 移开鼠标自动恢复到原来的播放位置
  - 如果正在播放，预览时暂停，移开后继续播放
- ✅ **性能优化**:
  - 预览使用已解码的帧缓存，避免重复解码
  - 窗口化加载策略，仅加载预览范围附近的帧
  - 节流处理，避免频繁跳转
- ✅ **视觉反馈**:
  - 时间轴上显示悬停位置的垂直线
  - 显示当前悬停时间（格式化为 MM:SS.mmm）

**技术实现**:
- `Timeline.svelte` 监听 `mousemove` 事件，计算对应时间并触发 `onHoverPreview`
- `VideoPreviewComposite.svelte` 处理预览回调：
  - 保存当前播放状态（位置、播放/暂停）
  - 临时跳转到预览帧
  - 鼠标移开时恢复原状态
- 使用 `isPreviewMode` 标志区分预览和正常播放

---

## 3. 导出场景用户故事

### 3.1 多格式导出 - 适配不同平台需求

**用户故事**:
> 作为一名**多平台内容创作者**，我需要将同一个录屏导出为不同格式以适配不同平台：MP4 用于 YouTube 上传，WebM 用于网站嵌入（更小的文件体积），GIF 用于社交媒体预览（无需播放器）。我希望能够在导出时选择格式，并根据平台要求调整参数。

**解决的问题**:
- ✅ **MP4 (H.264)**:
  - 最广泛兼容的格式，适合视频平台（YouTube、Vimeo）和移动设备
  - 硬件解码支持，播放流畅
  - 支持可变码率（VBR）和恒定码率（CBR）
  - 适合长视频和高质量存档
- ✅ **WebM (VP9)**:
  - 开源免费，无专利费用
  - 文件体积比 H.264 小 20-50%（相同质量）
  - 适合网页嵌入，浏览器原生支持
  - 适合带宽受限场景
- ✅ **GIF**:
  - 无需播放器，自动循环播放
  - 适合短片段预览（3-10 秒）
  - 社交媒体友好（Twitter、Slack、Discord）
  - 可调参数：
    - **帧率**: 10fps、15fps、24fps、30fps
    - **抖动**: Floyd-Steinberg 抖动算法，改善色彩过渡
    - **质量**: 1-100，控制颜色量化
    - **循环次数**: 无限循环或指定次数
    - **分辨率**: 建议缩小到 480p 或 720p 以减小文件大小
- ✅ **格式选择流程**:
  - 在导出对话框选择目标格式
  - 根据格式显示相关参数选项
  - 实时预估文件大小
  - 一键导出或批量导出多种格式

**技术实现**:
- `export-worker/strategies/mp4.ts` - MP4 导出策略（Mediabunny + H.264）
- `export-worker/strategies/webm.ts` - WebM 导出策略（VP9）
- `export-worker/strategies/gif.ts` - GIF 导出策略（gif.js 库）
- `export-manager.ts` 统一调度导出流程
- WebCodecs API 重新编码，应用所有编辑效果
- 流式写入 OPFS，支持大文件导出

---

### 3.2 质量与性能平衡 - 灵活配置导出参数

**用户故事**:
> 作为一名**在线教育讲师**，我需要在视频质量和文件大小之间找到平衡：高质量版本用于付费课程下载，压缩版本用于在线预览。我希望能够通过预设快速选择，也能够手动调整每个参数以满足特定需求。

**解决的问题**:
- ✅ **质量预设**:
  - **Draft（草稿）**: 低码率，快速导出，适合测试
  - **Balanced（平衡）**: 中等质量，文件大小适中，适合在线分享
  - **High（高质量）**: 高码率，适合专业用途
  - **Best（最佳）**: 最高质量，适合存档和二次编辑
- ✅ **分辨率调整**:
  - 保持原始分辨率
  - 自定义缩放：50%、75%、100%、125%、150%
  - 常用分辨率预设：1080p、720p、480p
  - 自动计算裁切后的输出分辨率
- ✅ **帧率控制**:
  - 保持原始帧率
  - 降低帧率减小文件大小：60fps → 30fps、30fps → 24fps
  - 自动调整关键帧间隔
- ✅ **码率配置**:
  - 自动计算：基于分辨率、帧率和质量预设
  - 手动指定：支持自定义码率（Kbps/Mbps）
  - 实时预估文件大小
- ✅ **格式特定选项**:
  - **MP4**: H.264 编码，兼容性最佳
  - **WebM**: VP9 编码，开源免费
  - **GIF**: 帧率、抖动、质量、循环次数可调
- ✅ **导出进度反馈**:
  - 阶段显示：Preparing → Compositing → Encoding → Muxing → Finalizing
  - 进度百分比和已处理帧数
  - 预计剩余时间
  - 实时码率和文件大小

**技术实现**:
- `VideoExportDialog.svelte` / `UnifiedExportDialog.svelte` 提供参数配置 UI
- 自动码率计算公式：`pixels × framerate × qualityFactor`
- `export-worker` 根据配置调用不同的导出策略
- 导出进度通过 Worker 消息实时更新

---

### 3.3 编辑效果应用 - 所见即所得导出

**用户故事**:
> 作为一名**视频编辑者**，我在 Studio 中花费时间精心调整了裁剪范围、裁切区域、缩放焦点、背景装饰等效果。我希望导出的视频完全符合预览效果，所有编辑都准确应用，不会出现预览和导出不一致的情况。

**解决的问题**:
- ✅ **Trim 应用**:
  - 仅导出裁剪范围内的帧（trimStartMs 到 trimEndMs）
  - 重新计算时间戳，从 0 开始
  - 保持帧率和关键帧间隔
- ✅ **Crop 应用**:
  - 导出时应用源空间裁切（cropX, cropY, cropWidth, cropHeight）
  - 输出分辨率自动调整为裁切后的尺寸
  - 保持像素级精度，无质量损失
- ✅ **Zoom 应用**:
  - 导出时应用所有缩放区间（startMs-endMs）
  - 精确计算每帧的缩放倍数和焦点位置
  - 应用缓动效果（Smooth/Linear/Instant）
  - 支持 Dolly/Anchor 两种模式
  - 背景同步选项生效
- ✅ **背景应用**:
  - 渲染背景（纯色/渐变/图片/壁纸）
  - 应用 Padding（边距）
  - 应用 Border Radius（圆角）
  - 应用 Shadow（阴影效果）
  - 所有装饰效果与预览完全一致
- ✅ **渲染一致性**:
  - 使用与预览相同的渲染管线
  - 相同的 Canvas 绘制逻辑
  - 相同的变换矩阵计算
  - 确保"所见即所得"

**技术实现**:
- `export-worker` 使用与预览相同的 `composite-worker` 渲染逻辑
- 逐帧渲染到 OffscreenCanvas，然后通过 VideoEncoder 编码
- 编辑配置（trim、crop、zoom、background）通过消息传递给 Worker
- OPFS 模式支持窗口化渲染，避免内存溢出
- 渲染管线：解码原始帧 → Crop → Zoom → 合成背景 → 编码 → 封装

---

### 3.4 OPFS 流式导出 - 大文件稳定导出

**用户故事**:
> 作为一名**长视频制作者**，我需要导出 1 小时的高清视频（可能超过 5GB）。传统的浏览器导出方案会将整个文件累积在内存中，导致内存不足而崩溃。我希望能够稳定地导出大文件，即使文件体积超过可用内存，并且能够实时看到导出进度。

**解决的问题**:
- ✅ **流式写入**:
  - 导出过程中直接写入 OPFS，不占用内存
  - 使用 Mediabunny 库的 StreamTarget 支持
  - 编码块实时刷新到磁盘
  - 支持导出任意大小的文件，不受内存限制
- ✅ **窗口化渲染**:
  - 分批加载和渲染帧（每批 60 帧）
  - 避免一次性加载全部视频到内存
  - 渲染完成的窗口立即释放，加载下一窗口
- ✅ **内存控制**:
  - 渲染完成的帧立即释放
  - 编码缓冲区定期刷新
  - 保持内存占用稳定（通常 < 500MB）
  - 长时间导出不会内存泄漏
- ✅ **进度追踪**:
  - 实时显示已处理帧数 / 总帧数
  - 进度百分比
  - 预计剩余时间
  - 当前阶段（Preparing/Compositing/Encoding/Muxing/Finalizing）
  - 实时码率和文件大小
- ✅ **导出完成**:
  - 导出完成后从 OPFS 读取并触发下载
  - 自动清理 OPFS 中的临时文件
  - 显示最终文件大小和导出耗时
- ✅ **错误恢复**:
  - 导出失败时保留部分数据
  - 支持重试机制
  - 显示详细错误信息

**技术实现**:
- `Mp4Strategy` / `WebmStrategy` 支持 StreamTarget（OPFS 流式写入）
- Mediabunny 库支持流式封装，边编码边写入
- 导出完成后从 OPFS 读取并使用 `showSaveFilePicker` 触发下载
- 窗口化渲染：每次加载 60 帧，渲染后释放
- 进度通过 Worker 消息实时更新到 UI

---

## 4. 存储与管理场景

### 4.1 Drive 文件管理 - 本地录制库

**用户故事**:
> 作为一名**频繁录制用户**，我积累了多个录制文件，需要一个清晰的界面来管理它们。我希望能够快速查看每个录制的基本信息（时长、大小、创建时间），并能够方便地打开编辑或删除不需要的文件。同时，我需要了解存储空间使用情况，避免超出配额。

**解决的问题**:
- ✅ **录制列表**:
  - 显示所有 OPFS 中的录制会话（`rec_*` 目录）
  - 按创建时间倒序排列（最新的在前）
  - 卡片式布局，清晰展示每个录制
- ✅ **元数据展示**:
  - **创建时间**: 格式化显示（YYYY-MM-DD HH:MM:SS）
  - **时长**: 格式化显示（HH:MM:SS 或 MM:SS）
  - **文件大小**: 自动单位转换（B/KB/MB/GB）
  - **分辨率**: 宽 × 高（如 1920×1080）
  - **编解码器**: 显示视频编码格式（VP9/H.264）
  - **帧率**: 显示录制帧率（如 30fps）
  - **完成状态**: 标识录制是否正常完成（completed: true/false）
- ✅ **快速操作**:
  - **打开 Studio**: 一键跳转到编辑器，自动加载录制
  - **删除录制**: 确认后删除整个录制会话（data.bin + index.jsonl + meta.json）
  - **下载原始文件**: 直接下载 OPFS 中的原始数据（可选）
- ✅ **存储配额管理**:
  - 显示已用空间 / 总配额
  - 进度条可视化存储使用率
  - 配额不足时警告提示
  - 支持请求持久化存储（Persistent Storage）
  - 显示是否已授予持久化权限
- ✅ **错误处理**:
  - 检测损坏的录制文件（meta.json 缺失或格式错误）
  - 显示未完成的录制（崩溃恢复场景）
  - 提供清理孤立文件的选项

**技术实现**:
- `drive/+page.svelte` 遍历 OPFS 根目录下的 `rec_*` 目录
- 读取 `meta.json` 获取录制元数据（width、height、framerate、duration、codec、completed）
- 使用 `navigator.storage.estimate()` 查询存储配额
- 使用 `navigator.storage.persist()` 请求持久化存储
- 删除操作递归删除目录下所有文件

---

### 4.2 崩溃恢复 - 数据安全保障

**用户故事**:
> 作为一名**重要会议记录员**，我在录制 1 小时会议时浏览器意外崩溃或系统断电。我希望重启后能够恢复已录制的内容，而不是从头开始，避免丢失宝贵的会议记录。

**解决的问题**:
- ✅ **数据持久化**:
  - 编码块实时写入 OPFS 的 `data.bin` 文件
  - 使用 SyncAccessHandle 同步写入，确保数据立即落盘
  - 崩溃时已写入的数据完整保留在磁盘上
- ✅ **索引容错**:
  - 索引每 100 个 chunk 批量刷新到 `index.jsonl`
  - 最坏情况：丢失最后 100 帧的索引（约 3 秒 @ 30fps）
  - 索引文件采用行式格式（JSONL），部分损坏不影响已写入行
- ✅ **状态标记**:
  - `meta.json` 的 `completed` 字段标识录制是否正常结束
  - 正常停止：`completed: true`
  - 崩溃中断：`completed: false` 或字段缺失
- ✅ **恢复流程**:
  - 重启后 Drive 页面检测未完成会话（`completed: false`）
  - 显示特殊标识（如"未完成"徽章）
  - 用户可选择：
    - **恢复**: 在 Studio 中打开，可能需要重建部分索引
    - **丢弃**: 删除整个会话释放空间
  - 自动计算实际可用时长（基于索引文件）
- ✅ **数据完整性**:
  - 索引文件记录每个 chunk 的偏移量和大小
  - 即使索引部分丢失，仍可通过扫描 `data.bin` 重建
  - 关键帧标记保留，支持随机访问

**技术实现**:
- `opfs-writer-worker.ts` 使用 SyncAccessHandle 同步写入
- 每 100 个 chunk 批量刷新索引到 `index.jsonl`（`flushIndex` 方法）
- `finalize` 时写入 `completed: true` 到 `meta.json`
- Drive 页面读取 `meta.json` 检测 `completed` 字段
- 未完成会话可在 Studio 中打开，自动处理索引不完整的情况

---

## 5. 技术创新与解决的核心问题

### 5.1 突破浏览器内存限制

**传统方案问题**:
- Blob 数组累积在内存中，1 小时 4K 视频约 4-8GB，超出浏览器单标签页限制（通常 4GB）
- IndexedDB 异步事务在高频写入（60fps）下产生巨大 Promise 调度开销，阻塞 Event Loop

**本项目解决方案**:
- ✅ 使用 OPFS SyncAccessHandle 在 Worker 中同步写入磁盘
- ✅ 零上下文切换，直接调用底层文件系统 API
- ✅ 支持无限时长录制，仅受磁盘空间限制

---

### 5.2 高性能编码与实时性保障

**传统方案问题**:
- MediaRecorder API 编码参数不可控，无法保证文本清晰度
- 编码在主线程执行，影响 UI 响应性

**本项目解决方案**:
- ✅ WebCodecs API 精确控制编码参数（码率、关键帧间隔、contentHint）
- ✅ Worker 架构隔离编码任务，主线程保持流畅
- ✅ 硬件加速编码，CPU 占用低

---

### 5.3 大文件编辑的内存管理

**传统方案问题**:
- 视频编辑器需要加载整个视频到内存，大文件无法处理
- 随机 Seek 需要从最近关键帧开始解码，性能差

**本项目解决方案**:
- ✅ 窗口化加载：仅加载当前播放窗口的帧（60 帧）
- ✅ 关键帧索引：`index.jsonl` 记录每个关键帧位置，快速定位
- ✅ 滑动窗口：自动加载下一窗口，无缝连续播放
- ✅ LRU 缓存：解码帧缓存上限 150 帧，自动释放旧帧

---

### 5.4 非破坏性编辑工作流

**传统方案问题**:
- 编辑操作直接修改原始文件，无法撤销
- 每次调整参数需要重新导出，耗时长

**本项目解决方案**:
- ✅ 所有编辑操作（Trim/Crop/Zoom/Background）仅修改渲染参数
- ✅ 原始 OPFS 数据保持完整，支持随时重置
- ✅ 实时预览：参数调整立即反映在预览中
- ✅ 导出时应用所有效果，一次性渲染

---

### 5.5 跨进程协作架构

**Chrome Extension MV3 限制**:
- Service Worker 无法直接访问 DOM 和媒体 API
- Content Script 无法使用 `desktopCapture` API

**本项目解决方案**:
- ✅ **Background (Service Worker)**: 消息路由、状态管理、权限请求
- ✅ **Offscreen Document**: 媒体流捕获、WebCodecs 编码、OPFS 写入
- ✅ **Content Script**: 元素/区域选择、RestrictionTarget/CropTarget 创建
- ✅ **Workers**: OPFS 读写、视频合成、导出编码
- ✅ 消息总线：`chrome.runtime.sendMessage` 实现跨进程通信

---

## 📊 总结

Screen Recorder Studio 通过创新的技术架构，解决了浏览器端视频录制、编辑、导出的核心难题：

1. **录制**: Tab/Window/Screen 三种核心模式 + 无限时长 + 硬件加速编码
2. **存储**: OPFS 流式写入 + 崩溃恢复 + 索引分离（data.bin + index.jsonl + meta.json）
3. **编辑**: 窗口化加载 + 非破坏性编辑 + 实时预览（Trim/Crop/Zoom/Background）
4. **导出**: 多格式支持（MP4/WebM/GIF）+ 流式导出 + 效果应用

适用场景涵盖：
- 🎓 **在线教育**：教程录制、课程演示
- 💼 **企业培训**：产品演示、操作指南
- 🎮 **游戏直播**：精彩片段剪辑
- 📱 **社交媒体**：短视频制作、内容创作
- 🔧 **技术支持**：问题复现、Bug 报告
- 📊 **会议记录**：远程会议、在线研讨会

---

## 🔄 版本说明

**当前版本特性**:
- ✅ 核心录制模式：Tab、Window、Screen（简化用户选择，聚焦主流场景）
- ✅ WebCodecs 硬件加速编码 + OPFS 无限时长存储
- ✅ Studio 非破坏性编辑（Trim、Crop、Zoom、Background）
- ✅ 多格式导出（MP4、WebM、GIF）

**代码保留但 UI 隐藏的功能**:
- 🔒 Element 录制（DOM 元素捕获，基于 RestrictionTarget API）
- 🔒 Area 录制（自定义区域选择，基于 CropTarget API）
- 🔒 Camera 录制（摄像头捕获）

> 这些高级功能的底层实现已完成（见 `src/extensions/content.ts`），但为了降低用户学习成本和提升产品稳定性，当前版本 UI 层面暂时隐藏。未来可根据用户反馈选择性开放。

---

## 📚 项目信息

- **许可证**: MIT
- **最低 Chrome 版本**: 116
- **技术栈**: Svelte 5 + WebCodecs API + OPFS + Chrome Extension MV3
- **开发语言**: TypeScript + Svelte
- **构建工具**: Vite + SvelteKit

## 🚀 快速开始

```bash
# 安装依赖
pnpm install

# 开发模式（站点预览）
pnpm dev

# 构建扩展
pnpm build:extension

# 打包扩展（生成 zip）
pnpm package:extension
```

## 📖 相关文档

- `README.md` / `README.ZH.md` - 项目总览与架构说明
- `docs/OPFS-RECORDING-EVALUATION.md` - OPFS 录制系统评估
- `blog/03-storage-opfs-database.md` - OPFS 存储架构详解
- `.userstories/` - 用户故事与场景分析

---

**文档生成时间**: 2026-01-08
**文档版本**: v1.0


