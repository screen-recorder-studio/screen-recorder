/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/mediabunny@1.12.1/dist/modules/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
function e(e){if(!e)throw new Error("Assertion failed.")}const t=e=>{const t=(e%360+360)%360;if(0===t||90===t||180===t||270===t)return t;throw new Error(`Invalid rotation ${e}.`)},r=e=>e&&e[e.length-1],i=e=>e>=0&&e<2**32;class s{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),t=this.bytes[e]??0,r=7-(7&this.pos),i=(t&1<<r)>>r;return this.pos++,i}readBits(e){if(1===e)return this.readBit();let t=0;for(let r=0;r<e;r++)t<<=1,t|=this.readBit();return t}writeBits(e,t){const r=this.pos+e;for(let e=this.pos;e<r;e++){const i=Math.floor(e/8);let s=this.bytes[i];const a=7-(7&e);s&=~(1<<a),s|=(t&1<<r-e-1)>>r-e-1<<a,this.bytes[i]=s}this.pos=r}readAlignedByte(){if(this.pos%8!=0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,t=this.bytes[e]??0;return this.pos+=8,t}skipBits(e){this.pos+=e}getBitsLeft(){return 8*this.bytes.length-this.pos}clone(){const e=new s(this.bytes);return e.pos=this.pos,e}}const a=e=>{let t=0;for(;0===e.readBits(1)&&t<32;)t++;if(t>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<t)-1+e.readBits(t)},n=e=>{const t=a(e);return 1&t?t+1>>1:-(t>>1)},o=e=>e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength),c=e=>e instanceof DataView?e:e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength),u=new TextDecoder,d=new TextEncoder,l=e=>Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e]))),h={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},m=l(h),f={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pg:16,hlg:18},p=l(f),g={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},w=l(g),k=e=>!!(e&&e.primaries&&e.transfer&&e.matrix&&void 0!==e.fullRange),b=e=>e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer||ArrayBuffer.isView(e);class y{constructor(){this.currentPromise=Promise.resolve()}async acquire(){let e;const t=new Promise((t=>{e=t})),r=this.currentPromise;return this.currentPromise=t,await r,e}}const T=e=>[...e].map((e=>e.toString(16).padStart(2,"0"))).join(""),S=e=>(e=(e=(e=(e=(e=e>>1&1431655765|(1431655765&e)<<1)>>2&858993459|(858993459&e)<<2)>>4&252645135|(252645135&e)<<4)>>8&16711935|(16711935&e)<<8)>>16&65535|(65535&e)<<16)>>>0,v=(e,t,r)=>{let i=0,s=e.length-1,a=-1;for(;i<=s;){const n=i+s>>1,o=r(e[n]);o===t?(a=n,s=n-1):o<t?i=n+1:s=n-1}return a},C=(e,t,r)=>{let i=0,s=e.length-1,a=-1;for(;i<=s;){const n=i+(s-i+1)/2|0;r(e[n])<=t?(a=n,i=n+1):s=n-1}return a},x=(e,t,r)=>{const i=C(e,r(t),r);e.splice(i+1,0,t)},P=()=>{let e,t;return{promise:new Promise(((r,i)=>{e=r,t=i})),resolve:e,reject:t}},_=(e,t)=>{for(let r=e.length-1;r>=0;r--)if(t(e[r]))return e[r]},E=(e,t)=>{for(let r=e.length-1;r>=0;r--)if(t(e[r]))return r;return-1},I=e=>{throw new Error(`Unexpected value: ${e}`)},B=(e,t,r)=>{const i=e.getUint8(t),s=e.getUint8(t+1),a=e.getUint8(t+2);return r?i|s<<8|a<<16:i<<16|s<<8|a},M=(e,t,r,i)=>{r>>>=0,r&=16777215,i?(e.setUint8(t,255&r),e.setUint8(t+1,r>>>8&255),e.setUint8(t+2,r>>>16&255)):(e.setUint8(t,r>>>16&255),e.setUint8(t+1,r>>>8&255),e.setUint8(t+2,255&r))},z=(e,t)=>({async next(){const r=await e.next();return r.done?{value:void 0,done:!0}:{value:t(r.value),done:!1}},return:()=>e.return(),throw:t=>e.throw(t),[Symbol.asyncIterator](){return this}}),F=(e,t,r)=>Math.max(t,Math.min(r,e)),A="und",D=(e,t)=>{const r=10**t;return Math.round(e*r)/r},R=(e,t)=>Math.round(e/t)*t,O=/^[a-z]{3}$/,W=e=>O.test(e),V=1e6*(1+Number.EPSILON),U=(e,t)=>{const r={...e};for(const i in t)"object"==typeof e[i]&&null!==e[i]&&"object"==typeof t[i]&&null!==t[i]?r[i]=U(e[i],t[i]):r[i]=t[i];return r},L=async(e,t,r)=>{let i=0;for(;;)try{return await fetch(e,t)}catch(e){i++;const t=r(i);if(null===t)throw e;if(console.error("Retrying failed fetch. Error:",e),!Number.isFinite(t)||t<0)throw new TypeError("Retry delay must be a non-negative finite number.");t>0&&await new Promise((e=>setTimeout(e,1e3*t)))}};class N{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}let H=null;const q=()=>{if(null!==H)return H;const e=!("undefined"==typeof navigator||!navigator.vendor?.match(/apple/i)||navigator.userAgent?.match(/crios/i)||navigator.userAgent?.match(/fxios/i)||navigator.userAgent?.match(/Opera|OPT\//));return H=e,e},$=(e,t,r,i)=>e<=i&&r<=t,j=["avc","hevc","vp9","av1","vp8"],K=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],Q=["aac","opus","mp3","vorbis","flac"],Y=[...Q,...K],G=["webvtt"],X=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],J=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Z=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],ee=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],te=".01.01.01.01.00",re=".0.110.01.01.01.0",ie=(e,t,i,s)=>{if("avc"===e){const e=100,a=Math.ceil(t/16)*Math.ceil(i/16),n=X.find((e=>a<=e.maxMacroblocks&&s<=e.maxBitrate))??r(X),o=n?n.level:0;return`avc1.${e.toString(16).padStart(2,"0")}${"00"}${o.toString(16).padStart(2,"0")}`}if("hevc"===e){const e="",a=1,n="6",o=t*i,c=J.find((e=>o<=e.maxPictureSize&&s<=e.maxBitrate))??r(J),u="B0";return`hev1.${e}${a}.${n}.${c.tier}${c.level}.${u}`}if("vp8"===e)return"vp8";if("vp9"===e){const e=t*i,a="08";return`vp09.${"00"}.${(Z.find((t=>e<=t.maxPictureSize&&s<=t.maxBitrate))??r(Z)).level.toString().padStart(2,"0")}.${a}`}if("av1"===e){const e=0,a=t*i,n=ee.find((e=>a<=e.maxPictureSize&&s<=e.maxBitrate))??r(ee),o="08";return`av01.${e}.${n.level.toString().padStart(2,"0")}${n.tier}.${o}`}throw new TypeError(`Unhandled codec '${e}'.`)},se=e=>{const t=e.split(".");return[1,1,Number(t[1]),2,1,Number(t[2]),3,1,Number(t[3]),4,1,t[4]?Number(t[4]):1]},ae=e=>{const t=e.split("."),r=Number(t[1]),i=t[2];return[129,(r<<5)+Number(i.slice(0,-1)),(("H"===i.slice(-1)?1:0)<<7)+((8===Number(t[3])?0:1)<<6)+0+((t[4]?Number(t[4]):0)<<4)+((t[5]?Number(t[5][0]):1)<<3)+((t[5]?Number(t[5][1]):1)<<2)+(t[5]?Number(t[5][2]):0),0]},ne=e=>{const{codec:t,codecDescription:i,colorSpace:s,avcCodecInfo:a,hevcCodecInfo:n,vp9CodecInfo:o,av1CodecInfo:u}=e;if("avc"===t){if(a){const e=new Uint8Array([a.avcProfileIndication,a.profileCompatibility,a.avcLevelIndication]);return`avc1.${T(e)}`}if(!i||i.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc1.${T(i.subarray(1,4))}`}if("hevc"===t){let e,t,r,s,a,o;if(n)e=n.generalProfileSpace,t=n.generalProfileIdc,r=S(n.generalProfileCompatibilityFlags),s=n.generalTierFlag,a=n.generalLevelIdc,o=[...n.generalConstraintIndicatorFlags];else{if(!i||i.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const n=c(i),u=n.getUint8(1);e=u>>6&3,t=31&u,r=S(n.getUint32(2)),s=u>>5&1,a=n.getUint8(12),o=[];for(let e=0;e<6;e++)o.push(n.getUint8(6+e))}let u="hev1.";for(u+=["","A","B","C"][e]+t,u+=".",u+=r.toString(16).toUpperCase(),u+=".",u+=0===s?"L":"H",u+=a;o.length>0&&0===o[o.length-1];)o.pop();return o.length>0&&(u+=".",u+=o.map((e=>e.toString(16).toUpperCase())).join(".")),u}if("vp8"===t)return"vp8";if("vp9"===t){if(!o){const t=e.width*e.height;let i=r(Z).level;for(const e of Z)if(t<=e.maxPictureSize){i=e.level;break}return`vp09.00.${i.toString().padStart(2,"0")}.08`}let t=`vp09.${o.profile.toString().padStart(2,"0")}.${o.level.toString().padStart(2,"0")}.${o.bitDepth.toString().padStart(2,"0")}.${o.chromaSubsampling.toString().padStart(2,"0")}`;return t+=`.${o.colourPrimaries.toString().padStart(2,"0")}.${o.transferCharacteristics.toString().padStart(2,"0")}.${o.matrixCoefficients.toString().padStart(2,"0")}.${o.videoFullRangeFlag.toString().padStart(2,"0")}`,t.endsWith(te)&&(t=t.slice(0,-15)),t}if("av1"===t){if(!u){const t=e.width*e.height;let i=r(Z).level;for(const e of Z)if(t<=e.maxPictureSize){i=e.level;break}return`av01.0.${i.toString().padStart(2,"0")}M.08`}const t=u.profile,i=u.level.toString().padStart(2,"0"),a=u.tier?"H":"M",n=u.bitDepth.toString().padStart(2,"0"),o=u.monochrome?"1":"0",c=100*u.chromaSubsamplingX+10*u.chromaSubsamplingY+1*(u.chromaSubsamplingX&&u.chromaSubsamplingY?u.chromaSamplePosition:0),d=s?.primaries?h[s.primaries]:1,l=s?.transfer?f[s.transfer]:1,m=s?.matrix?g[s.matrix]:1,p=s?.fullRange?1:0;let w=`av01.${t}.${i}${a}.${n}`;return w+=`.${o}.${c.toString().padStart(3,"0")}`,w+=`.${d.toString().padStart(2,"0")}`,w+=`.${l.toString().padStart(2,"0")}`,w+=`.${m.toString().padStart(2,"0")}`,w+=`.${p}`,w.endsWith(re)&&(w=w.slice(0,-17)),w}throw new TypeError(`Unhandled codec '${t}'.`)},oe=(e,t,r)=>{if("aac"===e)return t>=2&&r<=24e3?"mp4a.40.29":r<=24e3?"mp4a.40.5":"mp4a.40.2";if("mp3"===e)return"mp3";if("opus"===e)return"opus";if("vorbis"===e)return"vorbis";if("flac"===e)return"flac";if(K.includes(e))return e;throw new TypeError(`Unhandled codec '${e}'.`)},ce=e=>{const{codec:t,codecDescription:r,aacCodecInfo:i}=e;if("aac"===t){if(!i)throw new TypeError("AAC codec info must be provided.");if(i.isMpeg2)return"mp4a.67";return`mp4a.40.${le(r).objectType}`}if("mp3"===t)return"mp3";if("opus"===t)return"opus";if("vorbis"===t)return"vorbis";if("flac"===t)return"flac";if(t&&K.includes(t))return t;throw new TypeError(`Unhandled codec '${t}'.`)},ue=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],de=[-1,1,2,3,4,5,6,8],le=e=>{if(!e||e.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const t=new s(e);let r=t.readBits(5);31===r&&(r=32+t.readBits(6));const i=t.readBits(4);let a=null;15===i?a=t.readBits(24):i<ue.length&&(a=ue[i]);const n=t.readBits(4);let o=null;return n>=1&&n<=7&&(o=de[n]),{objectType:r,frequencyIndex:i,sampleRate:a,channelConfiguration:n,numberOfChannels:o}},he=48e3,me=/^pcm-([usf])(\d+)+(be)?$/,fe=t=>{if(e(K.includes(t)),"ulaw"===t)return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if("alaw"===t)return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const r=me.exec(t);let i;e(r),i="u"===r[1]?"unsigned":"s"===r[1]?"signed":"float";return{dataType:i,sampleSize:Number(r[2])/8,littleEndian:"be"!==r[3],silentValue:"pcm-u8"===t?128:0}},pe=e=>e.startsWith("avc1")||e.startsWith("avc3")?"avc":e.startsWith("hev1")||e.startsWith("hvc1")?"hevc":"vp8"===e?"vp8":e.startsWith("vp09")?"vp9":e.startsWith("av01")?"av1":e.startsWith("mp4a.40")||"mp4a.67"===e?"aac":"mp3"===e||"mp4a.69"===e||"mp4a.6B"===e||"mp4a.6b"===e?"mp3":"opus"===e?"opus":"vorbis"===e?"vorbis":"flac"===e?"flac":"ulaw"===e?"ulaw":"alaw"===e?"alaw":me.test(e)?e:"webvtt"===e?"webvtt":null;class ge{constructor(e){this._factor=e}_toVideoBitrate(e,t,r){const i=t*r,s=3e6*Math.pow(i/2073600,.95)*{avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2}[e]*this._factor;return 1e3*Math.ceil(s/1e3)}_toAudioBitrate(e){if(K.includes(e)||"flac"===e)return;const t={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!t)throw new Error(`Unhandled codec: ${e}`);let r=t*this._factor;if("aac"===e){r=[96e3,128e3,16e4,192e3].reduce(((e,t)=>Math.abs(t-r)<Math.abs(e-r)?t:e))}else if("opus"===e||"vorbis"===e)r=Math.max(6e3,r);else if("mp3"===e){r=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce(((e,t)=>Math.abs(t-r)<Math.abs(e-r)?t:e))}return 1e3*Math.round(r/1e3)}}const we=new ge(.3),ke=new ge(.6),be=new ge(1),ye=new ge(2),Te=new ge(4),Se=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],ve=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,Ce=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,xe=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,Pe=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,_e=e=>{if(!e)throw new TypeError("Video chunk metadata must be provided.");if("object"!=typeof e)throw new TypeError("Video chunk metadata must be an object.");if(!e.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if("object"!=typeof e.decoderConfig)throw new TypeError("Video chunk metadata decoder configuration must be an object.");if("string"!=typeof e.decoderConfig.codec)throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!Se.some((t=>e.decoderConfig.codec.startsWith(t))))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(e.decoderConfig.codedWidth)||e.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(e.decoderConfig.codedHeight)||e.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(void 0!==e.decoderConfig.description&&!b(e.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(void 0!==e.decoderConfig.colorSpace){const{colorSpace:t}=e.decoderConfig;if("object"!=typeof t)throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const r=Object.keys(h);if(null!=t.primaries&&!r.includes(t.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${r.join(", ")}.`);const i=Object.keys(f);if(null!=t.transfer&&!i.includes(t.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${i.join(", ")}.`);const s=Object.keys(g);if(null!=t.matrix&&!s.includes(t.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${s.join(", ")}.`);if(null!=t.fullRange&&"boolean"!=typeof t.fullRange)throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(e.decoderConfig.codec.startsWith("avc1")||e.decoderConfig.codec.startsWith("avc3")){if(!ve.test(e.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(e.decoderConfig.codec.startsWith("hev1")||e.decoderConfig.codec.startsWith("hvc1")){if(!Ce.test(e.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(e.decoderConfig.codec.startsWith("vp8")){if("vp8"!==e.decoderConfig.codec)throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(e.decoderConfig.codec.startsWith("vp09")){if(!xe.test(e.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(e.decoderConfig.codec.startsWith("av01")&&!Pe.test(e.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Ee=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],Ie=e=>{if(!e)throw new TypeError("Audio chunk metadata must be provided.");if("object"!=typeof e)throw new TypeError("Audio chunk metadata must be an object.");if(!e.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if("object"!=typeof e.decoderConfig)throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if("string"!=typeof e.decoderConfig.codec)throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Ee.some((t=>e.decoderConfig.codec.startsWith(t))))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(e.decoderConfig.sampleRate)||e.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(e.decoderConfig.numberOfChannels)||e.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(void 0!==e.decoderConfig.description&&!b(e.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(e.decoderConfig.codec.startsWith("mp4a")&&"mp4a.69"!==e.decoderConfig.codec&&"mp4a.6B"!==e.decoderConfig.codec&&"mp4a.6b"!==e.decoderConfig.codec){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(e.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!e.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(e.decoderConfig.codec.startsWith("mp3")||e.decoderConfig.codec.startsWith("mp4a")){if("mp3"!==e.decoderConfig.codec&&"mp4a.69"!==e.decoderConfig.codec&&"mp4a.6B"!==e.decoderConfig.codec&&"mp4a.6b"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(e.decoderConfig.codec.startsWith("opus")){if("opus"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(e.decoderConfig.description&&e.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(e.decoderConfig.codec.startsWith("vorbis")){if("vorbis"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!e.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(e.decoderConfig.codec.startsWith("flac")){if("flac"!==e.decoderConfig.codec)throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');const t=42;if(!e.decoderConfig.description||e.decoderConfig.description.byteLength<t)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((e.decoderConfig.codec.startsWith("pcm")||e.decoderConfig.codec.startsWith("ulaw")||e.decoderConfig.codec.startsWith("alaw"))&&!K.includes(e.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${K.join(", ")}).`)},Be=e=>{if(!e)throw new TypeError("Subtitle metadata must be provided.");if("object"!=typeof e)throw new TypeError("Subtitle metadata must be an object.");if(!e.config)throw new TypeError("Subtitle metadata must include a config object.");if("object"!=typeof e.config)throw new TypeError("Subtitle metadata config must be an object.");if("string"!=typeof e.config.description)throw new TypeError("Subtitle metadata config description must be a string.")};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class Me{constructor(e){this.mutex=new y,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,t,r){t+=e.source._timestampOffset;let i=this.trackTimestampInfo.get(e);if(!i){if(!r)throw new Error("First frame must be a key frame.");i={maxTimestamp:t,maxTimestampBeforeLastKeyFrame:t},this.trackTimestampInfo.set(e,i)}if(t<0)throw new Error(`Timestamps must be non-negative (got ${t}s).`);if(r&&(i.maxTimestampBeforeLastKeyFrame=i.maxTimestamp),t<i.maxTimestampBeforeLastKeyFrame)throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous run (a run begins with a key frame and ends right before the next key frame). Got ${t}s, but highest timestamp is ${i.maxTimestampBeforeLastKeyFrame}s.`);return i.maxTimestamp=Math.max(i.maxTimestamp,t),t}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ze extends Me{constructor(e,t){super(e),this.header=new Uint8Array(7),this.headerBitstream=new s(this.header),this.audioSpecificConfig=null,this.format=t,this.writer=e._writer}async start(){}async getMimeType(){return"audio/aac"}async addEncodedVideoPacket(){throw new Error("ADTS does not support video.")}async addEncodedAudioPacket(t,r,i){const s=await this.mutex.acquire();try{if(this.validateAndNormalizeTimestamp(t,r.timestamp,"key"===r.type),!this.audioSpecificConfig){Ie(i);const t=i?.decoderConfig?.description;e(t),this.audioSpecificConfig=le(o(t));const{objectType:r,frequencyIndex:s,channelConfiguration:a}=this.audioSpecificConfig,n=r-1;this.headerBitstream.writeBits(12,4095),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(2,0),this.headerBitstream.writeBits(1,1),this.headerBitstream.writeBits(2,n),this.headerBitstream.writeBits(4,s),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(3,a),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(1,0),this.headerBitstream.skipBits(13),this.headerBitstream.writeBits(11,2047),this.headerBitstream.writeBits(2,0)}const s=r.data.byteLength+this.header.byteLength;this.headerBitstream.pos=30,this.headerBitstream.writeBits(13,s);const a=this.writer.getPos();if(this.writer.write(this.header),this.writer.write(r.data),this.format._options.onFrame){const e=new Uint8Array(s);e.set(this.header,0),e.set(r.data,this.header.byteLength),this.format._options.onFrame(e,a)}await this.writer.flush()}finally{s()}}async addSubtitleCue(){throw new Error("ADTS does not support subtitles.")}async finalize(){}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Fe=/(?:(.+?)\n)?((?:\d{2}:)?\d{2}:\d{2}.\d{3})\s+-->\s+((?:\d{2}:)?\d{2}:\d{2}.\d{3})/g,Ae=/^WEBVTT(.|\n)*?\n{2}/,De=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g;class Re{constructor(e){this.preambleText=null,this.preambleEmitted=!1,this.options=e}parse(e){let t;if(e=e.replaceAll("\r\n","\n").replaceAll("\r","\n"),Fe.lastIndex=0,!this.preambleText){if(!Ae.test(e))throw new Error("WebVTT preamble incorrect.");t=Fe.exec(e);const r=e.slice(0,t?.index??e.length).trimEnd();if(!r)throw new Error("No WebVTT preamble provided.");this.preambleText=r,t&&(e=e.slice(t.index),Fe.lastIndex=0)}for(;t=Fe.exec(e);){const r=e.slice(0,t.index),i=t[1],s=t.index+t[0].length,a=e.indexOf("\n",s)+1,n=e.slice(s,a).trim();let o=e.indexOf("\n\n",s);-1===o&&(o=e.length);const c=We(t[2]),u=We(t[3])-c,d=e.slice(a,o).trim();e=e.slice(o).trimStart(),Fe.lastIndex=0;const l={timestamp:c/1e3,duration:u/1e3,text:d,identifier:i,settings:n,notes:r},h={};this.preambleEmitted||(h.config={description:this.preambleText},this.preambleEmitted=!0),this.options.output(l,h)}}}const Oe=/(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})/,We=e=>{const t=Oe.exec(e);if(!t)throw new Error("Expected match.");return 36e5*Number(t[1]||"0")+6e4*Number(t[2])+1e3*Number(t[3])+Number(t[4])},Ve=e=>{const t=Math.floor(e/36e5),r=Math.floor(e%36e5/6e4),i=Math.floor(e%6e4/1e3),s=e%1e3;return t.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+":"+i.toString().padStart(2,"0")+"."+s.toString().padStart(3,"0")},Ue=e=>{const t=[];let r=0;for(;r<e.length;){let i=-1,s=0;for(let t=r;t<e.length-3;t++){if(0===e[t]&&0===e[t+1]&&1===e[t+2]){i=t,s=3;break}if(t<e.length-4&&0===e[t]&&0===e[t+1]&&0===e[t+2]&&1===e[t+3]){i=t,s=4;break}}if(-1===i)break;if(r>0&&i>r){const s=e.subarray(r,i);s.length>0&&t.push(s)}r=i+s}if(r<e.length){const i=e.subarray(r);i.length>0&&t.push(i)}return t},Le=(t,r)=>{const i=[];let s=0;const a=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;s+r<=t.length;){let n;1===r?n=a.getUint8(s):2===r?n=a.getUint16(s,!1):3===r?n=(a.getUint16(s,!1)<<8)+a.getUint8(s+2):4===r?n=a.getUint32(s,!1):(I(r),e(!1)),s+=r;const o=t.subarray(s,s+n);i.push(o),s+=n}return i},Ne=e=>{const t=[],r=e.length;for(let i=0;i<r;i++)i+2<r&&0===e[i]&&0===e[i+1]&&3===e[i+2]?(t.push(0,0),i+=2):t.push(e[i]);return new Uint8Array(t)},He=e=>31&e[0],qe=e=>{try{const t=Ue(e),r=t.filter((e=>7===He(e))),i=t.filter((e=>8===He(e))),n=t.filter((e=>13===He(e)));if(0===r.length)return null;if(0===i.length)return null;const o=r[0],c=new s(Ne(o));c.skipBits(1),c.skipBits(2);if(7!==c.readBits(5))return console.error("Invalid SPS NAL unit type"),null;const u=c.readAlignedByte(),d=c.readAlignedByte(),l={configurationVersion:1,avcProfileIndication:u,profileCompatibility:d,avcLevelIndication:c.readAlignedByte(),lengthSizeMinusOne:3,sequenceParameterSets:r,pictureParameterSets:i,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if(100===u||110===u||122===u||144===u){a(c);const e=a(c);3===e&&c.skipBits(1);const t=a(c),r=a(c);l.chromaFormat=e,l.bitDepthLumaMinus8=t,l.bitDepthChromaMinus8=r,l.sequenceParameterSetExt=n}return l}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},$e=e=>e[0]>>1&63,je=e=>{try{const t=Ue(e),r=t.filter((e=>32===$e(e))),i=t.filter((e=>33===$e(e))),o=t.filter((e=>34===$e(e))),c=t.filter((e=>39===$e(e)||40===$e(e)));if(0===i.length||0===o.length)return null;const u=i[0],d=new s(Ne(u));d.skipBits(16),d.readBits(4);const l=d.readBits(3),h=d.readBits(1),{general_profile_space:m,general_tier_flag:f,general_profile_idc:p,general_profile_compatibility_flags:g,general_constraint_indicator_flags:w,general_level_idc:k}=Ke(d,l);a(d);const b=a(d);3===b&&d.skipBits(1),a(d),a(d),d.readBits(1)&&(a(d),a(d),a(d),a(d));const y=a(d),T=a(d);a(d);const S=d.readBits(1);for(let e=S?0:l;e<=l;e++)a(d),a(d),a(d);a(d),a(d),a(d),a(d),a(d),a(d),d.readBits(1)&&d.readBits(1)&&Qe(d),d.skipBits(1),d.skipBits(1),d.readBits(1)&&(d.skipBits(4),d.skipBits(4),a(d),a(d),d.skipBits(1));const v=a(d);if(Ye(d,v),d.readBits(1)){const e=a(d);for(let t=0;t<e;t++)a(d),d.skipBits(1)}d.skipBits(1),d.skipBits(1);let C=0;d.readBits(1)&&(C=Xe(d,l));let x=0;if(o.length>0){const e=o[0],t=new s(Ne(e));t.skipBits(16),a(t),a(t),t.skipBits(1),t.skipBits(1),t.skipBits(3),t.skipBits(1),t.skipBits(1),a(t),a(t),n(t),t.skipBits(1),t.skipBits(1),t.readBits(1)&&a(t),n(t),n(t),t.skipBits(1),t.skipBits(1),t.skipBits(1),t.skipBits(1);const r=t.readBits(1),i=t.readBits(1);x=r||i?r&&!i?2:!r&&i?3:0:0}const P=[...r.length?[{arrayCompleteness:1,nalUnitType:32,nalUnits:r}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:33,nalUnits:i}]:[],...o.length?[{arrayCompleteness:1,nalUnitType:34,nalUnits:o}]:[],...c.length?[{arrayCompleteness:1,nalUnitType:$e(c[0]),nalUnits:c}]:[]];return{configurationVersion:1,generalProfileSpace:m,generalTierFlag:f,generalProfileIdc:p,generalProfileCompatibilityFlags:g,generalConstraintIndicatorFlags:w,generalLevelIdc:k,minSpatialSegmentationIdc:C,parallelismType:x,chromaFormatIdc:b,bitDepthLumaMinus8:y,bitDepthChromaMinus8:T,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:l+1,temporalIdNested:h,lengthSizeMinusOne:3,arrays:P}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Ke=(e,t)=>{const r=e.readBits(2),i=e.readBits(1),s=e.readBits(5);let a=0;for(let t=0;t<32;t++)a=a<<1|e.readBits(1);const n=new Uint8Array(6);for(let t=0;t<6;t++)n[t]=e.readBits(8);const o=e.readBits(8),c=[],u=[];for(let r=0;r<t;r++)c.push(e.readBits(1)),u.push(e.readBits(1));if(t>0)for(let r=t;r<8;r++)e.skipBits(2);for(let r=0;r<t;r++)c[r]&&e.skipBits(88),u[r]&&e.skipBits(8);return{general_profile_space:r,general_tier_flag:i,general_profile_idc:s,general_profile_compatibility_flags:a,general_constraint_indicator_flags:n,general_level_idc:o}},Qe=e=>{for(let t=0;t<4;t++)for(let r=0;r<(3===t?2:6);r++){if(e.readBits(1)){const r=Math.min(64,1<<4+(t<<1));t>1&&n(e);for(let t=0;t<r;t++)n(e)}else a(e)}},Ye=(e,t)=>{const r=[];for(let i=0;i<t;i++)r[i]=Ge(e,i,t,r)},Ge=(e,t,r,i)=>{let s=0,n=0,o=0;if(0!==t&&(n=e.readBits(1)),n){if(t===r){o=t-(a(e)+1)}else o=t-1;e.readBits(1),a(e);const n=i[o]??0;for(let t=0;t<=n;t++){e.readBits(1)||e.readBits(1)}s=i[o]}else{const t=a(e),r=a(e);for(let r=0;r<t;r++)a(e),e.readBits(1);for(let t=0;t<r;t++)a(e),e.readBits(1);s=t+r}return s},Xe=(e,t)=>{if(e.readBits(1)){255===e.readBits(8)&&(e.readBits(16),e.readBits(16))}if(e.readBits(1)&&e.readBits(1),e.readBits(1)&&(e.readBits(3),e.readBits(1),e.readBits(1)&&(e.readBits(8),e.readBits(8),e.readBits(8))),e.readBits(1)&&(a(e),a(e)),e.readBits(1),e.readBits(1),e.readBits(1),e.readBits(1)&&(a(e),a(e),a(e),a(e)),e.readBits(1)&&(e.readBits(32),e.readBits(32),e.readBits(1)&&a(e),e.readBits(1)&&Je(e,!0,t)),e.readBits(1)){e.readBits(1),e.readBits(1),e.readBits(1);const t=a(e);return a(e),a(e),a(e),a(e),t}return 0},Je=(e,t,r)=>{let i=!1,s=!1,n=!1;t&&(i=1===e.readBits(1),s=1===e.readBits(1),(i||s)&&(n=1===e.readBits(1),n&&(e.readBits(8),e.readBits(5),e.readBits(1),e.readBits(5)),e.readBits(4),e.readBits(4),n&&e.readBits(4),e.readBits(5),e.readBits(5),e.readBits(5)));for(let t=0;t<=r;t++){let t=!0;1===e.readBits(1)||(t=1===e.readBits(1));let r=!1;t?a(e):r=1===e.readBits(1);let o=1;if(!r){o=a(e)+1}i&&Ze(e,o,n),s&&Ze(e,o,n)}},Ze=(e,t,r)=>{for(let i=0;i<t;i++)a(e),a(e),r&&(a(e),a(e)),e.readBits(1)},et=e=>{const t=new s(e);if(2!==t.readBits(2))return null;const i=t.readBits(1),a=(t.readBits(1)<<1)+i;3===a&&t.skipBits(1);if(1===t.readBits(1))return null;if(0!==t.readBits(1))return null;t.skipBits(2);if(4817730!==t.readBits(24))return null;let n=8;if(a>=2){n=t.readBits(1)?12:10}const o=t.readBits(3);let c=0,u=0;if(7!==o){if(u=t.readBits(1),1===a||3===a){const e=t.readBits(1),r=t.readBits(1);c=e||r?e&&!r?2:1:3,t.skipBits(1)}else c=1}else c=3,u=1;const d=(t.readBits(16)+1)*(t.readBits(16)+1);let l=r(Z).level;for(const e of Z)if(d<=e.maxPictureSize){l=e.level;break}return{profile:a,level:l,bitDepth:n,chromaSubsampling:c,videoFullRangeFlag:u,colourPrimaries:2===o?1:1===o?6:2,transferCharacteristics:2===o?1:1===o?6:2,matrixCoefficients:7===o?0:2===o?1:1===o?6:2}},tt=function*(t){const r=new s(t),i=()=>{let e=0;for(let t=0;t<8;t++){const i=r.readAlignedByte();if(e|=(127&i)<<7*t,!(128&i))break;if(7===t&&128&i)return null}return e>=2**32-1?null:e};for(;r.getBitsLeft()>=8;){r.skipBits(1);const s=r.readBits(4),a=r.readBits(1),n=r.readBits(1);let o;if(r.skipBits(1),a&&r.skipBits(8),n){const e=i();if(null===e)return;o=e}else o=Math.floor(r.getBitsLeft()/8);e(r.pos%8==0),yield{type:s,data:t.subarray(r.pos/8,r.pos/8+o)},r.skipBits(8*o)}},rt=e=>{for(const{type:t,data:r}of tt(e)){if(1!==t)continue;const e=new s(r),i=e.readBits(3);e.readBits(1);let a=0,n=0,o=0;if(e.readBits(1))a=e.readBits(5);else{if(e.readBits(1)){e.skipBits(32),e.skipBits(32);if(e.readBits(1))return null}const t=e.readBits(1);t&&(o=e.readBits(5),e.skipBits(32),e.skipBits(5),e.skipBits(5));const r=e.readBits(5);for(let i=0;i<=r;i++){e.skipBits(12);const r=e.readBits(5);if(0===i&&(a=r),r>7){const t=e.readBits(1);0===i&&(n=t)}if(t){if(e.readBits(1)){const t=o+1;e.skipBits(t),e.skipBits(t),e.skipBits(1)}}e.readBits(1)&&e.skipBits(4)}}const c=e.readBits(1);let u=8;if(2===i&&c){u=e.readBits(1)?12:10}else i<=2&&(u=c?10:8);let d=0;1!==i&&(d=e.readBits(1));let l=1,h=1,m=0;return d||(0===i?(l=1,h=1):1===i?(l=0,h=0):12===u&&(l=e.readBits(1),l&&(h=e.readBits(1))),l&&h&&(m=e.readBits(2))),{profile:i,level:a,tier:n,bitDepth:u,monochrome:d,chromaSubsamplingX:l,chromaSubsamplingY:h,chromaSamplePosition:m}}return null},it=e=>{const t=c(e),r=t.getUint8(9),i=t.getUint16(10,!0),s=t.getUint32(12,!0),a=t.getInt16(16,!0),n=t.getUint8(18);let o=null;return n&&(o=e.subarray(19,21+r)),{outputChannelCount:r,preSkip:i,inputSampleRate:s,outputGain:a,channelMappingFamily:n,channelMappingTable:o}},st=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],at=e=>{if(e.length<7)throw new Error("Setup header is too short.");if(5!==e[0])throw new Error("Wrong packet type in Setup header.");if("vorbis"!==String.fromCharCode(...e.slice(1,7)))throw new Error("Invalid packet signature in Setup header.");const t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e[t-1-i];const i=new s(r);let a=0;for(;i.getBitsLeft()>97;)if(1===i.readBits(1)){a=i.pos;break}if(0===a)throw new Error("Invalid Setup header: framing bit not found.");let n=0,o=!1,c=0;for(;i.getBitsLeft()>=97;){const e=i.pos,t=i.readBits(8),r=i.readBits(16),s=i.readBits(16);if(t>63||0!==r||0!==s){i.pos=e;break}if(i.skipBits(1),n++,n>64)break;i.clone().readBits(6)+1===n&&(o=!0,c=n)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(c>63)throw new Error(`Unsupported mode count: ${c}.`);const u=c;i.pos=0,i.skipBits(a);const d=Array(u).fill(0);for(let e=u-1;e>=0;e--)i.skipBits(40),d[e]=i.readBits(1);return{modeBlockflags:d}};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class nt{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let t=0;t<e.length;t++)this.helperView.setUint8(t%8,e.charCodeAt(t)),t%8==7&&this.writer.write(this.helper);e.length%8!=0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const t=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const t of e.children)t&&this.writeBox(t);const r=this.writer.getPos(),i=e.size??r-t;this.writer.seek(t),this.writeBoxHeader(e,i),this.writer.seek(r)}}writeBoxHeader(e,t){this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(t){const r=this.offsets.get(t);e(void 0!==r);const i=this.writer.getPos();this.writer.seek(r),this.writeBox(t),this.writer.seek(i)}measureBox(e){if(e.contents&&!e.children){return this.measureBoxHeader(e)+e.contents.byteLength}{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(const r of e.children)r&&(t+=this.measureBox(r));return t}}}const ot=new Uint8Array(8),ct=new DataView(ot.buffer),ut=e=>[(e%256+256)%256],dt=e=>(ct.setUint16(0,e,!1),[ot[0],ot[1]]),lt=e=>(ct.setInt16(0,e,!1),[ot[0],ot[1]]),ht=e=>(ct.setUint32(0,e,!1),[ot[1],ot[2],ot[3]]),mt=e=>(ct.setUint32(0,e,!1),[ot[0],ot[1],ot[2],ot[3]]),ft=e=>(ct.setInt32(0,e,!1),[ot[0],ot[1],ot[2],ot[3]]),pt=e=>(ct.setUint32(0,Math.floor(e/2**32),!1),ct.setUint32(4,e,!1),[ot[0],ot[1],ot[2],ot[3],ot[4],ot[5],ot[6],ot[7]]),gt=e=>(ct.setInt16(0,256*e,!1),[ot[0],ot[1]]),wt=e=>(ct.setInt32(0,65536*e,!1),[ot[0],ot[1],ot[2],ot[3]]),kt=e=>(ct.setInt32(0,2**30*e,!1),[ot[0],ot[1],ot[2],ot[3]]),bt=(e,t)=>{const r=[];let i=e;do{let e=127&i;i>>=7,r.length>0&&(e|=128),r.push(e),void 0!==t&&t--}while(i>0||t);return r.reverse()},yt=(e,t=!1)=>{const r=Array(e.length).fill(null).map(((t,r)=>e.charCodeAt(r)));return t&&r.push(0),r},Tt=e=>{let t=null;for(const r of e)(!t||r.timestamp>t.timestamp)&&(t=r);return t},St=e=>{const t=e*(Math.PI/180),r=Math.round(Math.cos(t)),i=Math.round(Math.sin(t));return[r,i,0,-i,r,0,0,0,1]},vt=St(0),Ct=e=>[wt(e[0]),wt(e[1]),kt(e[2]),wt(e[3]),wt(e[4]),kt(e[5]),wt(e[6]),wt(e[7]),kt(e[8])],xt=(e,t,r)=>({type:e,contents:t&&new Uint8Array(t.flat(10)),children:r}),Pt=(e,t,r,i,s)=>xt(e,[ut(t),ht(r),i??[]],s),_t=e=>({type:"mdat",largeSize:e}),Et=(e,t,r=!1)=>xt("moov",void 0,[It(t,e),...e.map((e=>Bt(e,t))),r?ur(e):null]),It=(e,t)=>{const r=ci(Math.max(0,...t.filter((e=>e.samples.length>0)).map((e=>{const t=Tt(e.samples);return t.timestamp+t.duration}))),ni),s=Math.max(0,...t.map((e=>e.track.id)))+1,a=!i(e)||!i(r),n=a?pt:mt;return Pt("mvhd",+a,0,[n(e),n(e),mt(ni),n(r),wt(1),gt(1),Array(10).fill(0),Ct(vt),Array(24).fill(0),mt(s)])},Bt=(e,t)=>{const r=oi(e);return xt("trak",void 0,[Mt(e,t),zt(e,t),void 0!==r.name?xt("udta",void 0,[xt("Â©nam",[...d.encode(r.name)])]):null])},Mt=(e,t)=>{const r=Tt(e.samples),s=ci(r?r.timestamp+r.duration:0,ni),a=!i(t)||!i(s),n=a?pt:mt;let o;if("video"===e.type){const t=e.track.metadata.rotation;o=St(t??0)}else o=vt;return Pt("tkhd",+a,3,[n(t),n(t),mt(e.track.id),mt(0),n(s),Array(8).fill(0),dt(0),dt(e.track.id),gt("audio"===e.type?1:0),dt(0),Ct(o),wt("video"===e.type?e.info.width:0),wt("video"===e.type?e.info.height:0)])},zt=(e,t)=>xt("mdia",void 0,[Ft(e,t),Rt(!0,At[e.type],Dt[e.type]),Ot(e)]),Ft=(e,t)=>{const r=Tt(e.samples),s=ci(r?r.timestamp+r.duration:0,e.timescale),a=!i(t)||!i(s),n=a?pt:mt;let o=0;for(const t of e.track.metadata.languageCode??A)o<<=5,o+=t.charCodeAt(0)-96;return Pt("mdhd",+a,0,[n(t),n(t),mt(e.timescale),n(s),dt(o),dt(0)])},At={video:"vide",audio:"soun",subtitle:"text"},Dt={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},Rt=(e,t,r)=>Pt("hdlr",0,0,[e?yt("mhlr"):mt(0),yt(t),mt(0),mt(0),mt(0),yt(r,!0)]),Ot=e=>xt("minf",void 0,[Wt[e.type](),Vt(),Nt(e)]),Wt={video:()=>Pt("vmhd",0,1,[dt(0),dt(0),dt(0),dt(0)]),audio:()=>Pt("smhd",0,0,[dt(0),dt(0)]),subtitle:()=>Pt("nmhd",0,0)},Vt=()=>xt("dinf",void 0,[Ut()]),Ut=()=>Pt("dref",0,0,[mt(1)],[Lt()]),Lt=()=>Pt("url ",0,1),Nt=e=>{const t=e.compositionTimeOffsetTable.length>1||e.compositionTimeOffsetTable.some((e=>0!==e.sampleCompositionTimeOffset));return xt("stbl",void 0,[Ht(e),rr(e),t?or(e):null,t?cr(e):null,sr(e),ar(e),nr(e),ir(e)])},Ht=t=>{let r;if("video"===t.type)r=qt(vr[t.track.source._codec],t);else if("audio"===t.type){const i=xr(t.track.source._codec,t.muxer.isQuickTime);e(i),r=Kt(i,t)}else"subtitle"===t.type&&(r=tr(_r[t.track.source._codec],t));return e(r),Pt("stsd",0,0,[mt(1)],[r])},qt=(e,t)=>xt(e,[Array(6).fill(0),dt(1),dt(0),dt(0),Array(12).fill(0),dt(t.info.width),dt(t.info.height),mt(4718592),mt(4718592),mt(0),dt(1),Array(32).fill(0),dt(24),lt(65535)],[Cr[t.track.source._codec](t),k(t.info.decoderConfig.colorSpace)?$t(t):null]),$t=e=>xt("colr",[yt("nclx"),dt(h[e.info.decoderConfig.colorSpace.primaries]),dt(f[e.info.decoderConfig.colorSpace.transfer]),dt(g[e.info.decoderConfig.colorSpace.matrix]),ut((e.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),jt=e=>{if(!e.info.decoderConfig)return null;const t=e.info.decoderConfig,r=t.codec.split("."),i=Number(r[1]),s=Number(r[2]),a=(Number(r[3])<<4)+((r[4]?Number(r[4]):1)<<1)+(r[8]?Number(r[8]):Number(t.colorSpace?.fullRange??0)),n=r[5]?Number(r[5]):t.colorSpace?.primaries?h[t.colorSpace.primaries]:2,o=r[6]?Number(r[6]):t.colorSpace?.transfer?f[t.colorSpace.transfer]:2,c=r[7]?Number(r[7]):t.colorSpace?.matrix?g[t.colorSpace.matrix]:2;return Pt("vpcC",1,0,[ut(i),ut(s),ut(a),ut(n),ut(o),ut(c),dt(0)])},Kt=(e,t)=>{let r,i=0,s=16;if(K.includes(t.track.source._codec)){const e=t.track.source._codec,{sampleSize:r}=fe(e);s=8*r,s>16&&(i=1)}return r=0===i?[Array(6).fill(0),dt(1),dt(i),dt(0),mt(0),dt(t.info.numberOfChannels),dt(s),dt(0),dt(0),dt(t.info.sampleRate<65536?t.info.sampleRate:0),dt(0)]:[Array(6).fill(0),dt(1),dt(i),dt(0),mt(0),dt(t.info.numberOfChannels),dt(Math.min(s,16)),dt(0),dt(0),dt(t.info.sampleRate<65536?t.info.sampleRate:0),dt(0),mt(1),mt(s/8),mt(t.info.numberOfChannels*s/8),mt(2)],xt(e,r,[Pr(t.track.source._codec,t.muxer.isQuickTime)?.(t)??null])},Qt=e=>{let t;switch(e.track.source._codec){case"aac":t=64;break;case"mp3":t=107;break;case"vorbis":t=221;break;default:throw new Error(`Unhandled audio codec: ${e.track.source._codec}`)}let r=[...ut(t),...ut(21),...ht(0),...mt(0),...mt(0)];if(e.info.decoderConfig.description){const t=o(e.info.decoderConfig.description);r=[...r,...ut(5),...bt(t.byteLength),...t]}return r=[...dt(1),...ut(0),...ut(4),...bt(r.length),...r,...ut(6),...ut(1),...ut(2)],r=[...ut(3),...bt(r.length),...r],Pt("esds",0,0,r)},Yt=e=>xt("wave",void 0,[Gt(e),Xt(e),xt("\0\0\0\0")]),Gt=e=>xt("frma",[yt(xr(e.track.source._codec,e.muxer.isQuickTime))]),Xt=e=>{const{littleEndian:t}=fe(e.track.source._codec);return xt("enda",[dt(+t)])},Jt=t=>{let r=t.info.numberOfChannels,i=3840,s=t.info.sampleRate,a=0,n=0,c=new Uint8Array(0);const u=t.info.decoderConfig?.description;if(u){e(u.byteLength>=18);const t=o(u),d=it(t);r=d.outputChannelCount,i=d.preSkip,s=d.inputSampleRate,a=d.outputGain,n=d.channelMappingFamily,d.channelMappingTable&&(c=d.channelMappingTable)}return xt("dOps",[ut(0),ut(r),dt(i),mt(s),lt(a),ut(n),...c])},Zt=t=>{const r=t.info.decoderConfig?.description;e(r);const i=o(r);return Pt("dfLa",0,0,[...i.subarray(4)])},er=e=>{const{littleEndian:t,sampleSize:r}=fe(e.track.source._codec);return Pt("pcmC",0,0,[ut(+t),ut(8*r)])},tr=(e,t)=>xt(e,[Array(6).fill(0),dt(1)],[Er[t.track.source._codec](t)]),rr=e=>Pt("stts",0,0,[mt(e.timeToSampleTable.length),e.timeToSampleTable.map((e=>[mt(e.sampleCount),mt(e.sampleDelta)]))]),ir=e=>{if(e.samples.every((e=>"key"===e.type)))return null;const t=[...e.samples.entries()].filter((([,e])=>"key"===e.type));return Pt("stss",0,0,[mt(t.length),t.map((([e])=>mt(e+1)))])},sr=e=>Pt("stsc",0,0,[mt(e.compactlyCodedChunkTable.length),e.compactlyCodedChunkTable.map((e=>[mt(e.firstChunk),mt(e.samplesPerChunk),mt(1)]))]),ar=e=>{if("audio"===e.type&&e.info.requiresPcmTransformation){const{sampleSize:t}=fe(e.track.source._codec);return Pt("stsz",0,0,[mt(t*e.info.numberOfChannels),mt(e.samples.reduce(((t,r)=>t+ci(r.duration,e.timescale)),0))])}return Pt("stsz",0,0,[mt(0),mt(e.samples.length),e.samples.map((e=>mt(e.size)))])},nr=e=>e.finalizedChunks.length>0&&r(e.finalizedChunks).offset>=2**32?Pt("co64",0,0,[mt(e.finalizedChunks.length),e.finalizedChunks.map((e=>pt(e.offset)))]):Pt("stco",0,0,[mt(e.finalizedChunks.length),e.finalizedChunks.map((e=>mt(e.offset)))]),or=e=>Pt("ctts",1,0,[mt(e.compositionTimeOffsetTable.length),e.compositionTimeOffsetTable.map((e=>[mt(e.sampleCount),ft(e.sampleCompositionTimeOffset)]))]),cr=t=>{let r=1/0,i=-1/0,s=1/0,a=-1/0;e(t.compositionTimeOffsetTable.length>0),e(t.samples.length>0);for(let e=0;e<t.compositionTimeOffsetTable.length;e++){const s=t.compositionTimeOffsetTable[e];r=Math.min(r,s.sampleCompositionTimeOffset),i=Math.max(i,s.sampleCompositionTimeOffset)}for(let e=0;e<t.samples.length;e++){const r=t.samples[e];s=Math.min(s,ci(r.timestamp,t.timescale)),a=Math.max(a,ci(r.timestamp+r.duration,t.timescale))}const n=Math.max(-r,0);return a>=2**31?null:Pt("cslg",0,0,[ft(n),ft(r),ft(i),ft(s),ft(a)])},ur=e=>xt("mvex",void 0,e.map(dr)),dr=e=>Pt("trex",0,0,[mt(e.track.id),mt(1),mt(0),mt(0),mt(0)]),lr=(e,t)=>xt("moof",void 0,[hr(e),...t.map(fr)]),hr=e=>Pt("mfhd",0,0,[mt(e)]),mr=e=>{let t=0,r=0;const i="delta"===e.type;return r|=+i,t|=i?1:2,t<<24|r<<16},fr=e=>xt("traf",void 0,[pr(e),gr(e),wr(e)]),pr=t=>{e(t.currentChunk);let r=0;r|=8,r|=16,r|=32,r|=131072;const i=t.currentChunk.samples[1]??t.currentChunk.samples[0],s={duration:i.timescaleUnitsToNextSample,size:i.size,flags:mr(i)};return Pt("tfhd",0,131128,[mt(t.track.id),mt(s.duration),mt(s.size),mt(s.flags)])},gr=t=>(e(t.currentChunk),Pt("tfdt",1,0,[pt(ci(t.currentChunk.startTimestamp,t.timescale))])),wr=t=>{e(t.currentChunk);const r=t.currentChunk.samples.map((e=>e.timescaleUnitsToNextSample)),i=t.currentChunk.samples.map((e=>e.size)),s=t.currentChunk.samples.map(mr),a=t.currentChunk.samples.map((e=>ci(e.timestamp-e.decodeTimestamp,t.timescale))),n=new Set(r),o=new Set(i),c=new Set(s),u=new Set(a),d=2===c.size&&s[0]!==s[1],l=n.size>1,h=o.size>1,m=!d&&c.size>1,f=u.size>1||[...u].some((e=>0!==e));let p=0;return p|=1,p|=4*+d,p|=256*+l,p|=512*+h,p|=1024*+m,p|=2048*+f,Pt("trun",1,p,[mt(t.currentChunk.samples.length),mt(t.currentChunk.offset-t.currentChunk.moofOffset||0),d?mt(s[0]):[],t.currentChunk.samples.map(((e,t)=>[l?mt(r[t]):[],h?mt(i[t]):[],m?mt(s[t]):[],f?ft(a[t]):[]]))])},kr=(e,t)=>Pt("tfra",1,0,[mt(e.track.id),mt(63),mt(e.finalizedChunks.length),e.finalizedChunks.map((r=>[pt(ci(r.samples[0].timestamp,e.timescale)),pt(r.moofOffset),mt(t+1),mt(1),mt(1)]))]),br=()=>Pt("mfro",0,0,[mt(0)]),yr=()=>xt("vtte"),Tr=(e,t,r,i,s)=>xt("vttc",void 0,[null!==s?xt("vsid",[ft(s)]):null,null!==r?xt("iden",[...d.encode(r)]):null,null!==t?xt("ctim",[...d.encode(Ve(t))]):null,null!==i?xt("sttg",[...d.encode(i)]):null,xt("payl",[...d.encode(e)])]),Sr=e=>xt("vtta",[...d.encode(e)]),vr={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},Cr={avc:e=>e.info.decoderConfig&&xt("avcC",[...o(e.info.decoderConfig.description)]),hevc:e=>e.info.decoderConfig&&xt("hvcC",[...o(e.info.decoderConfig.description)]),vp8:jt,vp9:jt,av1:e=>xt("av1C",ae(e.info.decoderConfig.codec))},xr=(e,t)=>{switch(e){case"aac":case"mp3":case"vorbis":return"mp4a";case"opus":return"Opus";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(t)switch(e){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":case"pcm-s24be":return"in24";case"pcm-s32":case"pcm-s32be":return"in32";case"pcm-f32":case"pcm-f32be":return"fl32";case"pcm-f64":case"pcm-f64be":return"fl64"}else switch(e){case"pcm-s16":case"pcm-s16be":case"pcm-s24":case"pcm-s24be":case"pcm-s32":case"pcm-s32be":return"ipcm";case"pcm-f32":case"pcm-f32be":case"pcm-f64":case"pcm-f64be":return"fpcm"}},Pr=(e,t)=>{switch(e){case"aac":case"mp3":case"vorbis":return Qt;case"opus":return Jt;case"flac":return Zt}if(t)switch(e){case"pcm-s24":case"pcm-s24be":case"pcm-s32":case"pcm-s32be":case"pcm-f32":case"pcm-f32be":case"pcm-f64":case"pcm-f64be":return Yt}else switch(e){case"pcm-s16":case"pcm-s16be":case"pcm-s24":case"pcm-s24be":case"pcm-s32":case"pcm-s32be":case"pcm-f32":case"pcm-f32be":case"pcm-f64":case"pcm-f64be":return er}return null},_r={webvtt:"wvtt"},Er={webvtt:e=>xt("vttC",[...d.encode(e.info.config.description)])};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class Ir{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let t=this.getPos();if(t<this.trackedStart){if(t+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-t),t=0}const r=t+e.byteLength-this.trackedStart;let i=this.trackedWrites.byteLength;for(;i<r;)i*=2;if(i!==this.trackedWrites.byteLength){const e=new Uint8Array(i);e.set(this.trackedWrites,0),this.trackedWrites=e}this.trackedWrites.set(e,t-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,t+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(1024),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const e={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,e}}const Br=65536,Mr=2**32;class zr extends Ir{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(Br,{maxByteLength:Mr})}catch{this.buffer=new ArrayBuffer(Br),this.supportsResize=!1}else this.buffer=new ArrayBuffer(Br);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let t=this.buffer.byteLength;for(;t<e;)t*=2;if(t!==this.buffer.byteLength){if(t>Mr)throw new Error("ArrayBuffer exceeded maximum size of 4294967296 bytes. Please consider using another target.");if(this.supportsResize)this.buffer.resize(t);else{const e=new ArrayBuffer(t),r=new Uint8Array(e);r.set(this.bytes,0),this.buffer=e,this.bytes=r}}}write(e){this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,t){return this.bytes.slice(e,t)}}class Fr extends Ir{constructor(e){super(),this.pos=0,this.sections=[],this.lastWriteEnd=0,this.lastFlushEnd=0,this.writer=null,this.chunks=[],this.target=e,this.chunked=e._options.chunked??!1,this.chunkSize=e._options.chunkSize??16777216}start(){this.writer=this.target._writable.getWriter()}write(e){if(this.pos>this.lastWriteEnd){const e=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(e))}this.maybeTrackWrites(e),this.sections.push({data:e.slice(),start:this.pos}),this.pos+=e.byteLength,this.lastWriteEnd=Math.max(this.lastWriteEnd,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(this.pos>this.lastWriteEnd){const e=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(e))}if(e(this.writer),0===this.sections.length)return;const t=[],r=[...this.sections].sort(((e,t)=>e.start-t.start));t.push({start:r[0].start,size:r[0].data.byteLength});for(let e=1;e<r.length;e++){const i=t[t.length-1],s=r[e];s.start<=i.start+i.size?i.size=Math.max(i.size,s.start+s.data.byteLength-i.start):t.push({start:s.start,size:s.data.byteLength})}for(const e of t){e.data=new Uint8Array(e.size);for(const t of this.sections)e.start<=t.start&&t.start<e.start+e.size&&e.data.set(t.data,t.start-e.start);if(null!==this.writer.desiredSize&&this.writer.desiredSize<=0&&await this.writer.ready,this.chunked)this.writeDataIntoChunks(e.data,e.start),this.tryToFlushChunks();else{if(this.ensureMonotonicity&&e.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:e.data,position:e.start}),this.lastFlushEnd=e.start+e.data.byteLength}}this.sections.length=0}writeDataIntoChunks(e,t){let r=this.chunks.findIndex((e=>e.start<=t&&t<e.start+this.chunkSize));-1===r&&(r=this.createChunk(t));const i=this.chunks[r],s=t-i.start,a=e.subarray(0,Math.min(this.chunkSize-s,e.byteLength));i.data.set(a,s);const n={start:s,end:s+a.byteLength};if(this.insertSectionIntoChunk(i,n),0===i.written[0].start&&i.written[0].end===this.chunkSize&&(i.shouldFlush=!0),this.chunks.length>2){for(let e=0;e<this.chunks.length-1;e++)this.chunks[e].shouldFlush=!0;this.tryToFlushChunks()}a.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(a.byteLength),t+a.byteLength)}insertSectionIntoChunk(e,t){let r=0,i=e.written.length-1,s=-1;for(;r<=i;){const a=Math.floor(r+(i-r+1)/2);e.written[a].start<=t.start?(r=a+1,s=a):i=a-1}for(e.written.splice(s+1,0,t),(-1===s||e.written[s].end<t.start)&&s++;s<e.written.length-1&&e.written[s].end>=e.written[s+1].start;)e.written[s].end=Math.max(e.written[s].end,e.written[s+1].end),e.written.splice(s+1,1)}createChunk(e){const t={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(t),this.chunks.sort(((e,t)=>e.start-t.start)),this.chunks.indexOf(t)}tryToFlushChunks(t=!1){e(this.writer);for(let e=0;e<this.chunks.length;e++){const r=this.chunks[e];if(r.shouldFlush||t){for(const e of r.written){const t=r.start+e.start;if(this.ensureMonotonicity&&t!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:r.data.subarray(e.start,e.end),position:t}),this.lastFlushEnd=r.start+e.end}this.chunks.splice(e--,1)}}}finalize(){return this.chunked&&this.tryToFlushChunks(!0),e(this.writer),this.writer.close()}async close(){return this.writer?.close()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ar{constructor(){this._output=null}}class Dr extends Ar{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new zr(this)}}class Rr extends Ar{constructor(e,t={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(null!=t&&"object"!=typeof t)throw new TypeError("StreamTarget options, when provided, must be an object.");if(void 0!==t.chunked&&"boolean"!=typeof t.chunked)throw new TypeError("options.chunked, when provided, must be a boolean.");if(void 0!==t.chunkSize&&(!Number.isInteger(t.chunkSize)||t.chunkSize<1024))throw new TypeError("options.chunkSize, when provided, must be an integer and not smaller than 1024.");this._writable=e,this._options=t}_createWriter(){return new Fr(this)}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Or=e=>{let t=(e.hasVideo?"video/":e.hasAudio?"audio/":"application/")+(e.isQuickTime?"quicktime":"mp4");if(e.codecStrings.length>0){t+=`; codecs="${[...new Set(e.codecStrings)].join(", ")}"`}return t};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Wr{constructor(e){this.source=e}requestSlice(e,t){if(e+t>this.fileSize)return null;const r=e+t,i=this.source._read(e,r);return i instanceof Promise?i.then((t=>t?new Vr(t.bytes,t.view,t.offset,e,r):null)):i?new Vr(i.bytes,i.view,i.offset,e,r):null}requestSliceRange(e,t,r){return this.requestSlice(e,F(this.fileSize-e,t,r))}}class Vr{constructor(e,t,r,i,s){this.bytes=e,this.view=t,this.offset=r,this.start=i,this.end=s,this.bufferPos=i-r}static tempFromBytes(e){return new Vr(e,c(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}skip(e){this.bufferPos+=e}slice(e,t=this.end-e){if(e<this.start||e+t>this.end)throw new RangeError("Slicing outside of original slice.");return new Vr(this.bytes,this.view,this.offset,e,e+t)}}const Ur=(e,t)=>{const r=e.bytes.subarray(e.bufferPos,e.bufferPos+t);return e.bufferPos+=t,r},Lr=e=>e.view.getUint8(e.bufferPos++),Nr=(e,t)=>{const r=e.view.getUint16(e.bufferPos,t);return e.bufferPos+=2,r},Hr=e=>{const t=e.view.getUint16(e.bufferPos,!1);return e.bufferPos+=2,t},qr=e=>256*Hr(e)+Lr(e),$r=e=>{const t=e.view.getInt16(e.bufferPos,!1);return e.bufferPos+=2,t},jr=(e,t)=>{const r=e.view.getUint32(e.bufferPos,t);return e.bufferPos+=4,r},Kr=e=>{const t=e.view.getUint32(e.bufferPos,!1);return e.bufferPos+=4,t},Qr=e=>{const t=e.view.getUint32(e.bufferPos,!0);return e.bufferPos+=4,t},Yr=e=>{const t=e.view.getInt32(e.bufferPos,!1);return e.bufferPos+=4,t},Gr=(e,t)=>{let r,i;return t?(r=jr(e,!0),i=jr(e,!0)):(i=jr(e,!1),r=jr(e,!1)),4294967296*i+r},Xr=e=>4294967296*Kr(e)+Kr(e),Jr=e=>4294967296*Yr(e)+Kr(e),Zr=e=>{const t=e.view.getFloat64(e.bufferPos,!1);return e.bufferPos+=8,t},ei=(e,t)=>{if(e.bufferPos+t>e.bytes.length)throw new RangeError("Reading past end of slice.");let r="";for(let i=0;i<t;i++)r+=String.fromCharCode(e.bytes[e.bufferPos++]);return r},ti=16,ri=e=>{let t=Kr(e);const r=ei(e,4);let i=8;1===t&&(t=Xr(e),i=16);const s=t-i;return s<0?null:{name:r,totalSize:t,headerSize:i,contentSize:s}},ii=e=>Yr(e)/65536,si=e=>Yr(e)/1073741824,ai=e=>{let t=0;for(let r=0;r<4;r++){t<<=7;const r=Lr(e);if(t|=127&r,!(128&r))break}return t},ni=1e3,oi=e=>{const t={},r=e.track;return void 0!==r.metadata.name&&(t.name=r.metadata.name),t},ci=(e,t,r=!0)=>{const i=e*t;return r?Math.round(i):i};class ui extends Me{constructor(e,t){super(e),this.auxTarget=new Dr,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new nt(this.auxWriter),this.mdat=null,this.trackDatas=[],this.allTracksKnown=P(),this.creationTime=Math.floor(Date.now()/1e3)+2082844800,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=t,this.writer=e._writer,this.boxWriter=new nt(this.writer),this.isQuickTime=t instanceof Js;const r=this.writer instanceof zr&&"in-memory";this.fastStart=t._options.fastStart??r,this.isFragmented="fragmented"===this.fastStart,("in-memory"===this.fastStart||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=t._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),t=this.output._tracks.some((e=>"video"===e.type&&"avc"===e.source._codec));if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox((r={isQuickTime:this.isQuickTime,holdsAvc:t,fragmented:this.isFragmented}).isQuickTime?xt("ftyp",[yt("qt  "),mt(512),yt("qt  ")]):r.fragmented?xt("ftyp",[yt("iso5"),mt(512),yt("iso5"),yt("iso6"),yt("mp41")]):xt("ftyp",[yt("isom"),mt(512),yt("isom"),r.holdsAvc?yt("avc1"):[],yt("mp41")])),this.format._options.onFtyp){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onFtyp(e,t)}var r;"in-memory"===this.fastStart?this.mdat=_t(!1):this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=_t(!0),this.boxWriter.writeBox(this.mdat)),await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some((t=>t.track===e)))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map((e=>{if("video"===e.type)return e.info.decoderConfig.codec;if("audio"===e.type)return e.info.decoderConfig.codec;return{webvtt:"wvtt"}[e.track.source._codec]}));return Or({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some((e=>"video"===e.type)),hasAudio:this.trackDatas.some((e=>"audio"===e.type)),codecStrings:e})}getVideoTrackData(t,r,i){const s=this.trackDatas.find((e=>e.track===t));if(s)return s;_e(i),e(i),e(i.decoderConfig);const a={...i.decoderConfig};e(void 0!==a.codedWidth),e(void 0!==a.codedHeight);let n=!1;if("avc"!==t.source._codec||a.description){if("hevc"===t.source._codec&&!a.description){const e=je(r.data);if(!e)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");a.description=(e=>{const t=[];t.push(e.configurationVersion),t.push((3&e.generalProfileSpace)<<6|(1&e.generalTierFlag)<<5|31&e.generalProfileIdc),t.push(e.generalProfileCompatibilityFlags>>>24&255),t.push(e.generalProfileCompatibilityFlags>>>16&255),t.push(e.generalProfileCompatibilityFlags>>>8&255),t.push(255&e.generalProfileCompatibilityFlags),t.push(...e.generalConstraintIndicatorFlags),t.push(255&e.generalLevelIdc),t.push(240|e.minSpatialSegmentationIdc>>8&15),t.push(255&e.minSpatialSegmentationIdc),t.push(252|3&e.parallelismType),t.push(252|3&e.chromaFormatIdc),t.push(248|7&e.bitDepthLumaMinus8),t.push(248|7&e.bitDepthChromaMinus8),t.push(e.avgFrameRate>>8&255),t.push(255&e.avgFrameRate),t.push((3&e.constantFrameRate)<<6|(7&e.numTemporalLayers)<<3|(1&e.temporalIdNested)<<2|3&e.lengthSizeMinusOne),t.push(255&e.arrays.length);for(const r of e.arrays){t.push((1&r.arrayCompleteness)<<7|63&r.nalUnitType),t.push(r.nalUnits.length>>8&255),t.push(255&r.nalUnits.length);for(const e of r.nalUnits){t.push(e.length>>8&255),t.push(255&e.length);for(let r=0;r<e.length;r++)t.push(e[r])}}return new Uint8Array(t)})(e),n=!0}}else{const t=qe(r.data);if(!t)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");a.description=(t=>{const r=[];r.push(t.configurationVersion),r.push(t.avcProfileIndication),r.push(t.profileCompatibility),r.push(t.avcLevelIndication),r.push(252|3&t.lengthSizeMinusOne),r.push(224|31&t.sequenceParameterSets.length);for(const e of t.sequenceParameterSets){const t=e.byteLength;r.push(t>>8),r.push(255&t);for(let i=0;i<t;i++)r.push(e[i])}r.push(t.pictureParameterSets.length);for(const e of t.pictureParameterSets){const t=e.byteLength;r.push(t>>8),r.push(255&t);for(let i=0;i<t;i++)r.push(e[i])}if(100===t.avcProfileIndication||110===t.avcProfileIndication||122===t.avcProfileIndication||144===t.avcProfileIndication){e(null!==t.chromaFormat),e(null!==t.bitDepthLumaMinus8),e(null!==t.bitDepthChromaMinus8),e(null!==t.sequenceParameterSetExt),r.push(252|3&t.chromaFormat),r.push(248|7&t.bitDepthLumaMinus8),r.push(248|7&t.bitDepthChromaMinus8),r.push(t.sequenceParameterSetExt.length);for(const e of t.sequenceParameterSetExt){const t=e.byteLength;r.push(t>>8),r.push(255&t);for(let i=0;i<t;i++)r.push(e[i])}}return new Uint8Array(r)})(t),n=!0}const o=((e,t)=>{const r=e<0?-1:1;let i=0,s=1,a=1,n=0,o=e=Math.abs(e);for(;;){const e=Math.floor(o),c=e*a+i,u=e*n+s;if(u>t)return{numerator:r*a,denominator:n};if(i=a,s=n,a=c,n=u,o=1/(o-e),!isFinite(o))break}return{numerator:r*a,denominator:n}})(1/(t.metadata.frameRate??57600),1e6).denominator,c={muxer:this,track:t,type:"video",info:{width:a.codedWidth,height:a.codedHeight,decoderConfig:a,requiresAnnexBTransformation:n},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(c),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),c}getAudioTrackData(t,r){const i=this.trackDatas.find((e=>e.track===t));if(i)return i;Ie(r),e(r),e(r.decoderConfig);const s={muxer:this,track:t,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:r.decoderConfig,requiresPcmTransformation:!this.isFragmented&&K.includes(t.source._codec)},timescale:r.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(s),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}getSubtitleTrackData(t,r){const i=this.trackDatas.find((e=>e.track===t));if(i)return i;Be(r),e(r),e(r.config);const s={muxer:this,track:t,type:"subtitle",info:{config:r.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(s),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,t,r){const i=await this.mutex.acquire();try{const i=this.getVideoTrackData(e,t,r);let s=t.data;if(i.info.requiresAnnexBTransformation){const e=(e=>{const t=Ue(e);if(0===t.length)return null;let r=0;for(const e of t)r+=4+e.byteLength;const i=new Uint8Array(r),s=new DataView(i.buffer);let a=0;for(const e of t){const t=e.byteLength;s.setUint32(a,t,!1),a+=4,i.set(e,a),a+=e.byteLength}return i})(s);if(!e)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");s=e}const a=this.validateAndNormalizeTimestamp(i.track,t.timestamp,"key"===t.type),n=this.createSampleForTrack(i,s,a,t.duration,t.type);await this.registerSample(i,n)}finally{i()}}async addEncodedAudioPacket(e,t,r){const i=await this.mutex.acquire();try{const i=this.getAudioTrackData(e,r),s=this.validateAndNormalizeTimestamp(i.track,t.timestamp,"key"===t.type),a=this.createSampleForTrack(i,t.data,s,t.duration,t.type);i.info.requiresPcmTransformation&&await this.maybePadWithSilence(i,s),await this.registerSample(i,a)}finally{i()}}async maybePadWithSilence(e,t){const i=r(e.samples),s=i?i.timestamp+i.duration:0,a=t-s,n=ci(a,e.timescale);if(n>0){const{sampleSize:t,silentValue:r}=fe(e.info.decoderConfig.codec),i=n*e.info.numberOfChannels,o=new Uint8Array(t*i).fill(r),c=this.createSampleForTrack(e,new Uint8Array(o.buffer),s,a,"key");await this.registerSample(e,c)}}async addSubtitleCue(e,t,r){const i=await this.mutex.acquire();try{const i=this.getSubtitleTrackData(e,r);this.validateAndNormalizeTimestamp(i.track,t.timestamp,!0),"webvtt"===e.source._codec&&(i.cueQueue.push(t),await this.processWebVTTCues(i,t.timestamp))}finally{i()}}async processWebVTTCues(t,r){for(;t.cueQueue.length>0;){const i=new Set([]);for(const s of t.cueQueue)e(s.timestamp<=r),e(t.lastCueEndTimestamp<=s.timestamp+s.duration),i.add(Math.max(s.timestamp,t.lastCueEndTimestamp)),i.add(s.timestamp+s.duration);const s=[...i].sort(((e,t)=>e-t)),a=s[0],n=s[1]??a;if(r<n)break;if(t.lastCueEndTimestamp<a){this.auxWriter.seek(0);const e=yr();this.auxBoxWriter.writeBox(e);const r=this.auxWriter.getSlice(0,this.auxWriter.getPos()),i=this.createSampleForTrack(t,r,t.lastCueEndTimestamp,a-t.lastCueEndTimestamp,"key");await this.registerSample(t,i),t.lastCueEndTimestamp=a}this.auxWriter.seek(0);for(let e=0;e<t.cueQueue.length;e++){const r=t.cueQueue[e];if(r.timestamp>=n)break;De.lastIndex=0;const i=De.test(r.text),s=r.timestamp+r.duration;let o=t.cueToSourceId.get(r);if(void 0===o&&n<s&&(o=t.nextSourceId++,t.cueToSourceId.set(r,o)),r.notes){const e=Sr(r.notes);this.auxBoxWriter.writeBox(e)}const c=Tr(r.text,i?a:null,r.identifier??null,r.settings??null,o??null);this.auxBoxWriter.writeBox(c),s===n&&t.cueQueue.splice(e--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),c=this.createSampleForTrack(t,o,a,n-a,"key");await this.registerSample(t,c),t.lastCueEndTimestamp=n}}createSampleForTrack(e,t,r,i,s){return{timestamp:r,decodeTimestamp:r,duration:i,data:t,size:t.byteLength,type:s,timescaleUnitsToNextSample:ci(i,e.timescale)}}processTimestamps(t,i){if(0===t.timestampProcessingQueue.length)return;if("audio"===t.type&&t.info.requiresPcmTransformation){let e=0;for(let r=0;r<t.timestampProcessingQueue.length;r++){const i=t.timestampProcessingQueue[r];e+=ci(i.duration,t.timescale)}if(0===t.timeToSampleTable.length)t.timeToSampleTable.push({sampleCount:e,sampleDelta:1});else{r(t.timeToSampleTable).sampleCount+=e}return void(t.timestampProcessingQueue.length=0)}const s=t.timestampProcessingQueue.map((e=>e.timestamp)).sort(((e,t)=>e-t));for(let i=0;i<t.timestampProcessingQueue.length;i++){const a=t.timestampProcessingQueue[i];a.decodeTimestamp=s[i],this.isFragmented||null!==t.lastTimescaleUnits||(a.decodeTimestamp=0);const n=ci(a.timestamp-a.decodeTimestamp,t.timescale),o=ci(a.duration,t.timescale);if(null!==t.lastTimescaleUnits){e(t.lastSample);const i=ci(a.decodeTimestamp,t.timescale,!1),s=Math.round(i-t.lastTimescaleUnits);if(e(s>=0),t.lastTimescaleUnits+=s,t.lastSample.timescaleUnitsToNextSample=s,!this.isFragmented){let i=r(t.timeToSampleTable);if(e(i),1===i.sampleCount){i.sampleDelta=s;const e=t.timeToSampleTable[t.timeToSampleTable.length-2];e&&e.sampleDelta===s&&(e.sampleCount++,t.timeToSampleTable.pop(),i=e)}else i.sampleDelta!==s&&(i.sampleCount--,t.timeToSampleTable.push(i={sampleCount:1,sampleDelta:s}));i.sampleDelta===o?i.sampleCount++:t.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const a=r(t.compositionTimeOffsetTable);e(a),a.sampleCompositionTimeOffset===n?a.sampleCount++:t.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:n})}}else t.lastTimescaleUnits=ci(a.decodeTimestamp,t.timescale,!1),this.isFragmented||(t.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),t.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:n}));t.lastSample=a}if(t.timestampProcessingQueue.length=0,e(t.lastSample),e(null!==t.lastTimescaleUnits),void 0!==i&&0===t.lastSample.timescaleUnitsToNextSample){e("key"===i.type);const r=ci(i.timestamp,t.timescale,!1),s=Math.round(r-t.lastTimescaleUnits);t.lastSample.timescaleUnitsToNextSample=s}}async registerSample(e,t){"key"===t.type&&this.processTimestamps(e,t),e.timestampProcessingQueue.push(t),this.isFragmented?(e.sampleQueue.push(t),await this.interleaveSamples()):await this.addSampleToTrack(e,t)}async addSampleToTrack(t,r){this.isFragmented||t.samples.push(r);let i=!1;if(t.currentChunk){t.currentChunk.startTimestamp=Math.min(t.currentChunk.startTimestamp,r.timestamp);const e=r.timestamp-t.currentChunk.startTimestamp;if(this.isFragmented){const s=this.trackDatas.every((e=>{if(t===e)return"key"===r.type;const i=e.sampleQueue[0];return i?"key"===i.type:e.track.source._closed}));e>=this.minimumFragmentDuration&&s&&r.timestamp>this.maxWrittenTimestamp&&(i=!0,await this.finalizeFragment())}else i=e>=.5}else i=!0;i&&(t.currentChunk&&await this.finalizeCurrentChunk(t),t.currentChunk={startTimestamp:r.timestamp,samples:[],offset:null,moofOffset:null}),e(t.currentChunk),t.currentChunk.samples.push(r),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,r.timestamp))}async finalizeCurrentChunk(t){if(e(!this.isFragmented),!t.currentChunk)return;t.finalizedChunks.push(t.currentChunk),this.finalizedChunks.push(t.currentChunk);let i=t.currentChunk.samples.length;if("audio"===t.type&&t.info.requiresPcmTransformation&&(i=t.currentChunk.samples.reduce(((e,r)=>e+ci(r.duration,t.timescale)),0)),0!==t.compactlyCodedChunkTable.length&&r(t.compactlyCodedChunkTable).samplesPerChunk===i||t.compactlyCodedChunkTable.push({firstChunk:t.finalizedChunks.length,samplesPerChunk:i}),"in-memory"!==this.fastStart){t.currentChunk.offset=this.writer.getPos();for(const r of t.currentChunk.samples)e(r.data),this.writer.write(r.data),r.data=null;await this.writer.flush()}else t.currentChunk.offset=0}async interleaveSamples(t=!1){if(e(this.isFragmented),t||this.allTracksAreKnown())e:for(;;){let e=null,r=1/0;for(const i of this.trackDatas){if(!t&&0===i.sampleQueue.length&&!i.track.source._closed)break e;i.sampleQueue.length>0&&i.sampleQueue[0].timestamp<r&&(e=i,r=i.sampleQueue[0].timestamp)}if(!e)break;const i=e.sampleQueue.shift();await this.addSampleToTrack(e,i)}}async finalizeFragment(t=!0){e(this.isFragmented);const r=this.nextFragmentNumber++;if(1===r){this.format._options.onMoov&&this.writer.startTrackingWrites();const e=Et(this.trackDatas,this.creationTime,!0);if(this.boxWriter.writeBox(e),this.format._options.onMoov){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoov(e,t)}}const i=this.trackDatas.filter((e=>e.currentChunk)),s=lr(r,i),a=this.writer.getPos(),n=a+this.boxWriter.measureBox(s);let o=n+8,c=1/0;for(const e of i){e.currentChunk.offset=o,e.currentChunk.moofOffset=a;for(const t of e.currentChunk.samples)o+=t.size;c=Math.min(c,e.currentChunk.startTimestamp)}const u=o-n,d=u>=2**32;if(d)for(const e of i)e.currentChunk.offset+=8;this.format._options.onMoof&&this.writer.startTrackingWrites();const l=lr(r,i);if(this.boxWriter.writeBox(l),this.format._options.onMoof){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoof(e,t,c)}e(this.writer.getPos()===n),this.format._options.onMdat&&this.writer.startTrackingWrites();const h=_t(d);h.size=u,this.boxWriter.writeBox(h),this.writer.seek(n+(d?ti:8));for(const e of i)for(const t of e.currentChunk.samples)this.writer.write(t.data),t.data=null;if(this.format._options.onMdat){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMdat(e,t)}for(const e of i)e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk),e.currentChunk=null;t&&await this.writer.flush()}async onTrackClose(e){const t=await this.mutex.acquire();if("subtitle"===e.type&&"webvtt"===e.source._codec){const t=this.trackDatas.find((t=>t.track===e));t&&await this.processWebVTTCues(t,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),t()}async finalize(){const t=await this.mutex.acquire();this.allTracksKnown.resolve();for(const e of this.trackDatas)"subtitle"===e.type&&"webvtt"===e.track.source._codec&&await this.processWebVTTCues(e,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const e of this.trackDatas)this.processTimestamps(e);await this.finalizeFragment(!1)}else for(const e of this.trackDatas)this.processTimestamps(e),await this.finalizeCurrentChunk(e);if("in-memory"===this.fastStart){let t;e(this.mdat);for(let r=0;r<2;r++){const r=Et(this.trackDatas,this.creationTime),i=this.boxWriter.measureBox(r);t=this.boxWriter.measureBox(this.mdat);let s=this.writer.getPos()+i+t;for(const r of this.finalizedChunks){r.offset=s;for(const{data:i}of r.samples)e(i),s+=i.byteLength,t+=i.byteLength}if(s<2**32)break;t>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const r=Et(this.trackDatas,this.creationTime);if(this.boxWriter.writeBox(r),this.format._options.onMoov){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoov(e,t)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=t,this.boxWriter.writeBox(this.mdat);for(const t of this.finalizedChunks)for(const r of t.samples)e(r.data),this.writer.write(r.data),r.data=null;if(this.format._options.onMdat){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMdat(e,t)}}else if(this.isFragmented){const e=this.writer.getPos(),t=(r=this.trackDatas,xt("mfra",void 0,[...r.map(kr),br()]));this.boxWriter.writeBox(t);const i=this.writer.getPos()-e;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(i)}else{e(this.mdat);const t=this.boxWriter.offsets.get(this.mdat);e(void 0!==t);const r=this.writer.getPos()-t;if(this.mdat.size=r,this.mdat.largeSize=r>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMdat(e,t)}this.format._options.onMoov&&this.writer.startTrackingWrites();const i=Et(this.trackDatas,this.creationTime);if(this.boxWriter.writeBox(i),this.format._options.onMoov){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onMoov(e,t)}}var r;t()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class di{constructor(e){this.value=e}}class li{constructor(e){this.value=e}}class hi{constructor(e){this.value=e}}class mi{constructor(e){this.value=e}}var fi;!function(e){e[e.EBML=440786851]="EBML",e[e.EBMLVersion=17030]="EBMLVersion",e[e.EBMLReadVersion=17143]="EBMLReadVersion",e[e.EBMLMaxIDLength=17138]="EBMLMaxIDLength",e[e.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",e[e.DocType=17026]="DocType",e[e.DocTypeVersion=17031]="DocTypeVersion",e[e.DocTypeReadVersion=17029]="DocTypeReadVersion",e[e.Segment=408125543]="Segment",e[e.SeekHead=290298740]="SeekHead",e[e.Seek=19899]="Seek",e[e.SeekID=21419]="SeekID",e[e.SeekPosition=21420]="SeekPosition",e[e.Duration=17545]="Duration",e[e.Info=357149030]="Info",e[e.TimestampScale=2807729]="TimestampScale",e[e.MuxingApp=19840]="MuxingApp",e[e.WritingApp=22337]="WritingApp",e[e.Tracks=374648427]="Tracks",e[e.TrackEntry=174]="TrackEntry",e[e.TrackNumber=215]="TrackNumber",e[e.TrackUID=29637]="TrackUID",e[e.TrackType=131]="TrackType",e[e.FlagEnabled=185]="FlagEnabled",e[e.FlagDefault=136]="FlagDefault",e[e.FlagForced=21930]="FlagForced",e[e.FlagLacing=156]="FlagLacing",e[e.Name=21358]="Name",e[e.Language=2274716]="Language",e[e.LanguageBCP47=2274717]="LanguageBCP47",e[e.CodecID=134]="CodecID",e[e.CodecPrivate=25506]="CodecPrivate",e[e.CodecDelay=22186]="CodecDelay",e[e.SeekPreRoll=22203]="SeekPreRoll",e[e.DefaultDuration=2352003]="DefaultDuration",e[e.Video=224]="Video",e[e.PixelWidth=176]="PixelWidth",e[e.PixelHeight=186]="PixelHeight",e[e.Audio=225]="Audio",e[e.SamplingFrequency=181]="SamplingFrequency",e[e.Channels=159]="Channels",e[e.BitDepth=25188]="BitDepth",e[e.SimpleBlock=163]="SimpleBlock",e[e.BlockGroup=160]="BlockGroup",e[e.Block=161]="Block",e[e.BlockAdditions=30113]="BlockAdditions",e[e.BlockMore=166]="BlockMore",e[e.BlockAdditional=165]="BlockAdditional",e[e.BlockAddID=238]="BlockAddID",e[e.BlockDuration=155]="BlockDuration",e[e.ReferenceBlock=251]="ReferenceBlock",e[e.Cluster=524531317]="Cluster",e[e.Timestamp=231]="Timestamp",e[e.Cues=475249515]="Cues",e[e.CuePoint=187]="CuePoint",e[e.CueTime=179]="CueTime",e[e.CueTrackPositions=183]="CueTrackPositions",e[e.CueTrack=247]="CueTrack",e[e.CueClusterPosition=241]="CueClusterPosition",e[e.Colour=21936]="Colour",e[e.MatrixCoefficients=21937]="MatrixCoefficients",e[e.TransferCharacteristics=21946]="TransferCharacteristics",e[e.Primaries=21947]="Primaries",e[e.Range=21945]="Range",e[e.Projection=30320]="Projection",e[e.ProjectionType=30321]="ProjectionType",e[e.ProjectionPoseRoll=30325]="ProjectionPoseRoll",e[e.Attachments=423732329]="Attachments",e[e.Chapters=272869232]="Chapters",e[e.Tags=307544935]="Tags"}(fi||(fi={}));const pi=[fi.EBML,fi.Segment],gi=[fi.SeekHead,fi.Info,fi.Cluster,fi.Tracks,fi.Cues,fi.Attachments,fi.Chapters,fi.Tags],wi=[...pi,...gi],ki=e=>e<256?1:e<65536?2:e<1<<24?3:e<2**32?4:e<2**40?5:6,bi=e=>e>=-64&&e<64?1:e>=-8192&&e<8192?2:e>=-1048576&&e<1<<20?3:e>=-(1<<27)&&e<1<<27?4:e>=-(2**34)&&e<2**34?5:6;class yi{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap,this.dataOffsets=new WeakMap}writeByte(e){this.helperView.setUint8(0,e),this.writer.write(this.helper.subarray(0,1))}writeFloat32(e){this.helperView.setFloat32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeFloat64(e){this.helperView.setFloat64(0,e,!1),this.writer.write(this.helper)}writeUnsignedInt(e,t=ki(e)){let r=0;switch(t){case 6:this.helperView.setUint8(r++,e/2**40|0);case 5:this.helperView.setUint8(r++,e/2**32|0);case 4:this.helperView.setUint8(r++,e>>24);case 3:this.helperView.setUint8(r++,e>>16);case 2:this.helperView.setUint8(r++,e>>8);case 1:this.helperView.setUint8(r++,e);break;default:throw new Error("Bad unsigned int size "+t)}this.writer.write(this.helper.subarray(0,r))}writeSignedInt(e,t=bi(e)){e<0&&(e+=2**(8*t)),this.writeUnsignedInt(e,t)}writeVarInt(e,t=(e=>{if(e<127)return 1;if(e<16383)return 2;if(e<2097151)return 3;if(e<268435455)return 4;if(e<2**35-1)return 5;if(e<2**42-1)return 6;throw new Error("EBML varint size not supported "+e)})(e)){let r=0;switch(t){case 1:this.helperView.setUint8(r++,128|e);break;case 2:this.helperView.setUint8(r++,64|e>>8),this.helperView.setUint8(r++,e);break;case 3:this.helperView.setUint8(r++,32|e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 4:this.helperView.setUint8(r++,16|e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 5:this.helperView.setUint8(r++,8|e/2**32&7),this.helperView.setUint8(r++,e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 6:this.helperView.setUint8(r++,4|e/2**40&3),this.helperView.setUint8(r++,e/2**32|0),this.helperView.setUint8(r++,e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;default:throw new Error("Bad EBML varint size "+t)}this.writer.write(this.helper.subarray(0,r))}writeAsciiString(e){this.writer.write(new Uint8Array(e.split("").map((e=>e.charCodeAt(0)))))}writeEBML(e){if(null!==e)if(e instanceof Uint8Array)this.writer.write(e);else if(Array.isArray(e))for(const t of e)this.writeEBML(t);else if(this.offsets.set(e,this.writer.getPos()),this.writeUnsignedInt(e.id),Array.isArray(e.data)){const t=this.writer.getPos(),r=-1===e.size?1:e.size??4;-1===e.size?this.writeByte(255):this.writer.seek(this.writer.getPos()+r);const i=this.writer.getPos();if(this.dataOffsets.set(e,i),this.writeEBML(e.data),-1!==e.size){const e=this.writer.getPos()-i,s=this.writer.getPos();this.writer.seek(t),this.writeVarInt(e,r),this.writer.seek(s)}}else if("number"==typeof e.data){const t=e.size??ki(e.data);this.writeVarInt(t),this.writeUnsignedInt(e.data,t)}else if("string"==typeof e.data)this.writeVarInt(e.data.length),this.writeAsciiString(e.data);else if(e.data instanceof Uint8Array)this.writeVarInt(e.data.byteLength,e.size),this.writer.write(e.data);else if(e.data instanceof di)this.writeVarInt(4),this.writeFloat32(e.data.value);else if(e.data instanceof li)this.writeVarInt(8),this.writeFloat64(e.data.value);else if(e.data instanceof hi){const t=e.size??bi(e.data.value);this.writeVarInt(t),this.writeSignedInt(e.data.value,t)}else if(e.data instanceof mi){const t=d.encode(e.data.value);this.writeVarInt(t.length),this.writer.write(t)}else I(e.data)}}const Ti=16,Si=e=>{const t=Lr(e);if(e.skip(-1),0===t)return null;let r=1,i=128;for(;!(t&i);)r++,i>>=1;return r},vi=e=>{const t=Lr(e);if(0===t)return null;let r=1,i=128;for(;!(t&i);)r++,i>>=1;let s=t&i-1;for(let t=1;t<r;t++)s*=256,s+=Lr(e);return s},Ci=(e,t)=>{if(t<1||t>8)throw new Error("Bad unsigned int size "+t);let r=0;for(let i=0;i<t;i++)r*=256,r+=Lr(e);return r},xi=e=>{const t=Si(e);if(null===t)return null;return Ci(e,t)},Pi=e=>{let t=Lr(e);return 255===t?t=null:(e.skip(-1),t=vi(e),72057594037927940===t&&(t=null)),t},_i=e=>{const t=xi(e);if(null===t)return null;return{id:t,size:Pi(e)}},Ei=(e,t)=>{const r=Ur(e,t);let i=0;for(;i<t&&0!==r[i];)i+=1;return String.fromCharCode(...r.subarray(0,i))},Ii=(e,t)=>{if(0===t)return 0;if(4!==t&&8!==t)throw new Error("Bad float size "+t);return 4===t?(e=>{const t=e.view.getFloat32(e.bufferPos,!1);return e.bufferPos+=4,t})(e):Zr(e)},Bi=async(e,t,r,i)=>{const s=new Set(r);let a=t;for(;a<i;){let t=e.requestSliceRange(a,2,Ti);if(t instanceof Promise&&(t=await t),!t)break;const r=_i(t);if(!r)break;if(s.has(r.id))return a;Fi(r.size),a=t.filePos+r.size}return null},Mi=async(e,t,r,i)=>{const s=new Set(r);let a=t;for(;a<i;){let t=e.requestSliceRange(a,0,Math.min(65536,i-a));if(t instanceof Promise&&(t=await t),!t)break;if(t.length<8)break;for(let e=0;e<t.length-8;e++){t.filePos=a;const e=xi(t);if(null!==e&&s.has(e))return a;a++}}return null},zi={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC","pcm-u8":"A_PCM/INT/LIT","pcm-s16":"A_PCM/INT/LIT","pcm-s16be":"A_PCM/INT/BIG","pcm-s24":"A_PCM/INT/LIT","pcm-s24be":"A_PCM/INT/BIG","pcm-s32":"A_PCM/INT/LIT","pcm-s32be":"A_PCM/INT/BIG","pcm-f32":"A_PCM/FLOAT/IEEE","pcm-f64":"A_PCM/FLOAT/IEEE",webvtt:"S_TEXT/WEBVTT"};function Fi(e){if(null===e)throw new Error("Undefined element size is used in a place where it is not supported.")}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ai=e=>{let t=(e.hasVideo?"video/":e.hasAudio?"audio/":"application/")+(e.isWebM?"webm":"x-matroska");if(e.codecStrings.length>0){t+=`; codecs="${[...new Set(e.codecStrings.filter(Boolean))].join(", ")}"`}return t},Di="https://github.com/Vanilagy/mediabunny",Ri={video:1,audio:2,subtitle:17};class Oi extends Me{constructor(e,t){super(e),this.trackDatas=[],this.allTracksKnown=P(),this.segment=null,this.segmentInfo=null,this.seekHead=null,this.tracksElement=null,this.segmentDuration=null,this.cues=null,this.currentCluster=null,this.currentClusterStartMsTimestamp=null,this.currentClusterMaxMsTimestamp=null,this.trackDatasInCurrentCluster=new Map,this.duration=0,this.writer=e._writer,this.format=t,this.ebmlWriter=new yi(this.writer),this.format._options.appendOnly&&(this.writer.ensureMonotonicity=!0)}async start(){const e=await this.mutex.acquire();this.writeEBMLHeader(),this.format._options.appendOnly||this.createSeekHead(),this.createSegmentInfo(),this.createCues(),await this.writer.flush(),e()}writeEBMLHeader(){this.format._options.onEbmlHeader&&this.writer.startTrackingWrites();const e={id:fi.EBML,data:[{id:fi.EBMLVersion,data:1},{id:fi.EBMLReadVersion,data:1},{id:fi.EBMLMaxIDLength,data:4},{id:fi.EBMLMaxSizeLength,data:8},{id:fi.DocType,data:this.format instanceof ea?"webm":"matroska"},{id:fi.DocTypeVersion,data:2},{id:fi.DocTypeReadVersion,data:2}]};if(this.ebmlWriter.writeEBML(e),this.format._options.onEbmlHeader){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onEbmlHeader(e,t)}}createSeekHead(){const e=new Uint8Array([28,83,187,107]),t=new Uint8Array([21,73,169,102]),r=new Uint8Array([22,84,174,107]),i={id:fi.SeekHead,data:[{id:fi.Seek,data:[{id:fi.SeekID,data:e},{id:fi.SeekPosition,size:5,data:0}]},{id:fi.Seek,data:[{id:fi.SeekID,data:t},{id:fi.SeekPosition,size:5,data:0}]},{id:fi.Seek,data:[{id:fi.SeekID,data:r},{id:fi.SeekPosition,size:5,data:0}]}]};this.seekHead=i}createSegmentInfo(){const e={id:fi.Duration,data:new li(0)};this.segmentDuration=e;const t={id:fi.Info,data:[{id:fi.TimestampScale,data:1e6},{id:fi.MuxingApp,data:Di},{id:fi.WritingApp,data:Di},this.format._options.appendOnly?null:e]};this.segmentInfo=t}createTracks(){const t={id:fi.Tracks,data:[]};this.tracksElement=t;for(const r of this.trackDatas){const i=zi[r.track.source._codec];e(i);let s=0;if("audio"===r.type&&"opus"===r.track.source._codec){s=8e7;const e=r.info.decoderConfig.description;if(e){const t=o(e),r=it(t);s=Math.round(r.preSkip/he*1e9)}}t.data.push({id:fi.TrackEntry,data:[{id:fi.TrackNumber,data:r.track.id},{id:fi.TrackUID,data:r.track.id},{id:fi.TrackType,data:Ri[r.type]},{id:fi.FlagLacing,data:0},{id:fi.Language,data:r.track.metadata.languageCode??A},{id:fi.CodecID,data:i},{id:fi.CodecDelay,data:0},{id:fi.SeekPreRoll,data:s},void 0!==r.track.metadata.name?{id:fi.Name,data:new mi(r.track.metadata.name)}:null,"video"===r.type?this.videoSpecificTrackInfo(r):null,"audio"===r.type?this.audioSpecificTrackInfo(r):null,"subtitle"===r.type?this.subtitleSpecificTrackInfo(r):null]})}}videoSpecificTrackInfo(e){const{frameRate:r,rotation:i}=e.track.metadata,s=[e.info.decoderConfig.description?{id:fi.CodecPrivate,data:o(e.info.decoderConfig.description)}:null,r?{id:fi.DefaultDuration,data:1e9/r}:null],a=i?t(-i):0,n=e.info.decoderConfig.colorSpace,c={id:fi.Video,data:[{id:fi.PixelWidth,data:e.info.width},{id:fi.PixelHeight,data:e.info.height},k(n)?{id:fi.Colour,data:[{id:fi.MatrixCoefficients,data:g[n.matrix]},{id:fi.TransferCharacteristics,data:f[n.transfer]},{id:fi.Primaries,data:h[n.primaries]},{id:fi.Range,data:n.fullRange?2:1}]}:null,a?{id:fi.Projection,data:[{id:fi.ProjectionType,data:0},{id:fi.ProjectionPoseRoll,data:new di((a+180)%360-180)}]}:null]};return s.push(c),s}audioSpecificTrackInfo(e){const t=K.includes(e.track.source._codec)?fe(e.track.source._codec):null;return[e.info.decoderConfig.description?{id:fi.CodecPrivate,data:o(e.info.decoderConfig.description)}:null,{id:fi.Audio,data:[{id:fi.SamplingFrequency,data:new di(e.info.sampleRate)},{id:fi.Channels,data:e.info.numberOfChannels},t?{id:fi.BitDepth,data:8*t.sampleSize}:null]}]}subtitleSpecificTrackInfo(e){return[{id:fi.CodecPrivate,data:d.encode(e.info.config.description)}]}createSegment(){const e={id:fi.Segment,size:this.format._options.appendOnly?-1:6,data:[this.format._options.appendOnly?null:this.seekHead,this.segmentInfo,this.tracksElement]};if(this.segment=e,this.format._options.onSegmentHeader&&this.writer.startTrackingWrites(),this.ebmlWriter.writeEBML(e),this.format._options.onSegmentHeader){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onSegmentHeader(e,t)}}createCues(){this.cues={id:fi.Cues,data:[]}}get segmentDataOffset(){return e(this.segment),this.ebmlWriter.dataOffsets.get(this.segment)}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some((t=>t.track===e)))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map((e=>{if("video"===e.type)return e.info.decoderConfig.codec;if("audio"===e.type)return e.info.decoderConfig.codec;return{webvtt:"wvtt"}[e.track.source._codec]}));return Ai({isWebM:this.format instanceof ea,hasVideo:this.trackDatas.some((e=>"video"===e.type)),hasAudio:this.trackDatas.some((e=>"audio"===e.type)),codecStrings:e})}getVideoTrackData(t,r){const i=this.trackDatas.find((e=>e.track===t));if(i)return i;_e(r),e(r),e(r.decoderConfig),e(void 0!==r.decoderConfig.codedWidth),e(void 0!==r.decoderConfig.codedHeight);const s={track:t,type:"video",info:{width:r.decoderConfig.codedWidth,height:r.decoderConfig.codedHeight,decoderConfig:r.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return"vp9"===t.source._codec?s.info.decoderConfig={...s.info.decoderConfig,description:new Uint8Array(se(s.info.decoderConfig.codec))}:"av1"===t.source._codec&&(s.info.decoderConfig={...s.info.decoderConfig,description:new Uint8Array(ae(s.info.decoderConfig.codec))}),this.trackDatas.push(s),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}getAudioTrackData(t,r){const i=this.trackDatas.find((e=>e.track===t));if(i)return i;Ie(r),e(r),e(r.decoderConfig);const s={track:t,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:r.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}getSubtitleTrackData(t,r){const i=this.trackDatas.find((e=>e.track===t));if(i)return i;Be(r),e(r),e(r.config);const s={track:t,type:"subtitle",info:{config:r.config},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort(((e,t)=>e.track.id-t.track.id)),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,t,r){const i=await this.mutex.acquire();try{const i=this.getVideoTrackData(e,r),s="key"===t.type;let a=this.validateAndNormalizeTimestamp(i.track,t.timestamp,s),n=t.duration;void 0!==e.metadata.frameRate&&(a=R(a,1/e.metadata.frameRate),n=R(n,1/e.metadata.frameRate));const o=this.createInternalChunk(t.data,a,n,t.type);"vp9"===e.source._codec&&this.fixVP9ColorSpace(i,o),i.chunkQueue.push(o),await this.interleaveChunks()}finally{i()}}async addEncodedAudioPacket(e,t,r){const i=await this.mutex.acquire();try{const i=this.getAudioTrackData(e,r),s="key"===t.type,a=this.validateAndNormalizeTimestamp(i.track,t.timestamp,s),n=this.createInternalChunk(t.data,a,t.duration,t.type);i.chunkQueue.push(n),await this.interleaveChunks()}finally{i()}}async addSubtitleCue(e,t,r){const i=await this.mutex.acquire();try{const i=this.getSubtitleTrackData(e,r),s=this.validateAndNormalizeTimestamp(i.track,t.timestamp,!0);let a=t.text;const n=Math.round(1e3*s);De.lastIndex=0,a=a.replace(De,(e=>{const t=We(e.slice(1,-1));return`<${Ve(t-n)}>`}));const o=d.encode(a),c=`${t.settings??""}\n${t.identifier??""}\n${t.notes??""}`,u=this.createInternalChunk(o,s,t.duration,"key",c.trim()?d.encode(c):null);i.chunkQueue.push(u),await this.interleaveChunks()}finally{i()}}async interleaveChunks(e=!1){if(e||this.allTracksAreKnown()){e:for(;;){let t=null,r=1/0;for(const i of this.trackDatas){if(!e&&0===i.chunkQueue.length&&!i.track.source._closed)break e;i.chunkQueue.length>0&&i.chunkQueue[0].timestamp<r&&(t=i,r=i.chunkQueue[0].timestamp)}if(!t)break;const i=t.chunkQueue.shift();this.writeBlock(t,i)}e||await this.writer.flush()}}fixVP9ColorSpace(e,t){if("key"!==t.type)return;if(!e.info.decoderConfig.colorSpace||!e.info.decoderConfig.colorSpace.matrix)return;const r=new s(t.data);r.skipBits(2);const i=r.readBits(1),a=(r.readBits(1)<<1)+i;3===a&&r.skipBits(1);if(r.readBits(1))return;if(0!==r.readBits(1))return;r.skipBits(2);if(4817730!==r.readBits(24))return;a>=2&&r.skipBits(1);const n={rgb:7,bt709:2,bt470bg:1,smpte170m:3}[e.info.decoderConfig.colorSpace.matrix];((e,t,r,i)=>{for(let s=t;s<r;s++){const t=Math.floor(s/8);let a=e[t];const n=7-(7&s);a&=~(1<<n),a|=(i&1<<r-s-1)>>r-s-1<<n,e[t]=a}})(t.data,r.pos,r.pos+3,n)}createInternalChunk(e,t,r,i,s=null){return{data:e,type:i,timestamp:t,duration:r,additions:s}}writeBlock(t,r){this.segment||(this.createTracks(),this.createSegment());const i=Math.round(1e3*r.timestamp),s=this.trackDatas.every((e=>{if(t===e)return"key"===r.type;const i=e.chunkQueue[0];return i?"key"===i.type:e.track.source._closed}));let a=!1;if(this.currentCluster){e(null!==this.currentClusterStartMsTimestamp),e(null!==this.currentClusterMaxMsTimestamp);const t=i-this.currentClusterStartMsTimestamp;a=s&&i>this.currentClusterMaxMsTimestamp&&t>=1e3*(this.format._options.minimumClusterDuration??1)||t>32767}else a=!0;a&&this.createNewCluster(i);const n=i-this.currentClusterStartMsTimestamp;if(n<-32768)return;const o=new Uint8Array(4),c=new DataView(o.buffer);c.setUint8(0,128|t.track.id),c.setInt16(1,n,!1);const u=Math.round(1e3*r.duration);if(r.additions){const e={id:fi.BlockGroup,data:[{id:fi.Block,data:[o,r.data]},"delta"===r.type?{id:fi.ReferenceBlock,data:new hi(t.lastWrittenMsTimestamp-i)}:null,r.additions?{id:fi.BlockAdditions,data:[{id:fi.BlockMore,data:[{id:fi.BlockAdditional,data:r.additions},{id:fi.BlockAddID,data:1}]}]}:null,u>0?{id:fi.BlockDuration,data:u}:null]};this.ebmlWriter.writeEBML(e)}else{c.setUint8(3,Number("key"===r.type)<<7);const e={id:fi.SimpleBlock,data:[o,r.data]};this.ebmlWriter.writeEBML(e)}this.duration=Math.max(this.duration,i+u),t.lastWrittenMsTimestamp=i,this.trackDatasInCurrentCluster.has(t)||this.trackDatasInCurrentCluster.set(t,{firstMsTimestamp:i}),this.currentClusterMaxMsTimestamp=Math.max(this.currentClusterMaxMsTimestamp,i)}createNewCluster(e){this.currentCluster&&this.finalizeCurrentCluster(),this.format._options.onCluster&&this.writer.startTrackingWrites(),this.currentCluster={id:fi.Cluster,size:this.format._options.appendOnly?-1:5,data:[{id:fi.Timestamp,data:e}]},this.ebmlWriter.writeEBML(this.currentCluster),this.currentClusterStartMsTimestamp=e,this.currentClusterMaxMsTimestamp=e,this.trackDatasInCurrentCluster.clear()}finalizeCurrentCluster(){if(e(this.currentCluster),!this.format._options.appendOnly){const e=this.writer.getPos()-this.ebmlWriter.dataOffsets.get(this.currentCluster),t=this.writer.getPos();this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster)+4),this.ebmlWriter.writeVarInt(e,5),this.writer.seek(t)}if(this.format._options.onCluster){e(null!==this.currentClusterStartMsTimestamp);const{data:t,start:r}=this.writer.stopTrackingWrites();this.format._options.onCluster(t,r,this.currentClusterStartMsTimestamp/1e3)}const t=this.ebmlWriter.offsets.get(this.currentCluster)-this.segmentDataOffset,r=new Map;for(const[e,{firstMsTimestamp:t}]of this.trackDatasInCurrentCluster)r.has(t)||r.set(t,[]),r.get(t).push(e);const i=[...r.entries()].sort(((e,t)=>e[0]-t[0]));for(const[r,s]of i)e(this.cues),this.cues.data.push({id:fi.CuePoint,data:[{id:fi.CueTime,data:r},...s.map((e=>({id:fi.CueTrackPositions,data:[{id:fi.CueTrack,data:e.track.id},{id:fi.CueClusterPosition,data:t}]})))]})}async onTrackClose(){const e=await this.mutex.acquire();this.allTracksAreKnown()&&this.allTracksKnown.resolve(),await this.interleaveChunks(),e()}async finalize(){const t=await this.mutex.acquire();if(this.allTracksKnown.resolve(),this.segment||(this.createTracks(),this.createSegment()),await this.interleaveChunks(!0),this.currentCluster&&this.finalizeCurrentCluster(),e(this.cues),this.ebmlWriter.writeEBML(this.cues),!this.format._options.appendOnly){const e=this.writer.getPos(),t=this.writer.getPos()-this.segmentDataOffset;this.writer.seek(this.ebmlWriter.offsets.get(this.segment)+4),this.ebmlWriter.writeVarInt(t,6),this.segmentDuration.data=new li(this.duration),this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration)),this.ebmlWriter.writeEBML(this.segmentDuration),this.seekHead.data[0].data[1].data=this.ebmlWriter.offsets.get(this.cues)-this.segmentDataOffset,this.seekHead.data[1].data[1].data=this.ebmlWriter.offsets.get(this.segmentInfo)-this.segmentDataOffset,this.seekHead.data[2].data[1].data=this.ebmlWriter.offsets.get(this.tracksElement)-this.segmentDataOffset,this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead)),this.ebmlWriter.writeEBML(this.seekHead),this.writer.seek(e)}t()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Wi={1:[-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1],2:[-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1],3:[-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1]},Vi={1:[-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],2:[-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1],3:[-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1]},Ui={0:[11025,12e3,8e3,-1],2:[22050,24e3,16e3,-1],3:[44100,48e3,32e3,-1]},Li=1483304551,Ni=1231971951,Hi=(e,t,r,i)=>3===e?Math.floor(4*(12*t/r+i)):Math.floor(144*t/r+i),qi=(e,t)=>3===e?3===t?21:36:3===t?13:21,$i=(e,t)=>{const r=e>>>24,i=e>>>16&255,s=e>>>8&255,a=255&e;if(255!==r&&255!==i&&255!==s&&255!==a)return{header:null,bytesAdvanced:4};if(255!==r)return{header:null,bytesAdvanced:1};if(224&~i)return{header:null,bytesAdvanced:1};const n=i>>3&3,o=i>>1&3,c=s>>4&15,u=s>>2&3,d=s>>1&1,l=a>>6&3,h=a>>4&3,m=a>>3&1,f=a>>2&1,p=3&a,g=3===n?Wi[o]?.[c]:Vi[o]?.[c];if(!g||-1===g)return{header:null,bytesAdvanced:1};const w=1e3*g,k=Ui[n]?.[u];if(!k||-1===k)return{header:null,bytesAdvanced:1};const b=Hi(o,w,k,d);if(null!==t&&t<b)return{header:null,bytesAdvanced:1};let y;return y=3===n?3===o?384:1152:3===o?384:2===o?1152:576,{header:{totalSize:b,mpegVersionId:n,layer:o,bitrate:w,frequencyIndex:u,sampleRate:k,channel:l,modeExtension:h,copyright:m,original:f,emphasis:p,audioSamplesInFrame:y},bytesAdvanced:1}};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class ji{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer)}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeXingFrame(e){const t=this.writer.getPos(),r=224|e.mpegVersionId<<3|e.layer<<1,i=3===e.mpegVersionId?Wi:Vi,s=i?.[e.layer];if(!s)throw new Error("Invalid MPEG version and layer combination.");const a=Ui[e.mpegVersionId]?.[e.frequencyIndex];if(!a||-1===a)throw new Error("Invalid MPEG version and frequency index combination.");const n=s.findIndex((t=>Hi(e.layer,1e3*t,a,0)>=155));if(-1===n)throw new Error("No suitable bitrate found.");const o=n<<4|e.frequencyIndex<<2,c=e.channel<<6|e.modeExtension<<4|e.copyright<<3|e.original<<2|e.emphasis;this.helper[0]=255,this.helper[1]=r,this.helper[2]=o,this.helper[3]=c,this.writer.write(this.helper.subarray(0,4));const u=qi(e.mpegVersionId,e.channel);this.writer.seek(t+u),this.writeU32(Li);let d=0;null!==e.frameCount&&(d|=1),null!==e.fileSize&&(d|=2),null!==e.toc&&(d|=4),this.writeU32(d),this.writeU32(e.frameCount??0),this.writeU32(e.fileSize??0),this.writer.write(e.toc??new Uint8Array(100));const l=Hi(e.layer,1e3*s[n],a,0);this.writer.seek(t+l)}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ki extends Me{constructor(e,t){super(e),this.xingFrameData=null,this.frameCount=0,this.framePositions=[],this.format=t,this.writer=e._writer,this.mp3Writer=new ji(e._writer)}async start(){}async getMimeType(){return"audio/mpeg"}async addEncodedVideoPacket(){throw new Error("MP3 does not support video.")}async addEncodedAudioPacket(e,t){const r=await this.mutex.acquire();try{const r=!1!==this.format._options.xingHeader;if(!this.xingFrameData&&r){const e=c(t.data);if(e.byteLength<4)throw new Error("Invalid MP3 header in sample.");const r=e.getUint32(0,!1),i=$i(r,null).header;if(!i)throw new Error("Invalid MP3 header in sample.");const s=qi(i.mpegVersionId,i.channel);if(e.byteLength>=s+4){const t=e.getUint32(s,!1);if(t===Li||t===Ni)return}this.xingFrameData={mpegVersionId:i.mpegVersionId,layer:i.layer,frequencyIndex:i.frequencyIndex,channel:i.channel,modeExtension:i.modeExtension,copyright:i.copyright,original:i.original,emphasis:i.emphasis,frameCount:null,fileSize:null,toc:null},this.mp3Writer.writeXingFrame(this.xingFrameData),this.frameCount++}this.validateAndNormalizeTimestamp(e,t.timestamp,"key"===t.type),this.writer.write(t.data),this.frameCount++,await this.writer.flush(),r&&this.framePositions.push(this.writer.getPos())}finally{r()}}async addSubtitleCue(){throw new Error("MP3 does not support subtitles.")}async finalize(){if(!this.xingFrameData)return;const t=await this.mutex.acquire(),r=this.writer.getPos();this.writer.seek(0);const i=new Uint8Array(100);for(let t=0;t<100;t++){const s=Math.floor(this.framePositions.length*(t/100));e(-1!==s&&s<this.framePositions.length);const a=this.framePositions[s];i[t]=a/r*256}if(this.xingFrameData.frameCount=this.frameCount,this.xingFrameData.fileSize=r,this.xingFrameData.toc=i,this.format._options.onXingFrame&&this.writer.startTrackingWrites(),this.mp3Writer.writeXingFrame(this.xingFrameData),this.format._options.onXingFrame){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onXingFrame(e,t)}this.writer.seek(r),t()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Qi=1399285583,Yi=new Uint32Array(256);for(let e=0;e<256;e++){let t=e<<24;for(let e=0;e<8;e++)t=2147483648&t?t<<1^79764919:t<<1;Yi[e]=t>>>0&4294967295}const Gi=e=>{const t=c(e),r=t.getUint32(22,!0);t.setUint32(22,0,!0);let i=0;for(let t=0;t<e.length;t++){const r=e[t];i=(i<<8^Yi[i>>>24^r])>>>0}return t.setUint32(22,r,!0),i},Xi=(t,r,i)=>{let s=0,a=null;if(t.length>0)if("vorbis"===r.codec){e(r.vorbisInfo);const n=(1<<(e=>{let t=0;for(;e;)t++,e>>=1;return t})(r.vorbisInfo.modeBlockflags.length-1))-1<<1,o=(t[0]&n)>>1;if(o>=r.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let c=i;const u=r.vorbisInfo.modeBlockflags[o];if(a=r.vorbisInfo.blocksizes[u],1===u){const e=1+(1|n),i=t[0]&e?1:0;c=r.vorbisInfo.blocksizes[i]}s=null!==c?c+a>>2:0}else if("opus"===r.codec){s=(e=>{const t=e[0]>>3;return{durationInSamples:st[t]}})(t).durationInSamples}return{durationInSamples:s,vorbisBlockSize:a}},Ji=e=>{let t="audio/ogg";if(e.codecStrings){t+=`; codecs="${[...new Set(e.codecStrings)].join(", ")}"`}return t},Zi=27,es=282,ts=e=>{const t=e.filePos;if(Qr(e)!==Qi)return null;e.skip(1);const r=Lr(e),i=(e=>{const t=Qr(e),r=(e=>{const t=e.view.getInt32(e.bufferPos,!0);return e.bufferPos+=4,t})(e);return 4294967296*r+t})(e),s=Qr(e),a=Qr(e),n=Qr(e),o=Lr(e),c=new Uint8Array(o);for(let t=0;t<o;t++)c[t]=Lr(e);const u=27+o,d=c.reduce(((e,t)=>e+t),0);return{headerStartPos:t,totalSize:u+d,dataStartPos:t+u,dataSize:d,headerType:r,granulePosition:i,serialNumber:s,sequenceNumber:a,checksum:n,lacingValues:c}},rs=(e,t)=>{for(;e.filePos<t-3;){const t=Qr(e),r=79;if((255&t)===r||(t>>>8&255)===r||(t>>>16&255)===r||(t>>>24&255)===r){if(e.skip(-4),t===Qi)return!0;e.skip(1)}}return!1};class is extends Me{constructor(e,t){super(e),this.trackDatas=[],this.bosPagesWritten=!1,this.allTracksKnown=P(),this.pageBytes=new Uint8Array(65307),this.pageView=new DataView(this.pageBytes.buffer),this.format=t,this.writer=e._writer,this.writer.ensureMonotonicity=!0}async start(){}async getMimeType(){return await this.allTracksKnown.promise,Ji({codecStrings:this.trackDatas.map((e=>e.codecInfo.codec))})}addEncodedVideoPacket(){throw new Error("Video tracks are not supported.")}getTrackData(t,r){const i=this.trackDatas.find((e=>e.track===t));if(i)return i;let s;do{s=Math.floor(2**32*Math.random())}while(this.trackDatas.some((e=>e.serialNumber===s)));e("vorbis"===t.source._codec||"opus"===t.source._codec),Ie(r),e(r),e(r.decoderConfig);const a={track:t,serialNumber:s,internalSampleRate:"opus"===t.source._codec?he:r.decoderConfig.sampleRate,codecInfo:{codec:t.source._codec,vorbisInfo:null,opusInfo:null},vorbisLastBlocksize:null,packetQueue:[],currentTimestampInSamples:0,pagesWritten:0,currentGranulePosition:0,currentLacingValues:[],currentPageData:[],currentPageSize:27,currentPageStartsWithFreshPacket:!0};return this.queueHeaderPackets(a,r),this.trackDatas.push(a),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),a}queueHeaderPackets(t,r){if(e(r.decoderConfig),"vorbis"===t.track.source._codec){e(r.decoderConfig.description);const i=o(r.decoderConfig.description);if(2!==i[0])throw new TypeError("First byte of Vorbis decoder description must be 2.");let s=1;const a=()=>{let e=0;for(;;){const t=i[s++];if(void 0===t)throw new TypeError("Vorbis decoder description is too short.");if(e+=t,t<255)return e}},n=a(),u=a();if(i.length-s<=0)throw new TypeError("Vorbis decoder description is too short.");const d=i.subarray(s,s+=n),l=i.subarray(s,s+=u),h=i.subarray(s);t.packetQueue.push({data:d,endGranulePosition:0,timestamp:0,forcePageFlush:!0},{data:l,endGranulePosition:0,timestamp:0,forcePageFlush:!1},{data:h,endGranulePosition:0,timestamp:0,forcePageFlush:!0});const m=c(d).getUint8(28);t.codecInfo.vorbisInfo={blocksizes:[1<<(15&m),1<<(m>>4)],modeBlockflags:at(h).modeBlockflags}}else if("opus"===t.track.source._codec){if(!r.decoderConfig.description)throw new TypeError("For Ogg, Opus decoder description is required.");const e=o(r.decoderConfig.description),i=new Uint8Array(16),s=new DataView(i.buffer);s.setUint32(0,1332770163,!1),s.setUint32(4,1415669619,!1),s.setUint32(8,0,!0),s.setUint32(12,0,!0),t.packetQueue.push({data:e,endGranulePosition:0,timestamp:0,forcePageFlush:!0},{data:i,endGranulePosition:0,timestamp:0,forcePageFlush:!0}),t.codecInfo.opusInfo={preSkip:it(e).preSkip}}}async addEncodedAudioPacket(e,t,r){const i=await this.mutex.acquire();try{const i=this.getTrackData(e,r);this.validateAndNormalizeTimestamp(i.track,t.timestamp,"key"===t.type);const s=i.currentTimestampInSamples,{durationInSamples:a,vorbisBlockSize:n}=Xi(t.data,i.codecInfo,i.vorbisLastBlocksize);i.currentTimestampInSamples+=a,i.vorbisLastBlocksize=n,i.packetQueue.push({data:t.data,endGranulePosition:i.currentTimestampInSamples,timestamp:s/i.internalSampleRate,forcePageFlush:!1}),await this.interleavePages()}finally{i()}}addSubtitleCue(){throw new Error("Subtitle tracks are not supported.")}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some((t=>t.track===e)))return!1;return!0}async interleavePages(e=!1){if(!this.bosPagesWritten){if(!this.allTracksAreKnown())return;for(const e of this.trackDatas)for(;e.packetQueue.length>0;){const t=e.packetQueue.shift();if(this.writePacket(e,t,!1),t.forcePageFlush)break}this.bosPagesWritten=!0}e:for(;;){let t=null,r=1/0;for(const i of this.trackDatas){if(!e&&i.packetQueue.length<=1&&!i.track.source._closed)break e;i.packetQueue.length>0&&i.packetQueue[0].timestamp<r&&(t=i,r=i.packetQueue[0].timestamp)}if(!t)break;const i=t.packetQueue.shift(),s=0===t.packetQueue.length;this.writePacket(t,i,s)}e||await this.writer.flush()}writePacket(e,t,r){let i=t.data.length,s=0,a=0;for(;;){0===e.currentLacingValues.length&&s>0&&(e.currentPageStartsWithFreshPacket=!1);const n=Math.min(255,i);e.currentLacingValues.push(n),e.currentPageSize++,a+=n;const o=i<255;if(255===e.currentLacingValues.length){const i=t.data.subarray(s,a);if(s=a,e.currentPageData.push(i),e.currentPageSize+=i.length,this.writePage(e,r&&o),o)return}if(o)break;i-=255}const n=t.data.subarray(s);e.currentPageData.push(n),e.currentPageSize+=n.length,e.currentGranulePosition=t.endGranulePosition,(e.currentPageSize>=8192||t.forcePageFlush)&&this.writePage(e,r)}writePage(e,t){this.pageView.setUint32(0,Qi,!0),this.pageView.setUint8(4,0);let r=0;e.currentPageStartsWithFreshPacket||(r|=1),0===e.pagesWritten&&(r|=2),t&&(r|=4),this.pageView.setUint8(5,r);const i=e.currentLacingValues.every((e=>255===e))?-1:e.currentGranulePosition;((e,t,r,i)=>{i?(e.setUint32(t+0,r,!0),e.setInt32(t+4,Math.floor(r/2**32),!0)):(e.setInt32(t+0,Math.floor(r/2**32),!0),e.setUint32(t+4,r,!0))})(this.pageView,6,i,!0),this.pageView.setUint32(14,e.serialNumber,!0),this.pageView.setUint32(18,e.pagesWritten,!0),this.pageView.setUint32(22,0,!0),this.pageView.setUint8(26,e.currentLacingValues.length),this.pageBytes.set(e.currentLacingValues,27);let s=27+e.currentLacingValues.length;for(const t of e.currentPageData)this.pageBytes.set(t,s),s+=t.length;const a=this.pageBytes.subarray(0,s),n=Gi(a);if(this.pageView.setUint32(22,n,!0),e.pagesWritten++,e.currentLacingValues.length=0,e.currentPageData.length=0,e.currentPageSize=27,e.currentPageStartsWithFreshPacket=!0,this.format._options.onPage&&this.writer.startTrackingWrites(),this.writer.write(a),this.format._options.onPage){const{data:t,start:r}=this.writer.stopTrackingWrites();this.format._options.onPage(t,r,e.track.source)}}async onTrackClose(){const e=await this.mutex.acquire();this.allTracksAreKnown()&&this.allTracksKnown.resolve(),await this.interleavePages(),e()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve(),await this.interleavePages(!0);for(const e of this.trackDatas)e.currentLacingValues.length>0&&this.writePage(e,!0);e()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class ss{constructor(e){this.input=e}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class as{static supports(e,t){return!1}}class ns{static supports(e,t){return!1}}class os{static supports(e,t){return!1}}class cs{static supports(e,t){return!1}}const us=[],ds=[],ls=[],hs=[],ms=e=>{if(e.prototype instanceof as){const t=e;if(us.includes(t))return void console.warn("Video decoder already registered.");us.push(t)}else{if(!(e.prototype instanceof ns))throw new TypeError("Decoder must be a CustomVideoDecoder or CustomAudioDecoder.");{const t=e;if(ds.includes(t))return void console.warn("Audio decoder already registered.");ds.push(t)}}},fs=e=>{if(e.prototype instanceof os){const t=e;if(ls.includes(t))return void console.warn("Video encoder already registered.");ls.push(t)}else{if(!(e.prototype instanceof cs))throw new TypeError("Encoder must be a CustomVideoEncoder or CustomAudioEncoder.");{const t=e;if(hs.includes(t))return void console.warn("Audio encoder already registered.");hs.push(t)}}},ps=new Uint8Array(0);class gs{constructor(e,t,r,i,s=-1,a){if(this.data=e,this.type=t,this.timestamp=r,this.duration=i,this.sequenceNumber=s,e===ps&&void 0===a)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(void 0===a&&(a=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if("key"!==t&&"delta"!==t)throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(r))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(i)||i<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(s))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(a)||a<0)throw new TypeError("byteLength must be a non-negative integer.");this.byteLength=a}get isMetadataOnly(){return this.data===ps}get microsecondTimestamp(){return Math.trunc(V*this.timestamp)}get microsecondDuration(){return Math.trunc(V*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if("undefined"==typeof EncodedVideoChunk)throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if("undefined"==typeof EncodedAudioChunk)throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const t=new Uint8Array(e.byteLength);return e.copyTo(t),new gs(t,e.type,e.timestamp/1e6,(e.duration??0)/1e6)}clone(e){if(void 0!==e&&("object"!=typeof e||null===e))throw new TypeError("options, when provided, must be an object.");if(void 0!==e?.timestamp&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if(void 0!==e?.duration&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");return new gs(this.data,this.type,e?.timestamp??this.timestamp,e?.duration??this.duration,this.sequenceNumber,this.byteLength)}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class ws{get displayWidth(){return this.rotation%180==0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180==0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(V*this.timestamp)}get microsecondDuration(){return Math.trunc(V*this.duration)}constructor(t,r){if(this._closed=!1,t instanceof ArrayBuffer||ArrayBuffer.isView(t)){if(!r||"object"!=typeof r)throw new TypeError("init must be an object.");if(!("format"in r)||"string"!=typeof r.format)throw new TypeError("init.format must be a string.");if(!Number.isInteger(r.codedWidth)||r.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(r.codedHeight)||r.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(void 0!==r.rotation&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(void 0!==r.duration&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=o(t).slice(),this.format=r.format,this.codedWidth=r.codedWidth,this.codedHeight=r.codedHeight,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace(r.colorSpace)}else if("undefined"!=typeof VideoFrame&&t instanceof VideoFrame){if(void 0!==r?.rotation&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(void 0!==r?.timestamp&&!Number.isFinite(r?.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if(void 0!==r?.duration&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=t,this.format=t.format,this.codedWidth=t.displayWidth,this.codedHeight=t.displayHeight,this.rotation=r?.rotation??0,this.timestamp=r?.timestamp??t.timestamp/1e6,this.duration=r?.duration??(t.duration??0)/1e6,this.colorSpace=t.colorSpace}else{if(!("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof SVGImageElement&&t instanceof SVGImageElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas))throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.");{if(!r||"object"!=typeof r)throw new TypeError("init must be an object.");if(void 0!==r.rotation&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(void 0!==r.duration&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if("undefined"!=typeof VideoFrame)return new ws(new VideoFrame(t,{timestamp:Math.trunc(r.timestamp*V),duration:Math.trunc((r.duration??0)*V)}),r);let i=0,s=0;if("naturalWidth"in t?(i=t.naturalWidth,s=t.naturalHeight):"videoWidth"in t?(i=t.videoWidth,s=t.videoHeight):"width"in t&&(i=Number(t.width),s=Number(t.height)),!i||!s)throw new TypeError("Could not determine dimensions.");const a=new OffscreenCanvas(i,s),n=a.getContext("2d",{alpha:!1,willReadFrequently:!0});e(n),n.drawImage(t,0,0),this._data=a,this.format="RGBX",this.codedWidth=i,this.codedHeight=s,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}}}clone(){if(this._closed)throw new Error("VideoSample is closed.");return e(null!==this._data),ks(this._data)?new ws(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new ws(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new ws(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(ks(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return e(null!==this._data),ks(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(t){if(!b(t))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(e(null!==this._data),ks(this._data))await this._data.copyTo(t);else if(this._data instanceof Uint8Array){o(t).set(this._data)}else{const r=this._data.getContext("2d",{alpha:!1});e(r);const i=r.getImageData(0,0,this.codedWidth,this.codedHeight);o(t).set(i.data)}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return e(null!==this._data),ks(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}draw(e,t,r,i,s,a,n,o,c){let u=0,d=0,l=this.displayWidth,h=this.displayHeight,m=0,f=0,p=this.displayWidth,g=this.displayHeight;if(void 0!==a?(u=t,d=r,l=i,h=s,m=a,f=n,void 0!==o?(p=o,g=c):(p=l,g=h)):(m=t,f=r,void 0!==i&&(p=i,g=s)),!("undefined"!=typeof CanvasRenderingContext2D&&e instanceof CanvasRenderingContext2D||"undefined"!=typeof OffscreenCanvasRenderingContext2D&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(u))throw new TypeError("sx must be a number.");if(!Number.isFinite(d))throw new TypeError("sy must be a number.");if(!Number.isFinite(l)||l<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(m))throw new TypeError("dx must be a number.");if(!Number.isFinite(f))throw new TypeError("dy must be a number.");if(!Number.isFinite(p)||p<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(g)||g<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");90===this.rotation?[u,d,l,h]=[d,this.codedHeight-u-l,h,l]:180===this.rotation?[u,d]=[this.codedWidth-u-l,this.codedHeight-d-h]:270===this.rotation&&([u,d,l,h]=[this.codedWidth-d-h,u,h,l]);const w=this.toCanvasImageSource();e.save();const k=m+p/2,b=f+g/2;e.translate(k,b),e.rotate(this.rotation*Math.PI/180);const y=this.rotation%180==0?1:p/g;e.scale(1/y,y),e.drawImage(w,u,d,l,h,-p/2,-g/2,p,g),e.restore()}drawWithFit(e,t){const r=e.canvas.width,i=e.canvas.height,s=t.rotation??this.rotation;let a,n,o,c;if("fill"===t.fit)a=0,n=0,o=r,c=i;else{const[e,u]=s%180==0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth],d="contain"===t.fit?Math.min(r/e,i/u):Math.max(r/e,i/u);o=e*d,c=u*d,a=(r-o)/2,n=(i-c)/2}const u=s%180==0?1:o/c;e.translate(r/2,i/2),e.rotate(s*Math.PI/180),e.scale(1/u,u),e.translate(-r/2,-i/2),e.drawImage(this.toCanvasImageSource(),a,n,o,c)}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(e(null!==this._data),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask((()=>e.close())),e}return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}}const ks=e=>"undefined"!=typeof VideoFrame&&e instanceof VideoFrame,bs=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class ys{get microsecondTimestamp(){return Math.trunc(V*this.timestamp)}get microsecondDuration(){return Math.trunc(V*this.duration)}constructor(e){if(this._closed=!1,xs(e)){if(null===e.format)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||"object"!=typeof e)throw new TypeError("Invalid AudioDataInit: must be an object.");if(!bs.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||0===e.numberOfChannels)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e?.timestamp))throw new TypeError("init.timestamp must be a number.");const t=e.data.byteLength/(Ts(e.format)*e.numberOfChannels);if(!Number.isInteger(t))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");let r;if(this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=t,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=t/e.sampleRate,e.data instanceof ArrayBuffer)r=new Uint8Array(e.data);else{if(!ArrayBuffer.isView(e.data))throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");r=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength)}const i=this.numberOfFrames*this.numberOfChannels*Ts(this.format);if(r.byteLength<i)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=r}}allocationSize(e){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(void 0!==e.format&&!bs.has(e.format))throw new TypeError("Invalid format.");if(void 0!==e.frameOffset&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(void 0!==e.frameCount&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const t=e.format??this.format,r=e.frameOffset??0;if(r>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const i=void 0!==e.frameCount?e.frameCount:this.numberOfFrames-r;if(i>this.numberOfFrames-r)throw new RangeError("frameCount out of range");const s=Ts(t),a=Ss(t);if(a&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!a&&0!==e.planeIndex)throw new RangeError("planeIndex out of range");return(a?i:i*this.numberOfChannels)*s}copyTo(e,t){if(!b(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!t||"object"!=typeof t)throw new TypeError("options must be an object.");if(!Number.isInteger(t.planeIndex)||t.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(void 0!==t.format&&!bs.has(t.format))throw new TypeError("Invalid format.");if(void 0!==t.frameOffset&&(!Number.isInteger(t.frameOffset)||t.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(void 0!==t.frameCount&&(!Number.isInteger(t.frameCount)||t.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:r,format:i,frameCount:s,frameOffset:a}=t,n=i??this.format;if(!n)throw new Error("Destination format not determined");const o=this.numberOfFrames,u=this.numberOfChannels,d=a??0;if(d>=o)throw new RangeError("frameOffset out of range");const l=void 0!==s?s:o-d;if(l>o-d)throw new RangeError("frameCount out of range");const h=Ts(n),m=Ss(n);if(m&&r>=u)throw new RangeError("planeIndex out of range");if(!m&&0!==r)throw new RangeError("planeIndex out of range");const f=(m?l:l*u)*h;if(e.byteLength<f)throw new RangeError("Destination buffer is too small");const p=c(e),g=Cs(n);if(xs(this._data))if(m)if("f32-planar"===n)this._data.copyTo(e,{planeIndex:r,frameOffset:d,frameCount:l,format:"f32-planar"});else{const e=new ArrayBuffer(4*l),t=new Float32Array(e);this._data.copyTo(t,{planeIndex:r,frameOffset:d,frameCount:l,format:"f32-planar"});const i=new DataView(e);for(let e=0;e<l;e++){g(p,e*h,i.getFloat32(4*e,!0))}}else{const e=u,t=new Float32Array(l);for(let r=0;r<e;r++){this._data.copyTo(t,{planeIndex:r,frameOffset:d,frameCount:l,format:"f32-planar"});for(let i=0;i<l;i++){g(p,(i*e+r)*h,t[i])}}}else{const e=this._data,t=new DataView(e.buffer,e.byteOffset,e.byteLength),i=this.format,s=vs(i),a=Ts(i),n=Ss(i);for(let e=0;e<l;e++)if(m){let i;i=n?(r*o+(e+d))*a:((e+d)*u+r)*a;g(p,e*h,s(t,i))}else for(let r=0;r<u;r++){let i;i=n?(r*o+(e+d))*a:((e+d)*u+r)*a;g(p,(e*u+r)*h,s(t,i))}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(xs(this._data)){const e=new ys(this._data.clone());return e.setTimestamp(this.timestamp),e}return new ys({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(xs(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(xs(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(Ss(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),t=new ArrayBuffer(e*this.numberOfChannels);for(let r=0;r<this.numberOfChannels;r++)this.copyTo(new Uint8Array(t,r*e,e),{planeIndex:r,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:t})}{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),t=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let r=0;r<this.numberOfChannels;r++)this.copyTo(t,{planeIndex:r,format:"f32-planar"}),e.copyToChannel(t,r);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}static*_fromAudioBuffer(e,t){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const r=e.numberOfChannels,i=e.sampleRate,s=e.length,a=Math.floor(24e4/r);let n=0,o=s;for(;o>0;){const s=Math.min(a,o),c=new Float32Array(r*s);for(let t=0;t<r;t++)e.copyFromChannel(c.subarray(t*s,(t+1)*s),t,n);yield new ys({format:"f32-planar",sampleRate:i,numberOfFrames:s,numberOfChannels:r,timestamp:t+n/i,data:c}),n+=s,o-=s}}static fromAudioBuffer(e,t){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const r=e.numberOfChannels,i=e.sampleRate,s=e.length,a=Math.floor(24e4/r);let n=0,o=s;const c=[];for(;o>0;){const s=Math.min(a,o),u=new Float32Array(r*s);for(let t=0;t<r;t++)e.copyFromChannel(u.subarray(t*s,(t+1)*s),t,n);const d=new ys({format:"f32-planar",sampleRate:i,numberOfFrames:s,numberOfChannels:r,timestamp:t+n/i,data:u});c.push(d),n+=s,o-=s}return c}}const Ts=e=>{switch(e){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},Ss=e=>{switch(e){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},vs=e=>{switch(e){case"u8":case"u8-planar":return(e,t)=>(e.getUint8(t)-128)/128;case"s16":case"s16-planar":return(e,t)=>e.getInt16(t,!0)/32768;case"s32":case"s32-planar":return(e,t)=>e.getInt32(t,!0)/2147483648;case"f32":case"f32-planar":return(e,t)=>e.getFloat32(t,!0)}},Cs=e=>{switch(e){case"u8":case"u8-planar":return(e,t,r)=>e.setUint8(t,F(127.5*(r+1),0,255));case"s16":case"s16-planar":return(e,t,r)=>e.setInt16(t,F(Math.round(32767*r),-32768,32767),!0);case"s32":case"s32-planar":return(e,t,r)=>e.setInt32(t,F(Math.round(2147483647*r),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,t,r)=>e.setFloat32(t,r,!0)}},xs=e=>"undefined"!=typeof AudioData&&e instanceof AudioData,Ps=e=>{if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.metadataOnly&&"boolean"!=typeof e.metadataOnly)throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(void 0!==e.verifyKeyPackets&&"boolean"!=typeof e.verifyKeyPackets)throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(e.verifyKeyPackets&&e.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},_s=e=>{if("number"!=typeof e||Number.isNaN(e))throw new TypeError("timestamp must be a number.")},Es=(e,t,r)=>r.verifyKeyPackets?t.then((async t=>{if(!t||"delta"===t.type)return t;const r=await e.determinePacketType(t);return r&&(t.type=r),t})):t;class Is{constructor(e){if(!(e instanceof Us))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){return Ps(e),Es(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,t={}){return _s(e),Ps(t),Es(this._track,this._track._backing.getPacket(e,t),t)}getNextPacket(e,t={}){if(!(e instanceof gs))throw new TypeError("packet must be an EncodedPacket.");return Ps(t),Es(this._track,this._track._backing.getNextPacket(e,t),t)}async getKeyPacket(e,t={}){if(_s(e),Ps(t),!t.verifyKeyPackets)return this._track._backing.getKeyPacket(e,t);const r=await this._track._backing.getKeyPacket(e,t);if(!r||"delta"===r.type)return r;return"delta"===await this._track.determinePacketType(r)?this.getKeyPacket(r.timestamp-1/this._track.timeResolution,t):r}async getNextKeyPacket(e,t={}){if(!(e instanceof gs))throw new TypeError("packet must be an EncodedPacket.");if(Ps(t),!t.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,t);const r=await this._track._backing.getNextKeyPacket(e,t);if(!r||"delta"===r.type)return r;return"delta"===await this._track.determinePacketType(r)?this.getNextKeyPacket(r,t):r}packets(e,t,r={}){if(void 0!==e&&!(e instanceof gs))throw new TypeError("startPacket must be an EncodedPacket.");if(void 0!==e&&e.isMetadataOnly&&!r?.metadataOnly)throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(void 0!==t&&!(t instanceof gs))throw new TypeError("endPacket must be an EncodedPacket.");Ps(r);const i=[];let{promise:s,resolve:a}=P(),{promise:n,resolve:o}=P(),c=!1,u=!1,d=null;const l=[];return(async()=>{let d=e??await this.getFirstPacket(r);for(;d&&!u&&!(t&&d.sequenceNumber>=t?.sequenceNumber);)i.length>Math.max(2,l.length)?(({promise:n,resolve:o}=P()),await n):(i.push(d),a(),({promise:s,resolve:a}=P()),d=await this.getNextPacket(d,r));c=!0,a()})().catch((e=>{d||(d=e,a())})),{async next(){for(;;){if(u)return{value:void 0,done:!0};if(d)throw d;if(i.length>0){const e=i.shift(),t=performance.now();for(l.push(t);l.length>0&&t-l[0]>=1e3;)l.shift();return o(),{value:e,done:!1}}if(c)return{value:void 0,done:!0};await s}},return:async()=>(u=!0,o(),a(),{value:void 0,done:!0}),async throw(e){throw e},[Symbol.asyncIterator](){return this}}}}class Bs{constructor(e,t){this.onSample=e,this.onError=t}}class Ms{mediaSamplesInRange(e=0,t=1/0){_s(e),_s(t);const r=[];let i=!1,s=null,{promise:a,resolve:n}=P(),{promise:o,resolve:c}=P(),u=!1,d=!1,l=!1,h=null;return(async()=>{const m=new Error,f=await this._createDecoder((o=>{c(),o.timestamp>=t&&(d=!0),d?o.close():(s&&(o.timestamp>e?(r.push(s),i=!0):s.close()),o.timestamp>=e&&(r.push(o),i=!0),s=i?null:o,r.length>0&&(n(),({promise:a,resolve:n}=P())))}),(e=>{h||(e.stack=m.stack,h=e,n())})),p=this._createPacketSink(),g=await p.getKeyPacket(e,{verifyKeyPackets:!0})??await p.getFirstPacket();if(!g)return;let w,k=g;if(t<1/0){const e=await p.getPacket(t),r=e?"key"===e.type&&e.timestamp===t?e:await p.getNextKeyPacket(e,{verifyKeyPackets:!0}):null;r&&(w=r)}const b=p.packets(g,w);for(await b.next();k&&!d;){const e=zs(r.length);if(r.length+f.getDecodeQueueSize()>e){({promise:o,resolve:c}=P()),await o;continue}f.decode(k);const t=await b.next();if(t.done)break;k=t.value}await b.return(),l||await f.flush(),f.close(),!i&&s&&r.push(s),u=!0,n()})().catch((e=>{h||(h=e,n())})),{async next(){for(;;){if(l)return{value:void 0,done:!0};if(h)throw h;if(r.length>0){const e=r.shift();return c(),{value:e,done:!1}}if(u)return{value:void 0,done:!0};await a}},async return(){l=!0,d=!0,c(),n(),s?.close();for(const e of r)e.close();return{value:void 0,done:!0}},async throw(e){throw e},[Symbol.asyncIterator](){return this}}}mediaSamplesAtTimestamps(t){(e=>{if(!(Symbol.iterator in e)&&!(Symbol.asyncIterator in e))throw new TypeError("Argument must be an iterable or async iterable.")})(t);const r=async function*(e){Symbol.iterator in e?yield*e[Symbol.iterator]():yield*e[Symbol.asyncIterator]()}(t),i=[],s=[];let{promise:a,resolve:n}=P(),{promise:o,resolve:c}=P(),u=!1,d=!1,l=null;const h=e=>{s.push(e),n(),({promise:a,resolve:n}=P())};return(async()=>{const t=new Error,a=await this._createDecoder((e=>{if(c(),d)return void e.close();let t=0;for(;i.length>0&&e.timestamp-i[0]>-1e-10;)t++,i.shift();if(t>0)for(let r=0;r<t;r++)h(r<t-1?e.clone():e);else e.close()}),(e=>{l||(e.stack=t.stack,l=e,n())})),m=this._createPacketSink();let f=null,p=null,g=-1;const w=async()=>{e(p);let t=p;for(a.decode(t);t.sequenceNumber<g;){const r=zs(s.length);for(;s.length+a.getDecodeQueueSize()>r&&!d;)({promise:o,resolve:c}=P()),await o;if(d)break;const i=await m.getNextPacket(t);e(i),t=i,a.decode(i)}g=-1},k=async()=>{await a.flush();for(let e=0;e<i.length;e++)h(null);i.length=0};for await(const e of r){if(_s(e),d)break;const t=await m.getPacket(e),r=t&&await m.getKeyPacket(e,{verifyKeyPackets:!0});r?(f&&(r.sequenceNumber!==p.sequenceNumber||t.timestamp<f.timestamp)&&(await w(),await k()),i.push(t.timestamp),g=Math.max(t.sequenceNumber,g),f=t,p=r):(-1!==g&&(await w(),await k()),h(null),f=null)}d||(-1!==g&&await w(),await k()),a.close(),u=!0,n()})().catch((e=>{l||(l=e,n())})),{async next(){for(;;){if(d)return{value:void 0,done:!0};if(l)throw l;if(s.length>0){const t=s.shift();return e(void 0!==t),c(),{value:t,done:!1}}if(u)return{value:void 0,done:!0};await a}},async return(){d=!0,c(),n();for(const e of s)e?.close();return{value:void 0,done:!0}},async throw(e){throw e},[Symbol.asyncIterator](){return this}}}}const zs=e=>0===e?40:8;class Fs extends Bs{constructor(t,i,s,a,n,o){super(t,i),this.rotation=n,this.timeResolution=o,this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new N,this.customDecoderQueueSize=0,this.inputTimestamps=[],this.sampleQueue=[];const c=us.find((e=>e.supports(s,a)));if(c)this.customDecoder=new c,this.customDecoder.codec=s,this.customDecoder.config=a,this.customDecoder.onSample=e=>{if(!(e instanceof ws))throw new TypeError("The argument passed to onSample must be a VideoSample.");this.finalizeAndEmitSample(e)},this.customDecoderCallSerializer.call((()=>this.customDecoder.init()));else{const t=t=>{if(q()){if(this.sampleQueue.length>0&&t.timestamp>=r(this.sampleQueue).timestamp){for(const e of this.sampleQueue)this.finalizeAndEmitSample(e);this.sampleQueue.length=0}x(this.sampleQueue,t,(e=>e.timestamp))}else{const r=this.inputTimestamps.shift();e(void 0!==r),t.setTimestamp(r),this.finalizeAndEmitSample(t)}};this.decoder=new VideoDecoder({output:e=>t(new ws(e)),error:i}),this.decoder.configure(a)}}finalizeAndEmitSample(e){e.setTimestamp(Math.round(e.timestamp*this.timeResolution)/this.timeResolution),e.setDuration(Math.round(e.duration*this.timeResolution)/this.timeResolution),e.setRotation(this.rotation),this.onSample(e)}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(e(this.decoder),this.decoder.decodeQueueSize)}decode(t){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call((()=>this.customDecoder.decode(t))).then((()=>this.customDecoderQueueSize--))):(e(this.decoder),q()||x(this.inputTimestamps,t.timestamp,(e=>e)),this.decoder.decode(t.toEncodedVideoChunk()))}async flush(){if(this.customDecoder?await this.customDecoderCallSerializer.call((()=>this.customDecoder.flush())):(e(this.decoder),await this.decoder.flush()),q()){for(const e of this.sampleQueue)this.finalizeAndEmitSample(e);this.sampleQueue.length=0}}close(){this.customDecoder?this.customDecoderCallSerializer.call((()=>this.customDecoder.close())):(e(this.decoder),this.decoder.close());for(const e of this.sampleQueue)e.close();this.sampleQueue.length=0}}class As extends Ms{constructor(e){if(!(e instanceof Ls))throw new TypeError("videoTrack must be an InputVideoTrack.");super(),this._videoTrack=e}async _createDecoder(t,r){if(!await this._videoTrack.canDecode())throw new Error("This video track cannot be decoded by this browser. Make sure to check decodability before using a track.");const i=this._videoTrack.codec,s=this._videoTrack.rotation,a=await this._videoTrack.getDecoderConfig(),n=this._videoTrack.timeResolution;return e(i&&a),new Fs(t,r,i,a,s,n)}_createPacketSink(){return new Is(this._videoTrack)}async getSample(e){_s(e);for await(const t of this.mediaSamplesAtTimestamps([e]))return t;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,t=1/0){return this.mediaSamplesInRange(e,t)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class Ds{constructor(e,t={}){if(this._nextCanvasIndex=0,!(e instanceof Ls))throw new TypeError("videoTrack must be an InputVideoTrack.");if(t&&"object"!=typeof t)throw new TypeError("options must be an object.");if(void 0!==t.width&&(!Number.isInteger(t.width)||t.width<=0))throw new TypeError("options.width, when defined, must be a positive integer.");if(void 0!==t.height&&(!Number.isInteger(t.height)||t.height<=0))throw new TypeError("options.height, when defined, must be a positive integer.");if(void 0!==t.fit&&!["fill","contain","cover"].includes(t.fit))throw new TypeError('options.fit, when provided, must be one of "fill", "contain", or "cover".');if(void 0!==t.width&&void 0!==t.height&&void 0===t.fit)throw new TypeError("When both options.width and options.height are provided, options.fit must also be provided.");if(void 0!==t.rotation&&![0,90,180,270].includes(t.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180 or 270.");if(void 0!==t.poolSize&&("number"!=typeof t.poolSize||!Number.isInteger(t.poolSize)||t.poolSize<0))throw new TypeError("poolSize must be a non-negative integer.");const r=t.rotation??e.rotation;let[i,s]=r%180==0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth];const a=i/s;void 0!==t.width&&void 0===t.height?(i=t.width,s=Math.round(i/a)):void 0===t.width&&void 0!==t.height?(s=t.height,i=Math.round(s*a)):void 0!==t.width&&void 0!==t.height&&(i=t.width,s=t.height),this._videoTrack=e,this._width=i,this._height=s,this._rotation=r,this._fit=t.fit??"fill",this._videoSampleSink=new As(e),this._canvasPool=Array.from({length:t.poolSize??0},(()=>null))}_videoSampleToWrappedCanvas(t){let r=this._canvasPool[this._nextCanvasIndex],i=!1;r||("undefined"!=typeof document?(r=document.createElement("canvas"),r.width=this._width,r.height=this._height):r=new OffscreenCanvas(this._width,this._height),this._canvasPool.length>0&&(this._canvasPool[this._nextCanvasIndex]=r),i=!0),this._canvasPool.length>0&&(this._nextCanvasIndex=(this._nextCanvasIndex+1)%this._canvasPool.length);const s=r.getContext("2d",{alpha:!1});e(s),s.resetTransform(),i||s.clearRect(0,0,this._width,this._height),t.drawWithFit(s,{fit:this._fit,rotation:this._rotation});const a={canvas:r,timestamp:t.timestamp,duration:t.duration};return t.close(),a}async getCanvas(e){_s(e);const t=await this._videoSampleSink.getSample(e);return t&&this._videoSampleToWrappedCanvas(t)}canvases(e=0,t=1/0){return z(this._videoSampleSink.samples(e,t),(e=>this._videoSampleToWrappedCanvas(e)))}canvasesAtTimestamps(e){return z(this._videoSampleSink.samplesAtTimestamps(e),(e=>e&&this._videoSampleToWrappedCanvas(e)))}}class Rs extends Bs{constructor(e,t,r,i){super(e,t),this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new N,this.customDecoderQueueSize=0,this.currentTimestamp=null;const s=t=>{(null===this.currentTimestamp||Math.abs(t.timestamp-this.currentTimestamp)>=t.duration)&&(this.currentTimestamp=t.timestamp);const r=this.currentTimestamp;if(this.currentTimestamp+=t.duration,0===t.numberOfFrames)return void t.close();const s=i.sampleRate;t.setTimestamp(Math.round(r*s)/s),e(t)},a=ds.find((e=>e.supports(r,i)));a?(this.customDecoder=new a,this.customDecoder.codec=r,this.customDecoder.config=i,this.customDecoder.onSample=e=>{if(!(e instanceof ys))throw new TypeError("The argument passed to onSample must be an AudioSample.");s(e)},this.customDecoderCallSerializer.call((()=>this.customDecoder.init()))):(this.decoder=new AudioDecoder({output:e=>s(new ys(e)),error:t}),this.decoder.configure(i))}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(e(this.decoder),this.decoder.decodeQueueSize)}decode(t){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call((()=>this.customDecoder.decode(t))).then((()=>this.customDecoderQueueSize--))):(e(this.decoder),this.decoder.decode(t.toEncodedAudioChunk()))}flush(){return this.customDecoder?this.customDecoderCallSerializer.call((()=>this.customDecoder.flush())):(e(this.decoder),this.decoder.flush())}close(){this.customDecoder?this.customDecoderCallSerializer.call((()=>this.customDecoder.close())):(e(this.decoder),this.decoder.close())}}class Os extends Bs{constructor(t,r,i){super(t,r),this.decoderConfig=i,this.currentTimestamp=null,e(K.includes(i.codec)),this.codec=i.codec;const{dataType:s,sampleSize:a,littleEndian:n}=fe(this.codec);switch(this.inputSampleSize=a,a){case 1:"unsigned"===s?this.readInputValue=(e,t)=>e.getUint8(t)-128:"signed"===s?this.readInputValue=(e,t)=>e.getInt8(t):"ulaw"===s?this.readInputValue=(e,t)=>(e=>{let t=0,r=0,i=~e;128&i&&(i&=-129,t=-1),r=5+((240&i)>>4);const s=(1<<r|(15&i)<<r-4|1<<r-5)-33;return 0===t?s:-s})(e.getUint8(t)):"alaw"===s?this.readInputValue=(e,t)=>(e=>{let t=0,r=0,i=85^e;128&i&&(i&=-129,t=-1),r=4+((240&i)>>4);let s=0;return s=4!==r?1<<r|(15&i)<<r-4|1<<r-5:i<<1|1,0===t?s:-s})(e.getUint8(t)):e(!1);break;case 2:"unsigned"===s?this.readInputValue=(e,t)=>e.getUint16(t,n)-32768:"signed"===s?this.readInputValue=(e,t)=>e.getInt16(t,n):e(!1);break;case 3:"unsigned"===s?this.readInputValue=(e,t)=>B(e,t,n)-2**23:"signed"===s?this.readInputValue=(e,t)=>((e,t,r)=>B(e,t,r)<<8>>8)(e,t,n):e(!1);break;case 4:"unsigned"===s?this.readInputValue=(e,t)=>e.getUint32(t,n)-2**31:"signed"===s?this.readInputValue=(e,t)=>e.getInt32(t,n):"float"===s?this.readInputValue=(e,t)=>e.getFloat32(t,n):e(!1);break;case 8:"float"===s?this.readInputValue=(e,t)=>e.getFloat64(t,n):e(!1);break;default:I(a),e(!1)}switch(a){case 1:"ulaw"===s||"alaw"===s?(this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(e,t,r)=>e.setInt16(t,r,!0)):(this.outputSampleSize=1,this.outputFormat="u8",this.writeOutputValue=(e,t,r)=>e.setUint8(t,r+128));break;case 2:this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(e,t,r)=>e.setInt16(t,r,!0);break;case 3:this.outputSampleSize=4,this.outputFormat="s32",this.writeOutputValue=(e,t,r)=>e.setInt32(t,r<<8,!0);break;case 4:this.outputSampleSize=4,"float"===s?(this.outputFormat="f32",this.writeOutputValue=(e,t,r)=>e.setFloat32(t,r,!0)):(this.outputFormat="s32",this.writeOutputValue=(e,t,r)=>e.setInt32(t,r,!0));break;case 8:this.outputSampleSize=4,this.outputFormat="f32",this.writeOutputValue=(e,t,r)=>e.setFloat32(t,r,!0);break;default:I(a),e(!1)}}getDecodeQueueSize(){return 0}decode(e){const t=c(e.data),r=e.byteLength/this.decoderConfig.numberOfChannels/this.inputSampleSize,i=r*this.decoderConfig.numberOfChannels*this.outputSampleSize,s=new ArrayBuffer(i),a=new DataView(s);for(let e=0;e<r*this.decoderConfig.numberOfChannels;e++){const r=e*this.inputSampleSize,i=e*this.outputSampleSize,s=this.readInputValue(t,r);this.writeOutputValue(a,i,s)}const n=r/this.decoderConfig.sampleRate;(null===this.currentTimestamp||Math.abs(e.timestamp-this.currentTimestamp)>=n)&&(this.currentTimestamp=e.timestamp);const o=this.currentTimestamp;this.currentTimestamp+=n;const u=new ys({format:this.outputFormat,data:s,numberOfChannels:this.decoderConfig.numberOfChannels,sampleRate:this.decoderConfig.sampleRate,numberOfFrames:r,timestamp:o});this.onSample(u)}async flush(){}close(){}}class Ws extends Ms{constructor(e){if(!(e instanceof Ns))throw new TypeError("audioTrack must be an InputAudioTrack.");super(),this._audioTrack=e}async _createDecoder(t,r){if(!await this._audioTrack.canDecode())throw new Error("This audio track cannot be decoded by this browser. Make sure to check decodability before using a track.");const i=this._audioTrack.codec,s=await this._audioTrack.getDecoderConfig();return e(i&&s),K.includes(s.codec)?new Os(t,r,s):new Rs(t,r,i,s)}_createPacketSink(){return new Is(this._audioTrack)}async getSample(e){_s(e);for await(const t of this.mediaSamplesAtTimestamps([e]))return t;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,t=1/0){return this.mediaSamplesInRange(e,t)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class Vs{constructor(e){if(!(e instanceof Ns))throw new TypeError("audioTrack must be an InputAudioTrack.");this._audioSampleSink=new Ws(e)}_audioSampleToWrappedArrayBuffer(e){return{buffer:e.toAudioBuffer(),timestamp:e.timestamp,duration:e.duration}}async getBuffer(e){_s(e);const t=await this._audioSampleSink.getSample(e);return t&&this._audioSampleToWrappedArrayBuffer(t)}buffers(e=0,t=1/0){return z(this._audioSampleSink.samples(e,t),(e=>this._audioSampleToWrappedArrayBuffer(e)))}buffersAtTimestamps(e){return z(this._audioSampleSink.samplesAtTimestamps(e),(e=>e&&this._audioSampleToWrappedArrayBuffer(e)))}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Us{constructor(e){this._backing=e}isVideoTrack(){return this instanceof Ls}isAudioTrack(){return this instanceof Ns}get id(){return this._backing.getId()}get internalCodecId(){return this._backing.getInternalCodecId()}get languageCode(){return this._backing.getLanguageCode()}get name(){return this._backing.getName()}get timeResolution(){return this._backing.getTimeResolution()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const t=new Is(this);let r=1/0,i=-1/0,s=0,a=0;for await(const n of t.packets(void 0,void 0,{metadataOnly:!0})){if(s>=e&&n.timestamp>=i)break;r=Math.min(r,n.timestamp),i=Math.max(i,n.timestamp+n.duration),s++,a+=n.byteLength}return{packetCount:s,averagePacketRate:s?Number((s/(i-r)).toPrecision(16)):0,averageBitrate:s?Number((8*a/(i-r)).toPrecision(16)):0}}}class Ls extends Us{constructor(e){super(e),this._backing=e}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180==0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180==0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return"bt2020"===e.primaries||"smpte432"===e.primaries||"pg"===e.transfer||"hlg"===e.transfer||"bt2020-ncl"===e.matrix}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return e?.codec??null}async canDecode(){try{const t=await this._backing.getDecoderConfig();if(!t)return!1;const r=this._backing.getCodec();if(e(null!==r),us.some((e=>e.supports(r,t))))return!0;if("undefined"==typeof VideoDecoder)return!1;return!0===(await VideoDecoder.isConfigSupported(t)).supported}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(t){if(!(t instanceof gs))throw new TypeError("packet must be an EncodedPacket.");if(t.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");return null===this.codec?null:(async(t,r)=>{switch(e(t.codec),t.codec){case"avc":{const i=await t.getDecoderConfig();let s;if(e(i),i.description){const e=1+(3&o(i.description)[4]);s=Le(r.data,e)}else s=Ue(r.data);return s.some((e=>5===He(e)))?"key":"delta"}case"hevc":{const i=await t.getDecoderConfig();let s;if(e(i),i.description){const e=1+(3&o(i.description)[21]);s=Le(r.data,e)}else s=Ue(r.data);return s.some((e=>{const t=$e(e);return 16<=t&&t<=23}))?"key":"delta"}case"vp8":return 1&r.data[0]?"delta":"key";case"vp9":{const e=new s(r.data);if(2!==e.readBits(2))return null;const t=e.readBits(1);return 3===(e.readBits(1)<<1)+t&&e.skipBits(1),e.readBits(1)?null:0===e.readBits(1)?"key":"delta"}case"av1":{let e=!1;for(const{type:t,data:i}of tt(r.data))if(1===t){const t=new s(i);t.skipBits(4),e=!!t.readBits(1)}else if(3===t||6===t||7===t){if(e)return"key";const t=new s(i);return t.readBits(1)?null:0===t.readBits(2)?"key":"delta"}return null}default:I(t.codec),e(!1)}})(this,t)}}class Ns extends Us{constructor(e){super(e),this._backing=e}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){const e=await this._backing.getDecoderConfig();return e?.codec??null}async canDecode(){try{const t=await this._backing.getDecoderConfig();if(!t)return!1;const r=this._backing.getCodec();if(e(null!==r),ds.some((e=>e.supports(r,t))))return!0;if(t.codec.startsWith("pcm-"))return!0;if("undefined"==typeof AudioDecoder)return!1;return!0===(await AudioDecoder.isConfigSupported(t)).supported}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof gs))throw new TypeError("packet must be an EncodedPacket.");return null===this.codec?null:"key"}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */var Hs;!function(e){e[e.PCM=1]="PCM",e[e.IEEE_FLOAT=3]="IEEE_FLOAT",e[e.ALAW=6]="ALAW",e[e.MULAW=7]="MULAW",e[e.EXTENSIBLE=65534]="EXTENSIBLE"}(Hs||(Hs={}));class qs extends ss{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let t=this.reader.requestSlice(0,12);t instanceof Promise&&(t=await t),e(t);const r=ei(t,4),i="RIFX"!==r,s="RF64"===r,a=jr(t,i);let n=s?this.reader.fileSize:Math.min(a+8,this.reader.fileSize);if("WAVE"!==ei(t,4))throw new Error("Invalid WAVE file - wrong format");let o=0,c=null,u=t.filePos;for(;u<n;){let e=this.reader.requestSlice(u,8);if(e instanceof Promise&&(e=await e),!e)break;const t=ei(e,4),r=jr(e,i),a=e.filePos;if(s&&0===o&&"ds64"!==t)throw new Error('Invalid RF64 file: First chunk must be "ds64".');if("fmt "===t)await this.parseFmtChunk(a,r,i);else if("data"===t)c??=r,this.dataStart=e.filePos,this.dataSize=Math.min(c,n-this.dataStart);else if("ds64"===t){const t=Gr(e,i);c=Gr(e,i),n=Math.min(t+8,this.reader.fileSize)}u=a+r+(1&r),o++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(-1===this.dataStart)throw new Error('Invalid WAVE file - missing "data" chunk');const d=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/d)*d,this.tracks.push(new Ns(new js(this)))})()}async parseFmtChunk(e,t,r){let i=this.reader.requestSlice(e,t);if(i instanceof Promise&&(i=await i),!i)return;let s=Nr(i,r);const a=Nr(i,r),n=jr(i,r);i.skip(4);const o=Nr(i,r);let c;if(c=14===t?8:Nr(i,r),t>=18&&357!==s){const e=Nr(i,r),a=t-18;if(Math.min(a,e)>=22&&s===Hs.EXTENSIBLE){i.skip(6);const e=Ur(i,16);s=e[0]|e[1]<<8}}s!==Hs.MULAW&&s!==Hs.ALAW||(c=8),this.audioInfo={format:s,numberOfChannels:a,sampleRate:n,sampleSizeInBytes:Math.ceil(c/8),blockSizeInBytes:o}}getCodec(){if(e(this.audioInfo),this.audioInfo.format===Hs.MULAW)return"ulaw";if(this.audioInfo.format===Hs.ALAW)return"alaw";if(this.audioInfo.format===Hs.PCM){if(1===this.audioInfo.sampleSizeInBytes)return"pcm-u8";if(2===this.audioInfo.sampleSizeInBytes)return"pcm-s16";if(3===this.audioInfo.sampleSizeInBytes)return"pcm-s24";if(4===this.audioInfo.sampleSizeInBytes)return"pcm-s32"}return this.audioInfo.format===Hs.IEEE_FLOAT&&4===this.audioInfo.sampleSizeInBytes?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){await this.readMetadata(),e(this.audioInfo);return this.dataSize/this.audioInfo.blockSizeInBytes/this.audioInfo.sampleRate}async getTracks(){return await this.readMetadata(),this.tracks}}const $s=2048;class js{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}getInternalCodecId(){return e(this.demuxer.audioInfo),this.demuxer.audioInfo.format}async getDecoderConfig(){const t=this.demuxer.getCodec();return t?(e(this.demuxer.audioInfo),{codec:t,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}computeDuration(){return this.demuxer.computeDuration()}getNumberOfChannels(){return e(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return e(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return e(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return A}async getFirstTimestamp(){return 0}async getPacketAtIndex(t,r){e(this.demuxer.audioInfo);const i=t*$s*this.demuxer.audioInfo.blockSizeInBytes;if(i>=this.demuxer.dataSize)return null;const s=Math.min($s*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-i);let a;if(r.metadataOnly)a=ps;else{let t=this.demuxer.reader.requestSlice(this.demuxer.dataStart+i,s);t instanceof Promise&&(t=await t),e(t),a=Ur(t,s)}const n=t*$s/this.demuxer.audioInfo.sampleRate,o=s/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return new gs(a,"key",n,o,t,s)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}getPacket(t,r){e(this.demuxer.audioInfo);const i=Math.floor(t*this.demuxer.audioInfo.sampleRate/$s);return this.getPacketAtIndex(i,r)}getNextPacket(t,r){e(this.demuxer.audioInfo);const i=Math.round(t.timestamp*this.demuxer.audioInfo.sampleRate/$s);return this.getPacketAtIndex(i+1,r)}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ks{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer)}writeU16(e){this.helperView.setUint16(0,e,!0),this.writer.write(this.helper.subarray(0,2))}writeU32(e){this.helperView.setUint32(0,e,!0),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,e,!0),this.helperView.setUint32(4,Math.floor(e/2**32),!0),this.writer.write(this.helper)}writeAscii(e){this.writer.write((new TextEncoder).encode(e))}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Qs extends Me{constructor(e,t){super(e),this.headerWritten=!1,this.dataSize=0,this.sampleRate=null,this.sampleCount=0,this.format=t,this.writer=e._writer,this.riffWriter=new Ks(e._writer),this.isRf64=!!t._options.large}async start(){}async getMimeType(){return"audio/wav"}async addEncodedVideoPacket(){throw new Error("WAVE does not support video.")}async addEncodedAudioPacket(t,r,i){const s=await this.mutex.acquire();try{if(this.headerWritten||(Ie(i),e(i),e(i.decoderConfig),this.writeHeader(t,i.decoderConfig),this.sampleRate=i.decoderConfig.sampleRate,this.headerWritten=!0),this.validateAndNormalizeTimestamp(t,r.timestamp,"key"===r.type),!this.isRf64&&this.writer.getPos()+r.data.byteLength>=2**32)throw new Error("Adding more audio data would exceed the maximum RIFF size of 4 GiB. To write larger files, use RF64 by setting `large: true` in the WavOutputFormatOptions.");this.writer.write(r.data),this.dataSize+=r.data.byteLength,this.sampleCount+=Math.round(r.duration*this.sampleRate),await this.writer.flush()}finally{s()}}async addSubtitleCue(){throw new Error("WAVE does not support subtitles.")}writeHeader(e,t){let r;this.format._options.onHeader&&this.writer.startTrackingWrites();const i=e.source._codec,s=fe(i);r="ulaw"===s.dataType?Hs.MULAW:"alaw"===s.dataType?Hs.ALAW:"float"===s.dataType?Hs.IEEE_FLOAT:Hs.PCM;const a=t.numberOfChannels,n=t.sampleRate,o=s.sampleSize*a;if(this.riffWriter.writeAscii(this.isRf64?"RF64":"RIFF"),this.isRf64?this.riffWriter.writeU32(4294967295):this.riffWriter.writeU32(0),this.riffWriter.writeAscii("WAVE"),this.isRf64&&(this.riffWriter.writeAscii("ds64"),this.riffWriter.writeU32(28),this.riffWriter.writeU64(0),this.riffWriter.writeU64(0),this.riffWriter.writeU64(0),this.riffWriter.writeU32(0)),this.riffWriter.writeAscii("fmt "),this.riffWriter.writeU32(16),this.riffWriter.writeU16(r),this.riffWriter.writeU16(a),this.riffWriter.writeU32(n),this.riffWriter.writeU32(n*o),this.riffWriter.writeU16(o),this.riffWriter.writeU16(8*s.sampleSize),this.riffWriter.writeAscii("data"),this.isRf64?this.riffWriter.writeU32(4294967295):this.riffWriter.writeU32(0),this.format._options.onHeader){const{data:e,start:t}=this.writer.stopTrackingWrites();this.format._options.onHeader(e,t)}}async finalize(){const e=await this.mutex.acquire(),t=this.writer.getPos();this.isRf64?(this.writer.seek(20),this.riffWriter.writeU64(t-8),this.writer.seek(28),this.riffWriter.writeU64(this.dataSize),this.writer.seek(36),this.riffWriter.writeU64(this.sampleCount)):(this.writer.seek(4),this.riffWriter.writeU32(t-8),this.writer.seek(40),this.riffWriter.writeU32(this.dataSize)),this.writer.seek(t),e()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Ys{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter((e=>j.includes(e)))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter((e=>Y.includes(e)))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter((e=>G.includes(e)))}_codecUnsupportedHint(e){return""}}class Gs extends Ys{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.fastStart&&![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError('options.fastStart, when provided, must be false, "in-memory", or "fragmented".');if(void 0!==e.minimumFragmentDuration&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(void 0!==e.onFtyp&&"function"!=typeof e.onFtyp)throw new TypeError("options.onFtyp, when provided, must be a function.");if(void 0!==e.onMoov&&"function"!=typeof e.onMoov)throw new TypeError("options.onMoov, when provided, must be a function.");if(void 0!==e.onMdat&&"function"!=typeof e.onMdat)throw new TypeError("options.onMdat, when provided, must be a function.");if(void 0!==e.onMoof&&"function"!=typeof e.onMoof)throw new TypeError("options.onMoof, when provided, must be a function.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:2**32-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new ui(e,this)}}class Xs extends Gs{get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...j,...Q,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...G]}_codecUnsupportedHint(e){return(new Js).getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class Js extends Gs{get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...j,...Y]}_codecUnsupportedHint(e){return(new Xs).getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}class Zs extends Ys{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.appendOnly&&"boolean"!=typeof e.appendOnly)throw new TypeError("options.appendOnly, when provided, must be a boolean.");if(void 0!==e.minimumClusterDuration&&(!Number.isFinite(e.minimumClusterDuration)||e.minimumClusterDuration<0))throw new TypeError("options.minimumClusterDuration, when provided, must be a non-negative number.");if(void 0!==e.onEbmlHeader&&"function"!=typeof e.onEbmlHeader)throw new TypeError("options.onEbmlHeader, when provided, must be a function.");if(void 0!==e.onSegmentHeader&&"function"!=typeof e.onSegmentHeader)throw new TypeError("options.onHeader, when provided, must be a function.");if(void 0!==e.onCluster&&"function"!=typeof e.onCluster)throw new TypeError("options.onCluster, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new Oi(e,this)}get _name(){return"Matroska"}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:127}}}get fileExtension(){return".mkv"}get mimeType(){return"video/x-matroska"}getSupportedCodecs(){return[...j,...Q,...K.filter((e=>!["pcm-s8","pcm-f32be","pcm-f64be","ulaw","alaw"].includes(e))),...G]}get supportsVideoRotationMetadata(){return!1}}class ea extends Zs{getSupportedCodecs(){return[...j.filter((e=>["vp8","vp9","av1"].includes(e))),...Y.filter((e=>["opus","vorbis"].includes(e))),...G]}get _name(){return"WebM"}get fileExtension(){return".webm"}get mimeType(){return"video/webm"}_codecUnsupportedHint(e){return(new Zs).getSupportedCodecs().includes(e)?" Switching to MKV will grant support for this codec.":""}}class ta extends Ys{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.xingHeader&&"boolean"!=typeof e.xingHeader)throw new TypeError("options.xingHeader, when provided, must be a boolean.");if(void 0!==e.onXingFrame&&"function"!=typeof e.onXingFrame)throw new TypeError("options.onXingFrame, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new Ki(e,this)}get _name(){return"MP3"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".mp3"}get mimeType(){return"audio/mpeg"}getSupportedCodecs(){return["mp3"]}get supportsVideoRotationMetadata(){return!1}}class ra extends Ys{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.large&&"boolean"!=typeof e.large)throw new TypeError("options.large, when provided, must be a boolean.");if(void 0!==e.onHeader&&"function"!=typeof e.onHeader)throw new TypeError("options.onHeader, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new Qs(e,this)}get _name(){return"WAVE"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".wav"}get mimeType(){return"audio/wav"}getSupportedCodecs(){return[...K.filter((e=>["pcm-s16","pcm-s24","pcm-s32","pcm-f32","pcm-u8","ulaw","alaw"].includes(e)))]}get supportsVideoRotationMetadata(){return!1}}class ia extends Ys{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.onPage&&"function"!=typeof e.onPage)throw new TypeError("options.onPage, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new is(e,this)}get _name(){return"Ogg"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:0,max:1/0},subtitle:{min:0,max:0},total:{min:1,max:2**32}}}get fileExtension(){return".ogg"}get mimeType(){return"application/ogg"}getSupportedCodecs(){return[...Y.filter((e=>["vorbis","opus"].includes(e)))]}get supportsVideoRotationMetadata(){return!1}}class sa extends Ys{constructor(e={}){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(void 0!==e.onFrame&&"function"!=typeof e.onFrame)throw new TypeError("options.onFrame, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new ze(e,this)}get _name(){return"ADTS"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".aac"}get mimeType(){return"audio/aac"}getSupportedCodecs(){return["aac"]}get supportsVideoRotationMetadata(){return!1}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const aa=e=>{if(!e||"object"!=typeof e)throw new TypeError("Encoding config must be an object.");if(!j.includes(e.codec))throw new TypeError(`Invalid video codec '${e.codec}'. Must be one of: ${j.join(", ")}.`);if(!(e.bitrate instanceof ge)&&(!Number.isInteger(e.bitrate)||e.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(void 0!==e.keyFrameInterval&&(!Number.isFinite(e.keyFrameInterval)||e.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(void 0!==e.sizeChangeBehavior&&!["deny","passThrough","fill","contain","cover"].includes(e.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(void 0!==e.onEncodedPacket&&"function"!=typeof e.onEncodedPacket)throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(void 0!==e.onEncoderConfig&&"function"!=typeof e.onEncoderConfig)throw new TypeError("config.onEncoderConfig, when provided, must be a function.");na(e.codec,e)},na=(e,t)=>{if(!t||"object"!=typeof t)throw new TypeError("Encoding options must be an object.");if(void 0!==t.bitrateMode&&!["constant","variable"].includes(t.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(void 0!==t.latencyMode&&!["quality","realtime"].includes(t.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(void 0!==t.fullCodecString&&"string"!=typeof t.fullCodecString)throw new TypeError("fullCodecString, when provided, must be a string.");if(void 0!==t.fullCodecString&&pe(t.fullCodecString)!==e)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${e}).`);if(void 0!==t.hardwareAcceleration&&!["no-preference","prefer-hardware","prefer-software"].includes(t.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(void 0!==t.scalabilityMode&&"string"!=typeof t.scalabilityMode)throw new TypeError("scalabilityMode, when provided, must be a string.");if(void 0!==t.contentHint&&"string"!=typeof t.contentHint)throw new TypeError("contentHint, when provided, must be a string.")},oa=e=>{const t=e.bitrate instanceof ge?e.bitrate._toVideoBitrate(e.codec,e.width,e.height):e.bitrate;return{codec:e.fullCodecString??ie(e.codec,e.width,e.height,t),width:e.width,height:e.height,bitrate:t,bitrateMode:e.bitrateMode,framerate:e.framerate,latencyMode:e.latencyMode,hardwareAcceleration:e.hardwareAcceleration,scalabilityMode:e.scalabilityMode,contentHint:e.contentHint,...(r=e.codec,"avc"===r?{avc:{format:"avc"}}:"hevc"===r?{hevc:{format:"hevc"}}:{})};var r},ca=e=>{if(!e||"object"!=typeof e)throw new TypeError("Encoding config must be an object.");if(!Y.includes(e.codec))throw new TypeError(`Invalid audio codec '${e.codec}'. Must be one of: ${Y.join(", ")}.`);if(void 0===e.bitrate&&(!K.includes(e.codec)||"flac"===e.codec))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(void 0!==e.bitrate&&!(e.bitrate instanceof ge)&&(!Number.isInteger(e.bitrate)||e.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(void 0!==e.onEncodedPacket&&"function"!=typeof e.onEncodedPacket)throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(void 0!==e.onEncoderConfig&&"function"!=typeof e.onEncoderConfig)throw new TypeError("config.onEncoderConfig, when provided, must be a function.");ua(e.codec,e)},ua=(e,t)=>{if(!t||"object"!=typeof t)throw new TypeError("Encoding options must be an object.");if(void 0!==t.bitrateMode&&!["constant","variable"].includes(t.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(void 0!==t.fullCodecString&&"string"!=typeof t.fullCodecString)throw new TypeError("fullCodecString, when provided, must be a string.");if(void 0!==t.fullCodecString&&pe(t.fullCodecString)!==e)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${e}).`)},da=e=>{const t=e.bitrate instanceof ge?e.bitrate._toAudioBitrate(e.codec):e.bitrate;return{codec:e.fullCodecString??oe(e.codec,e.numberOfChannels,e.sampleRate),numberOfChannels:e.numberOfChannels,sampleRate:e.sampleRate,bitrate:t,bitrateMode:e.bitrateMode,...(r=e.codec,"aac"===r?{aac:{format:"aac"}}:"opus"===r?{opus:{format:"opus"}}:{})};var r},la=e=>{if(j.includes(e))return ha(e);if(Y.includes(e))return ma(e);if(G.includes(e))return fa(e);throw new TypeError(`Unknown codec '${e}'.`)},ha=async(e,{width:t=1280,height:r=720,bitrate:i=1e6,...s}={})=>{if(!j.includes(e))return!1;if(!Number.isInteger(t)||t<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(r)||r<=0)throw new TypeError("height must be a positive integer.");if(!(i instanceof ge)&&(!Number.isInteger(i)||i<=0))throw new TypeError("bitrate must be a positive integer or a quality.");na(e,s);let a=null;if(ls.length>0&&(a??=oa({codec:e,width:t,height:r,bitrate:i,framerate:void 0,...s}),ls.some((t=>t.supports(e,a)))))return!0;if("undefined"==typeof VideoEncoder)return!1;a??=oa({codec:e,width:t,height:r,bitrate:i,framerate:void 0,...s});return!0===(await VideoEncoder.isConfigSupported(a)).supported},ma=async(e,{numberOfChannels:t=2,sampleRate:r=48e3,bitrate:i=128e3,...s}={})=>{if(!Y.includes(e))return!1;if(!Number.isInteger(t)||t<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(r)||r<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(i instanceof ge)&&(!Number.isInteger(i)||i<=0))throw new TypeError("bitrate must be a positive integer.");ua(e,s);let a=null;if(hs.length>0&&(a??=da({codec:e,numberOfChannels:t,sampleRate:r,bitrate:i,...s}),hs.some((t=>t.supports(e,a)))))return!0;if(K.includes(e))return!0;if("undefined"==typeof AudioEncoder)return!1;a??=da({codec:e,numberOfChannels:t,sampleRate:r,bitrate:i,...s});return!0===(await AudioEncoder.isConfigSupported(a)).supported},fa=async e=>!!G.includes(e),pa=async()=>{const[e,t,r]=await Promise.all([ga(),wa(),ka()]);return[...e,...t,...r]},ga=async(e=j,t)=>{const r=await Promise.all(e.map((e=>ha(e,t))));return e.filter(((e,t)=>r[t]))},wa=async(e=Y,t)=>{const r=await Promise.all(e.map((e=>ma(e,t))));return e.filter(((e,t)=>r[t]))},ka=async(e=G)=>{const t=await Promise.all(e.map(fa));return e.filter(((e,r)=>t[r]))},ba=async(e,t)=>{for(const r of e)if(await ha(r,t))return r;return null},ya=async(e,t)=>{for(const r of e)if(await ma(r,t))return r;return null},Ta=async e=>{for(const t of e)if(await fa(t))return t;return null};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class Sa{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if("canceled"===this._connectedTrack.output.state)throw new Error("Output has been canceled.");if("finalizing"===this._connectedTrack.output.state||"finalized"===this._connectedTrack.output.state)throw new Error("Output has been finalized.");if("pending"===this._connectedTrack.output.state)throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if("pending"===e.output.state)throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,"finalizing"!==e.output.state&&"finalized"!==e.output.state&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}}class va extends Sa{constructor(e){if(super(),this._connectedTrack=null,!j.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${j.join(", ")}.`);this._codec=e}}class Ca extends va{constructor(e){super(e)}add(e,t){if(!(e instanceof gs))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(void 0!==t&&(!t||"object"!=typeof t))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack,e,t)}}class xa{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new N,this.customEncoderQueueSize=0,this.encoderError=null}async add(t,r,i){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),null!==this.codedWidth&&null!==this.codedHeight){if(t.codedWidth!==this.codedWidth||t.codedHeight!==this.codedHeight){const i=this.encodingConfig.sizeChangeBehavior??"deny";if("passThrough"===i);else{if("deny"===i)throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${t.codedWidth}x${t.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let s=!1;this.resizeCanvas||("undefined"!=typeof document?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),s=!0);const a=this.resizeCanvas.getContext("2d",{alpha:!1});e(a),s||a.clearRect(0,0,this.codedWidth,this.codedHeight),t.drawWithFit(a,{fit:i}),r&&t.close(),t=new ws(this.resizeCanvas,{timestamp:t.timestamp,duration:t.duration,rotation:t.rotation}),r=!0}}}}else this.codedWidth=t.codedWidth,this.codedHeight=t.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(t),this.encoderInitialized||await this.ensureEncoderPromise),e(this.encoderInitialized);const s=this.encodingConfig.keyFrameInterval??5,a=Math.floor(t.timestamp/s),n={...i,keyFrame:i?.keyFrame||0===s||a!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=a,this.customEncoder){this.customEncoderQueueSize++;const e=t.clone(),r=this.customEncoderCallSerializer.call((()=>this.customEncoder.encode(e,n))).then((()=>this.customEncoderQueueSize--)).catch((e=>this.encoderError??=e)).finally((()=>{e.close()}));this.customEncoderQueueSize>=4&&await r}else{e(this.encoder);const i=t.toVideoFrame();this.encoder.encode(i,n),i.close(),r&&t.close(),this.encoder.encodeQueueSize>=4&&await new Promise((e=>this.encoder.addEventListener("dequeue",e,{once:!0})))}await this.muxer.mutex.currentPromise}finally{r&&t.close()}}async ensureEncoder(t){if(!this.encoder)return this.ensureEncoderPromise=(async()=>{const r=oa({width:t.codedWidth,height:t.codedHeight,...this.encodingConfig,framerate:this.source._connectedTrack?.metadata.frameRate});this.encodingConfig.onEncoderConfig?.(r);const i=ls.find((e=>e.supports(this.encodingConfig.codec,r)));if(i)this.customEncoder=new i,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=r,this.customEncoder.onPacket=(e,t)=>{if(!(e instanceof gs))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(void 0!==t&&(!t||"object"!=typeof t))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(e,t),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,e,t)},await this.customEncoder.init();else{if("undefined"==typeof VideoEncoder)throw new Error("VideoEncoder is not supported by this browser.");if(!(await VideoEncoder.isConfigSupported(r)).supported)throw new Error(`This specific encoder configuration (${r.codec}, ${r.bitrate} bps, ${r.width}x${r.height}, hardware acceleration: ${r.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);this.encoder=new VideoEncoder({output:(e,t)=>{const r=gs.fromEncodedChunk(e);this.encodingConfig.onEncodedPacket?.(r,t),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,r,t)},error:e=>{e.stack=(new Error).stack,this.encoderError??=e}}),this.encoder.configure(r)}e(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call((()=>this.customEncoder.flush())),await this.customEncoderCallSerializer.call((()=>this.customEncoder.close()))):this.encoder&&(e||await this.encoder.flush(),this.encoder.close()),this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.encoderError)throw this.encoderError}}class Pa extends va{constructor(e){aa(e),super(e.codec),this._encoder=new xa(this,e)}add(e,t){if(!(e instanceof ws))throw new TypeError("videoSample must be a VideoSample.");return this._encoder.add(e,!1,t)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class _a extends va{constructor(e,t){if(!("undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas))throw new TypeError("canvas must be an HTMLCanvasElement or OffscreenCanvas.");aa(t),super(t.codec),this._encoder=new xa(this,t),this._canvas=e}add(e,t=0,r){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(t)||t<0)throw new TypeError("duration must be a non-negative number.");const i=new ws(this._canvas,{timestamp:e,duration:t});return this._encoder.add(i,!0,r)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Ea extends va{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||"video"!==e.kind)throw new TypeError("track must be a video MediaStreamTrack.");aa(t),super((t={...t,latencyMode:"realtime"}).codec),this._abortController=null,this._workerTrackId=null,this._workerListener=null,this._promiseWithResolvers=P(),this._errorPromiseAccessed=!1,this._encoder=new xa(this,t),this._track=e}async _start(){this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController;let e=null,t=!1;const r=r=>{if(t)r.close();else{if(null===e){e=r.timestamp/1e6;const t=this._connectedTrack.output._muxer;null===t.firstMediaStreamTimestamp?(t.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-t.firstMediaStreamTimestamp-e}this._encoder.getQueueSize()>=4?r.close():this._encoder.add(new ws(r),!0).catch((e=>{t=!0,this._abortController?.abort(),this._promiseWithResolvers.reject(e),null!==this._workerTrackId&&Ua({type:"stopTrack",trackId:this._workerTrackId})}))}};if("undefined"!=typeof MediaStreamTrackProcessor){const e=new MediaStreamTrackProcessor({track:this._track}),t=new WritableStream({write:r});e.readable.pipeTo(t,{signal:this._abortController.signal}).catch((e=>{e instanceof DOMException&&"AbortError"===e.name||this._promiseWithResolvers.reject(e)}))}else{if(!await Va())throw new Error("MediaStreamTrackProcessor is required but not supported by this browser.");this._workerTrackId=Ra++,Ua({type:"videoTrack",trackId:this._workerTrackId,track:this._track},[this._track]),this._workerListener=e=>{const t=e.data;"videoFrame"===t.type&&t.trackId===this._workerTrackId?r(t.videoFrame):"error"===t.type&&t.trackId===this._workerTrackId&&this._promiseWithResolvers.reject(t.error)},Oa.addEventListener("message",this._workerListener)}}async _flushAndClose(t){this._abortController&&(this._abortController.abort(),this._abortController=null),null!==this._workerTrackId&&(e(this._workerListener),Ua({type:"stopTrack",trackId:this._workerTrackId}),await new Promise((t=>{const r=i=>{const s=i.data;"trackStopped"===s.type&&s.trackId===this._workerTrackId&&(e(this._workerListener),Oa.removeEventListener("message",this._workerListener),Oa.removeEventListener("message",r),t())};Oa.addEventListener("message",r)}))),await this._encoder.flushAndClose(t)}}class Ia extends Sa{constructor(e){if(super(),this._connectedTrack=null,!Y.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${Y.join(", ")}.`);this._codec=e}}class Ba extends Ia{constructor(e){super(e)}add(e,t){if(!(e instanceof gs))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(void 0!==t&&(!t||"object"!=typeof t))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack,e,t)}}class Ma{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new N,this.customEncoderQueueSize=0,this.encoderError=null}async add(t,r){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),null!==this.lastNumberOfChannels&&null!==this.lastSampleRate){if(t.numberOfChannels!==this.lastNumberOfChannels||t.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${t.numberOfChannels} channels at ${t.sampleRate} Hz.`)}else this.lastNumberOfChannels=t.numberOfChannels,this.lastSampleRate=t.sampleRate;if(this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(t),this.encoderInitialized||await this.ensureEncoderPromise),e(this.encoderInitialized),this.customEncoder){this.customEncoderQueueSize++;const e=t.clone(),r=this.customEncoderCallSerializer.call((()=>this.customEncoder.encode(e))).then((()=>this.customEncoderQueueSize--)).catch((e=>this.encoderError??=e)).finally((()=>{e.close()}));this.customEncoderQueueSize>=4&&await r,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(t,r);else{e(this.encoder);const i=t.toAudioData();this.encoder.encode(i),i.close(),r&&t.close(),this.encoder.encodeQueueSize>=4&&await new Promise((e=>this.encoder.addEventListener("dequeue",e,{once:!0}))),await this.muxer.mutex.currentPromise}}finally{r&&t.close()}}async doPcmEncoding(t,r){e(this.outputSampleSize),e(this.writeOutputValue);const{numberOfChannels:i,numberOfFrames:s,sampleRate:a,timestamp:n}=t,o=2048,c=[];for(let e=0;e<s;e+=o){const r=Math.min(o,t.numberOfFrames-e),s=r*i*this.outputSampleSize,a=new ArrayBuffer(s),n=new DataView(a);c.push({frameCount:r,view:n})}const u=t.allocationSize({planeIndex:0,format:"f32-planar"}),d=new Float32Array(u/Float32Array.BYTES_PER_ELEMENT);for(let e=0;e<i;e++){t.copyTo(d,{planeIndex:e,format:"f32-planar"});for(let t=0;t<c.length;t++){const{frameCount:r,view:s}=c[t];for(let a=0;a<r;a++)this.writeOutputValue(s,(a*i+e)*this.outputSampleSize,d[t*o+a])}}r&&t.close();const l={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:i,sampleRate:a}};for(let e=0;e<c.length;e++){const{frameCount:t,view:r}=c[e],i=r.buffer,s=e*o,u=new gs(new Uint8Array(i),"key",n+s/a,t/a);this.encodingConfig.onEncodedPacket?.(u,l),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,u,l)}}ensureEncoder(t){if(!this.encoderInitialized)return this.ensureEncoderPromise=(async()=>{const{numberOfChannels:r,sampleRate:i}=t,s=da({numberOfChannels:r,sampleRate:i,...this.encodingConfig});this.encodingConfig.onEncoderConfig?.(s);const a=hs.find((e=>e.supports(this.encodingConfig.codec,s)));if(a)this.customEncoder=new a,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=s,this.customEncoder.onPacket=(e,t)=>{if(!(e instanceof gs))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(void 0!==t&&(!t||"object"!=typeof t))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(e,t),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,e,t)},await this.customEncoder.init();else if(K.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if("undefined"==typeof AudioEncoder)throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(s)).supported)throw new Error(`This specific encoder configuration (${s.codec}, ${s.bitrate} bps, ${s.numberOfChannels} channels, ${s.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(e,t)=>{const r=gs.fromEncodedChunk(e);this.encodingConfig.onEncodedPacket?.(r,t),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,r,t)},error:e=>{e.stack=(new Error).stack,this.encoderError??=e}}),this.encoder.configure(s)}e(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const t=this.encodingConfig.codec,{dataType:r,sampleSize:i,littleEndian:s}=fe(t);switch(this.outputSampleSize=i,i){case 1:"unsigned"===r?this.writeOutputValue=(e,t,r)=>e.setUint8(t,F(127.5*(r+1),0,255)):"signed"===r?this.writeOutputValue=(e,t,r)=>{e.setInt8(t,F(Math.round(128*r),-128,127))}:"ulaw"===r?this.writeOutputValue=(e,t,r)=>{const i=F(Math.floor(32767*r),-32768,32767);e.setUint8(t,(e=>{let t=e,r=4096,i=0,s=12,a=0;for(t<0&&(t=-t,i=128),t+=33,t>8191&&(t=8191);(t&r)!==r&&s>=5;)r>>=1,s--;return a=t>>s-4&15,255&~(i|s-5<<4|a)})(i))}:"alaw"===r?this.writeOutputValue=(e,t,r)=>{const i=F(Math.floor(32767*r),-32768,32767);e.setUint8(t,(e=>{let t=2048,r=0,i=11,s=0,a=e;for(a<0&&(a=-a,r=128),a>4095&&(a=4095);(a&t)!==t&&i>=5;)t>>=1,i--;return s=a>>(4===i?1:i-4)&15,85^(r|i-4<<4|s)})(i))}:e(!1);break;case 2:"unsigned"===r?this.writeOutputValue=(e,t,r)=>e.setUint16(t,F(32767.5*(r+1),0,65535),s):"signed"===r?this.writeOutputValue=(e,t,r)=>e.setInt16(t,F(Math.round(32767*r),-32768,32767),s):e(!1);break;case 3:"unsigned"===r?this.writeOutputValue=(e,t,r)=>M(e,t,F(8388607.5*(r+1),0,16777215),s):"signed"===r?this.writeOutputValue=(e,t,r)=>((e,t,r,i)=>{(r=F(r,-8388608,8388607))<0&&(r=r+16777216&16777215),M(e,t,r,i)})(e,t,F(Math.round(8388607*r),-8388608,8388607),s):e(!1);break;case 4:"unsigned"===r?this.writeOutputValue=(e,t,r)=>e.setUint32(t,F(2147483647.5*(r+1),0,4294967295),s):"signed"===r?this.writeOutputValue=(e,t,r)=>e.setInt32(t,F(Math.round(2147483647*r),-2147483648,2147483647),s):"float"===r?this.writeOutputValue=(e,t,r)=>e.setFloat32(t,r,s):e(!1);break;case 8:"float"===r?this.writeOutputValue=(e,t,r)=>e.setFloat64(t,r,s):e(!1);break;default:I(i),e(!1)}}async flushAndClose(e){this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call((()=>this.customEncoder.flush())),await this.customEncoderCallSerializer.call((()=>this.customEncoder.close()))):this.encoder&&(e||await this.encoder.flush(),this.encoder.close()),this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.encoderError)throw this.encoderError}}class za extends Ia{constructor(e){ca(e),super(e.codec),this._encoder=new Ma(this,e)}add(e){if(!(e instanceof ys))throw new TypeError("audioSample must be an AudioSample.");return this._encoder.add(e,!1)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Fa extends Ia{constructor(e){ca(e),super(e.codec),this._accumulatedTime=0,this._encoder=new Ma(this,e)}async add(e){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const t=ys._fromAudioBuffer(e,this._accumulatedTime);this._accumulatedTime+=e.duration;for(const e of t)await this._encoder.add(e,!0)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Aa extends Ia{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||"audio"!==e.kind)throw new TypeError("track must be an audio MediaStreamTrack.");ca(t),super(t.codec),this._abortController=null,this._audioContext=null,this._scriptProcessorNode=null,this._promiseWithResolvers=P(),this._errorPromiseAccessed=!1,this._encoder=new Ma(this,t),this._track=e}async _start(){if(this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController,"undefined"!=typeof MediaStreamTrackProcessor){let e=null;const t=new MediaStreamTrackProcessor({track:this._track}),r=new WritableStream({write:t=>{if(null===e){e=t.timestamp/1e6;const r=this._connectedTrack.output._muxer;null===r.firstMediaStreamTimestamp?(r.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-r.firstMediaStreamTimestamp-e}this._encoder.getQueueSize()>=4?t.close():this._encoder.add(new ys(t),!0).catch((e=>{this._abortController?.abort(),this._promiseWithResolvers.reject(e)}))}});t.readable.pipeTo(r,{signal:this._abortController.signal}).catch((e=>{e instanceof DOMException&&"AbortError"===e.name||this._promiseWithResolvers.reject(e)}))}else{const e=window.AudioContext||window.webkitAudioContext;this._audioContext=new e({sampleRate:this._track.getSettings().sampleRate});const t=this._audioContext.createMediaStreamSource(new MediaStream([this._track]));this._scriptProcessorNode=this._audioContext.createScriptProcessor(4096),"suspended"===this._audioContext.state&&await this._audioContext.resume(),t.connect(this._scriptProcessorNode),this._scriptProcessorNode.connect(this._audioContext.destination);let r=!1,i=0;this._scriptProcessorNode.onaudioprocess=e=>{const t=ys._fromAudioBuffer(e.inputBuffer,i);i+=e.inputBuffer.duration;for(const e of t){if(!r){r=!0;const e=this._connectedTrack.output._muxer;null===e.firstMediaStreamTimestamp?e.firstMediaStreamTimestamp=performance.now()/1e3:this._timestampOffset=performance.now()/1e3-e.firstMediaStreamTimestamp}this._encoder.getQueueSize()>=4?e.close():this._encoder.add(e,!0).catch((e=>{this._audioContext.suspend(),this._promiseWithResolvers.reject(e)}))}}}}async _flushAndClose(t){this._abortController&&(this._abortController.abort(),this._abortController=null),this._audioContext&&(e(this._scriptProcessorNode),this._scriptProcessorNode.disconnect(),await this._audioContext.suspend()),await this._encoder.flushAndClose(t)}}const Da=()=>{const e=(e,t)=>{t?self.postMessage(e,{transfer:t}):self.postMessage(e)};e({type:"support",supported:"undefined"!=typeof MediaStreamTrackProcessor});const t=new Map,r=new Set;self.addEventListener("message",(i=>{const s=i.data;switch(s.type){case"videoTrack":{const i=new MediaStreamTrackProcessor({track:s.track}),a=new WritableStream({write:t=>{r.has(s.trackId)?t.close():e({type:"videoFrame",trackId:s.trackId,videoFrame:t},[t])}}),n=new AbortController;t.set(s.trackId,n),i.readable.pipeTo(a,{signal:n.signal}).catch((t=>{t instanceof DOMException&&"AbortError"===t.name||e({type:"error",trackId:s.trackId,error:t})}))}break;case"stopTrack":{const i=t.get(s.trackId);i&&(i.abort(),t.delete(s.trackId)),r.add(s.trackId),e({type:"trackStopped",trackId:s.trackId})}break;default:I(s)}}))};let Ra=0,Oa=null;let Wa=null;const Va=async()=>null!==Wa?Wa:(Oa||(()=>{const e=new Blob([`(${Da.toString()})()`],{type:"application/javascript"}),t=URL.createObjectURL(e);Oa=new Worker(t)})(),new Promise((t=>{e(Oa);const r=e=>{const i=e.data;"support"===i.type&&(Wa=i.supported,Oa.removeEventListener("message",r),t(i.supported))};Oa.addEventListener("message",r)}))),Ua=(t,r)=>{e(Oa),r?Oa.postMessage(t,r):Oa.postMessage(t)};class La extends Sa{constructor(e){if(super(),this._connectedTrack=null,!G.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${G.join(", ")}.`);this._codec=e}}class Na extends La{constructor(e){super(e),this._parser=new Re({codec:e,output:(e,t)=>this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack,e,t)})}add(e){if("string"!=typeof e)throw new TypeError("text must be a string.");return this._ensureValidAdd(),this._parser.parse(e),this._connectedTrack.output._muxer.mutex.currentPromise}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Ha=["video","audio","subtitle"],qa=e=>{if(!e||"object"!=typeof e)throw new TypeError("metadata must be an object.");if(void 0!==e.languageCode&&!W(e.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(void 0!==e.name&&"string"!=typeof e.name)throw new TypeError("metadata.name, when provided, must be a string.")};class $a{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new y,!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(!(e.format instanceof Ys))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof Ar))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,t={}){if(!(e instanceof va))throw new TypeError("source must be a VideoSource.");if(qa(t),void 0!==t.rotation&&![0,90,180,270].includes(t.rotation))throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&t.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(void 0!==t.frameRate&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive number.`);this._addTrack("video",e,t)}addAudioTrack(e,t={}){if(!(e instanceof Ia))throw new TypeError("source must be an AudioSource.");qa(t),this._addTrack("audio",e,t)}addSubtitleTrack(e,t={}){if(!(e instanceof La))throw new TypeError("source must be a SubtitleSource.");qa(t),this._addTrack("subtitle",e,t)}_addTrack(e,t,r){if("pending"!==this.state)throw new Error("Cannot add track after output has been started or canceled.");if(t._connectedTrack)throw new Error("Source is already used for a track.");const i=this.format.getSupportedTrackCounts(),s=this._tracks.reduce(((t,r)=>t+(r.type===e?1:0)),0),a=i[e].max;if(s===a)throw new Error(0===a?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${a} ${e} track`+(1===a?"":"s")+".");const n=i.total.max;if(this._tracks.length===n)throw new Error(`${this.format._name} does not support more than ${n} tracks`+(1===n?"":"s")+" in total.");const o={id:this._tracks.length+1,output:this,type:e,source:t,metadata:r};if("video"===o.type){const e=this.format.getSupportedVideoCodecs();if(0===e.length)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(o.source._codec));if(!e.includes(o.source._codec))throw new Error(`Codec '${o.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${e.map((e=>`'${e}'`)).join(", ")}.`+this.format._codecUnsupportedHint(o.source._codec))}else if("audio"===o.type){const e=this.format.getSupportedAudioCodecs();if(0===e.length)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(o.source._codec));if(!e.includes(o.source._codec))throw new Error(`Codec '${o.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${e.map((e=>`'${e}'`)).join(", ")}.`+this.format._codecUnsupportedHint(o.source._codec))}else if("subtitle"===o.type){const e=this.format.getSupportedSubtitleCodecs();if(0===e.length)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(o.source._codec));if(!e.includes(o.source._codec))throw new Error(`Codec '${o.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${e.map((e=>`'${e}'`)).join(", ")}.`+this.format._codecUnsupportedHint(o.source._codec))}this._tracks.push(o),t._connectedTrack=o}async start(){const e=this.format.getSupportedTrackCounts();for(const t of Ha){const r=this._tracks.reduce(((e,r)=>e+(r.type===t?1:0)),0),i=e[t].min;if(r<i)throw new Error(i===e[t].max?`${this.format._name} requires exactly ${i} ${t} track${1===i?"":"s"}.`:`${this.format._name} requires at least ${i} ${t} track${1===i?"":"s"}.`)}const t=e.total.min;if(this._tracks.length<t)throw new Error(t===e.total.max?`${this.format._name} requires exactly ${t} track`+(1===t?"":"s")+".":`${this.format._name} requires at least ${t} track`+(1===t?"":"s")+".");if("canceled"===this.state)throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const e=await this._mutex.acquire();await this._muxer.start();const t=this._tracks.map((e=>e.source._start()));await Promise.all(t),e()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){return this._cancelPromise?(console.warn("Output has already been canceled."),this._cancelPromise):"finalizing"!==this.state&&"finalized"!==this.state?this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),t=this._tracks.map((e=>e.source._flushOrWaitForOngoingClose(!0)));await Promise.all(t),await this._writer.close(),e()})():void console.warn("Output has already been finalized.")}async finalize(){if("pending"===this.state)throw new Error("Cannot finalize before starting.");if("canceled"===this.state)throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),t=this._tracks.map((e=>e.source._flushOrWaitForOngoingClose(!1)));await Promise.all(t),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}var ja="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},Ka=[],Qa=[],Ya="undefined"!=typeof Uint8Array?Uint8Array:Array,Ga=!1;function Xa(){Ga=!0;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0;t<64;++t)Ka[t]=e[t],Qa[e.charCodeAt(t)]=t;Qa["-".charCodeAt(0)]=62,Qa["_".charCodeAt(0)]=63}function Ja(e,t,r){for(var i,s,a=[],n=t;n<r;n+=3)i=(e[n]<<16)+(e[n+1]<<8)+e[n+2],a.push(Ka[(s=i)>>18&63]+Ka[s>>12&63]+Ka[s>>6&63]+Ka[63&s]);return a.join("")}function Za(e){var t;Ga||Xa();for(var r=e.length,i=r%3,s="",a=[],n=16383,o=0,c=r-i;o<c;o+=n)a.push(Ja(e,o,o+n>c?c:o+n));return 1===i?(t=e[r-1],s+=Ka[t>>2],s+=Ka[t<<4&63],s+="=="):2===i&&(t=(e[r-2]<<8)+e[r-1],s+=Ka[t>>10],s+=Ka[t>>4&63],s+=Ka[t<<2&63],s+="="),a.push(s),a.join("")}function en(e,t,r,i,s){var a,n,o=8*s-i-1,c=(1<<o)-1,u=c>>1,d=-7,l=r?s-1:0,h=r?-1:1,m=e[t+l];for(l+=h,a=m&(1<<-d)-1,m>>=-d,d+=o;d>0;a=256*a+e[t+l],l+=h,d-=8);for(n=a&(1<<-d)-1,a>>=-d,d+=i;d>0;n=256*n+e[t+l],l+=h,d-=8);if(0===a)a=1-u;else{if(a===c)return n?NaN:1/0*(m?-1:1);n+=Math.pow(2,i),a-=u}return(m?-1:1)*n*Math.pow(2,a-i)}function tn(e,t,r,i,s,a){var n,o,c,u=8*a-s-1,d=(1<<u)-1,l=d>>1,h=23===s?Math.pow(2,-24)-Math.pow(2,-77):0,m=i?0:a-1,f=i?1:-1,p=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,n=d):(n=Math.floor(Math.log(t)/Math.LN2),t*(c=Math.pow(2,-n))<1&&(n--,c*=2),(t+=n+l>=1?h/c:h*Math.pow(2,1-l))*c>=2&&(n++,c/=2),n+l>=d?(o=0,n=d):n+l>=1?(o=(t*c-1)*Math.pow(2,s),n+=l):(o=t*Math.pow(2,l-1)*Math.pow(2,s),n=0));s>=8;e[r+m]=255&o,m+=f,o/=256,s-=8);for(n=n<<s|o,u+=s;u>0;e[r+m]=255&n,m+=f,n/=256,u-=8);e[r+m-f]|=128*p}var rn={}.toString,sn=Array.isArray||function(e){return"[object Array]"==rn.call(e)};function an(){return on.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function nn(e,t){if(an()<t)throw new RangeError("Invalid typed array length");return on.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=on.prototype:(null===e&&(e=new on(t)),e.length=t),e}function on(e,t,r){if(!(on.TYPED_ARRAY_SUPPORT||this instanceof on))return new on(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return dn(this,e)}return cn(this,e,t,r)}function cn(e,t,r,i){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,i){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(i||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===i?new Uint8Array(t):void 0===i?new Uint8Array(t,r):new Uint8Array(t,r,i);on.TYPED_ARRAY_SUPPORT?(e=t).__proto__=on.prototype:e=ln(e,t);return e}(e,t,r,i):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!on.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var i=0|fn(t,r);e=nn(e,i);var s=e.write(t,r);s!==i&&(e=e.slice(0,s));return e}(e,t,r):function(e,t){if(mn(t)){var r=0|hn(t.length);return 0===(e=nn(e,r)).length||t.copy(e,0,0,r),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(i=t.length)!=i?nn(e,0):ln(e,t);if("Buffer"===t.type&&sn(t.data))return ln(e,t.data)}var i;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function un(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function dn(e,t){if(un(t),e=nn(e,t<0?0:0|hn(t)),!on.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function ln(e,t){var r=t.length<0?0:0|hn(t.length);e=nn(e,r);for(var i=0;i<r;i+=1)e[i]=255&t[i];return e}function hn(e){if(e>=an())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+an().toString(16)+" bytes");return 0|e}function mn(e){return!(null==e||!e._isBuffer)}function fn(e,t){if(mn(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var i=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return Ln(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return Nn(e).length;default:if(i)return Ln(e).length;t=(""+t).toLowerCase(),i=!0}}function pn(e,t,r){var i=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return Bn(this,t,r);case"utf8":case"utf-8":return Pn(this,t,r);case"ascii":return En(this,t,r);case"latin1":case"binary":return In(this,t,r);case"base64":return xn(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Mn(this,t,r);default:if(i)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),i=!0}}function gn(e,t,r){var i=e[t];e[t]=e[r],e[r]=i}function wn(e,t,r,i,s){if(0===e.length)return-1;if("string"==typeof r?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=s?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(s)return-1;r=e.length-1}else if(r<0){if(!s)return-1;r=0}if("string"==typeof t&&(t=on.from(t,i)),mn(t))return 0===t.length?-1:kn(e,t,r,i,s);if("number"==typeof t)return t&=255,on.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):kn(e,[t],r,i,s);throw new TypeError("val must be string, number or Buffer")}function kn(e,t,r,i,s){var a,n=1,o=e.length,c=t.length;if(void 0!==i&&("ucs2"===(i=String(i).toLowerCase())||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(e.length<2||t.length<2)return-1;n=2,o/=2,c/=2,r/=2}function u(e,t){return 1===n?e[t]:e.readUInt16BE(t*n)}if(s){var d=-1;for(a=r;a<o;a++)if(u(e,a)===u(t,-1===d?0:a-d)){if(-1===d&&(d=a),a-d+1===c)return d*n}else-1!==d&&(a-=a-d),d=-1}else for(r+c>o&&(r=o-c),a=r;a>=0;a--){for(var l=!0,h=0;h<c;h++)if(u(e,a+h)!==u(t,h)){l=!1;break}if(l)return a}return-1}function bn(e,t,r,i){r=Number(r)||0;var s=e.length-r;i?(i=Number(i))>s&&(i=s):i=s;var a=t.length;if(a%2!=0)throw new TypeError("Invalid hex string");i>a/2&&(i=a/2);for(var n=0;n<i;++n){var o=parseInt(t.substr(2*n,2),16);if(isNaN(o))return n;e[r+n]=o}return n}function yn(e,t,r,i){return Hn(Ln(t,e.length-r),e,r,i)}function Tn(e,t,r,i){return Hn(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,i)}function Sn(e,t,r,i){return Tn(e,t,r,i)}function vn(e,t,r,i){return Hn(Nn(t),e,r,i)}function Cn(e,t,r,i){return Hn(function(e,t){for(var r,i,s,a=[],n=0;n<e.length&&!((t-=2)<0);++n)i=(r=e.charCodeAt(n))>>8,s=r%256,a.push(s),a.push(i);return a}(t,e.length-r),e,r,i)}function xn(e,t,r){return 0===t&&r===e.length?Za(e):Za(e.slice(t,r))}function Pn(e,t,r){r=Math.min(e.length,r);for(var i=[],s=t;s<r;){var a,n,o,c,u=e[s],d=null,l=u>239?4:u>223?3:u>191?2:1;if(s+l<=r)switch(l){case 1:u<128&&(d=u);break;case 2:128==(192&(a=e[s+1]))&&(c=(31&u)<<6|63&a)>127&&(d=c);break;case 3:a=e[s+1],n=e[s+2],128==(192&a)&&128==(192&n)&&(c=(15&u)<<12|(63&a)<<6|63&n)>2047&&(c<55296||c>57343)&&(d=c);break;case 4:a=e[s+1],n=e[s+2],o=e[s+3],128==(192&a)&&128==(192&n)&&128==(192&o)&&(c=(15&u)<<18|(63&a)<<12|(63&n)<<6|63&o)>65535&&c<1114112&&(d=c)}null===d?(d=65533,l=1):d>65535&&(d-=65536,i.push(d>>>10&1023|55296),d=56320|1023&d),i.push(d),s+=l}return function(e){var t=e.length;if(t<=_n)return String.fromCharCode.apply(String,e);var r="",i=0;for(;i<t;)r+=String.fromCharCode.apply(String,e.slice(i,i+=_n));return r}(i)}on.TYPED_ARRAY_SUPPORT=void 0===ja.TYPED_ARRAY_SUPPORT||ja.TYPED_ARRAY_SUPPORT,an(),on.poolSize=8192,on._augment=function(e){return e.__proto__=on.prototype,e},on.from=function(e,t,r){return cn(null,e,t,r)},on.TYPED_ARRAY_SUPPORT&&(on.prototype.__proto__=Uint8Array.prototype,on.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&on[Symbol.species]),on.alloc=function(e,t,r){return function(e,t,r,i){return un(t),t<=0?nn(e,t):void 0!==r?"string"==typeof i?nn(e,t).fill(r,i):nn(e,t).fill(r):nn(e,t)}(null,e,t,r)},on.allocUnsafe=function(e){return dn(null,e)},on.allocUnsafeSlow=function(e){return dn(null,e)},on.isBuffer=function(e){return null!=e&&(!!e._isBuffer||qn(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&qn(e.slice(0,0))}(e))},on.compare=function(e,t){if(!mn(e)||!mn(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,i=t.length,s=0,a=Math.min(r,i);s<a;++s)if(e[s]!==t[s]){r=e[s],i=t[s];break}return r<i?-1:i<r?1:0},on.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},on.concat=function(e,t){if(!sn(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return on.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var i=on.allocUnsafe(t),s=0;for(r=0;r<e.length;++r){var a=e[r];if(!mn(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(i,s),s+=a.length}return i},on.byteLength=fn,on.prototype._isBuffer=!0,on.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)gn(this,t,t+1);return this},on.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)gn(this,t,t+3),gn(this,t+1,t+2);return this},on.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)gn(this,t,t+7),gn(this,t+1,t+6),gn(this,t+2,t+5),gn(this,t+3,t+4);return this},on.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?Pn(this,0,e):pn.apply(this,arguments)},on.prototype.equals=function(e){if(!mn(e))throw new TypeError("Argument must be a Buffer");return this===e||0===on.compare(this,e)},on.prototype.inspect=function(){var e="";return this.length>0&&(e=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(e+=" ... ")),"<Buffer "+e+">"},on.prototype.compare=function(e,t,r,i,s){if(!mn(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===i&&(i=0),void 0===s&&(s=this.length),t<0||r>e.length||i<0||s>this.length)throw new RangeError("out of range index");if(i>=s&&t>=r)return 0;if(i>=s)return-1;if(t>=r)return 1;if(this===e)return 0;for(var a=(s>>>=0)-(i>>>=0),n=(r>>>=0)-(t>>>=0),o=Math.min(a,n),c=this.slice(i,s),u=e.slice(t,r),d=0;d<o;++d)if(c[d]!==u[d]){a=c[d],n=u[d];break}return a<n?-1:n<a?1:0},on.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},on.prototype.indexOf=function(e,t,r){return wn(this,e,t,r,!0)},on.prototype.lastIndexOf=function(e,t,r){return wn(this,e,t,r,!1)},on.prototype.write=function(e,t,r,i){if(void 0===t)i="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)i=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===i&&(i="utf8")):(i=r,r=void 0)}var s=this.length-t;if((void 0===r||r>s)&&(r=s),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var a=!1;;)switch(i){case"hex":return bn(this,e,t,r);case"utf8":case"utf-8":return yn(this,e,t,r);case"ascii":return Tn(this,e,t,r);case"latin1":case"binary":return Sn(this,e,t,r);case"base64":return vn(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Cn(this,e,t,r);default:if(a)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),a=!0}},on.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var _n=4096;function En(e,t,r){var i="";r=Math.min(e.length,r);for(var s=t;s<r;++s)i+=String.fromCharCode(127&e[s]);return i}function In(e,t,r){var i="";r=Math.min(e.length,r);for(var s=t;s<r;++s)i+=String.fromCharCode(e[s]);return i}function Bn(e,t,r){var i=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>i)&&(r=i);for(var s="",a=t;a<r;++a)s+=Un(e[a]);return s}function Mn(e,t,r){for(var i=e.slice(t,r),s="",a=0;a<i.length;a+=2)s+=String.fromCharCode(i[a]+256*i[a+1]);return s}function zn(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function Fn(e,t,r,i,s,a){if(!mn(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>s||t<a)throw new RangeError('"value" argument is out of bounds');if(r+i>e.length)throw new RangeError("Index out of range")}function An(e,t,r,i){t<0&&(t=65535+t+1);for(var s=0,a=Math.min(e.length-r,2);s<a;++s)e[r+s]=(t&255<<8*(i?s:1-s))>>>8*(i?s:1-s)}function Dn(e,t,r,i){t<0&&(t=4294967295+t+1);for(var s=0,a=Math.min(e.length-r,4);s<a;++s)e[r+s]=t>>>8*(i?s:3-s)&255}function Rn(e,t,r,i,s,a){if(r+i>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function On(e,t,r,i,s){return s||Rn(e,0,r,4),tn(e,t,r,i,23,4),r+4}function Wn(e,t,r,i,s){return s||Rn(e,0,r,8),tn(e,t,r,i,52,8),r+8}on.prototype.slice=function(e,t){var r,i=this.length;if((e=~~e)<0?(e+=i)<0&&(e=0):e>i&&(e=i),(t=void 0===t?i:~~t)<0?(t+=i)<0&&(t=0):t>i&&(t=i),t<e&&(t=e),on.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=on.prototype;else{var s=t-e;r=new on(s,void 0);for(var a=0;a<s;++a)r[a]=this[a+e]}return r},on.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||zn(e,t,this.length);for(var i=this[e],s=1,a=0;++a<t&&(s*=256);)i+=this[e+a]*s;return i},on.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||zn(e,t,this.length);for(var i=this[e+--t],s=1;t>0&&(s*=256);)i+=this[e+--t]*s;return i},on.prototype.readUInt8=function(e,t){return t||zn(e,1,this.length),this[e]},on.prototype.readUInt16LE=function(e,t){return t||zn(e,2,this.length),this[e]|this[e+1]<<8},on.prototype.readUInt16BE=function(e,t){return t||zn(e,2,this.length),this[e]<<8|this[e+1]},on.prototype.readUInt32LE=function(e,t){return t||zn(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},on.prototype.readUInt32BE=function(e,t){return t||zn(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},on.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||zn(e,t,this.length);for(var i=this[e],s=1,a=0;++a<t&&(s*=256);)i+=this[e+a]*s;return i>=(s*=128)&&(i-=Math.pow(2,8*t)),i},on.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||zn(e,t,this.length);for(var i=t,s=1,a=this[e+--i];i>0&&(s*=256);)a+=this[e+--i]*s;return a>=(s*=128)&&(a-=Math.pow(2,8*t)),a},on.prototype.readInt8=function(e,t){return t||zn(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},on.prototype.readInt16LE=function(e,t){t||zn(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},on.prototype.readInt16BE=function(e,t){t||zn(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},on.prototype.readInt32LE=function(e,t){return t||zn(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},on.prototype.readInt32BE=function(e,t){return t||zn(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},on.prototype.readFloatLE=function(e,t){return t||zn(e,4,this.length),en(this,e,!0,23,4)},on.prototype.readFloatBE=function(e,t){return t||zn(e,4,this.length),en(this,e,!1,23,4)},on.prototype.readDoubleLE=function(e,t){return t||zn(e,8,this.length),en(this,e,!0,52,8)},on.prototype.readDoubleBE=function(e,t){return t||zn(e,8,this.length),en(this,e,!1,52,8)},on.prototype.writeUIntLE=function(e,t,r,i){(e=+e,t|=0,r|=0,i)||Fn(this,e,t,r,Math.pow(2,8*r)-1,0);var s=1,a=0;for(this[t]=255&e;++a<r&&(s*=256);)this[t+a]=e/s&255;return t+r},on.prototype.writeUIntBE=function(e,t,r,i){(e=+e,t|=0,r|=0,i)||Fn(this,e,t,r,Math.pow(2,8*r)-1,0);var s=r-1,a=1;for(this[t+s]=255&e;--s>=0&&(a*=256);)this[t+s]=e/a&255;return t+r},on.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,1,255,0),on.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},on.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,2,65535,0),on.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):An(this,e,t,!0),t+2},on.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,2,65535,0),on.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):An(this,e,t,!1),t+2},on.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,4,4294967295,0),on.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):Dn(this,e,t,!0),t+4},on.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,4,4294967295,0),on.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Dn(this,e,t,!1),t+4},on.prototype.writeIntLE=function(e,t,r,i){if(e=+e,t|=0,!i){var s=Math.pow(2,8*r-1);Fn(this,e,t,r,s-1,-s)}var a=0,n=1,o=0;for(this[t]=255&e;++a<r&&(n*=256);)e<0&&0===o&&0!==this[t+a-1]&&(o=1),this[t+a]=(e/n|0)-o&255;return t+r},on.prototype.writeIntBE=function(e,t,r,i){if(e=+e,t|=0,!i){var s=Math.pow(2,8*r-1);Fn(this,e,t,r,s-1,-s)}var a=r-1,n=1,o=0;for(this[t+a]=255&e;--a>=0&&(n*=256);)e<0&&0===o&&0!==this[t+a+1]&&(o=1),this[t+a]=(e/n|0)-o&255;return t+r},on.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,1,127,-128),on.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},on.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,2,32767,-32768),on.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):An(this,e,t,!0),t+2},on.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,2,32767,-32768),on.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):An(this,e,t,!1),t+2},on.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,4,2147483647,-2147483648),on.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):Dn(this,e,t,!0),t+4},on.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||Fn(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),on.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Dn(this,e,t,!1),t+4},on.prototype.writeFloatLE=function(e,t,r){return On(this,e,t,!0,r)},on.prototype.writeFloatBE=function(e,t,r){return On(this,e,t,!1,r)},on.prototype.writeDoubleLE=function(e,t,r){return Wn(this,e,t,!0,r)},on.prototype.writeDoubleBE=function(e,t,r){return Wn(this,e,t,!1,r)},on.prototype.copy=function(e,t,r,i){if(r||(r=0),i||0===i||(i=this.length),t>=e.length&&(t=e.length),t||(t=0),i>0&&i<r&&(i=r),i===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),e.length-t<i-r&&(i=e.length-t+r);var s,a=i-r;if(this===e&&r<t&&t<i)for(s=a-1;s>=0;--s)e[s+t]=this[s+r];else if(a<1e3||!on.TYPED_ARRAY_SUPPORT)for(s=0;s<a;++s)e[s+t]=this[s+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+a),t);return a},on.prototype.fill=function(e,t,r,i){if("string"==typeof e){if("string"==typeof t?(i=t,t=0,r=this.length):"string"==typeof r&&(i=r,r=this.length),1===e.length){var s=e.charCodeAt(0);s<256&&(e=s)}if(void 0!==i&&"string"!=typeof i)throw new TypeError("encoding must be a string");if("string"==typeof i&&!on.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var a;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{var n=mn(e)?e:Ln(new on(e,i).toString()),o=n.length;for(a=0;a<r-t;++a)this[a+t]=n[a%o]}return this};var Vn=/[^+\/0-9A-Za-z-_]/g;function Un(e){return e<16?"0"+e.toString(16):e.toString(16)}function Ln(e,t){var r;t=t||1/0;for(var i=e.length,s=null,a=[],n=0;n<i;++n){if((r=e.charCodeAt(n))>55295&&r<57344){if(!s){if(r>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(n+1===i){(t-=3)>-1&&a.push(239,191,189);continue}s=r;continue}if(r<56320){(t-=3)>-1&&a.push(239,191,189),s=r;continue}r=65536+(s-55296<<10|r-56320)}else s&&(t-=3)>-1&&a.push(239,191,189);if(s=null,r<128){if((t-=1)<0)break;a.push(r)}else if(r<2048){if((t-=2)<0)break;a.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;a.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return a}function Nn(e){return function(e){var t,r,i,s,a,n;Ga||Xa();var o=e.length;if(o%4>0)throw new Error("Invalid string. Length must be a multiple of 4");a="="===e[o-2]?2:"="===e[o-1]?1:0,n=new Ya(3*o/4-a),i=a>0?o-4:o;var c=0;for(t=0,r=0;t<i;t+=4,r+=3)s=Qa[e.charCodeAt(t)]<<18|Qa[e.charCodeAt(t+1)]<<12|Qa[e.charCodeAt(t+2)]<<6|Qa[e.charCodeAt(t+3)],n[c++]=s>>16&255,n[c++]=s>>8&255,n[c++]=255&s;return 2===a?(s=Qa[e.charCodeAt(t)]<<2|Qa[e.charCodeAt(t+1)]>>4,n[c++]=255&s):1===a&&(s=Qa[e.charCodeAt(t)]<<10|Qa[e.charCodeAt(t+1)]<<4|Qa[e.charCodeAt(t+2)]>>2,n[c++]=s>>8&255,n[c++]=255&s),n}(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(Vn,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function Hn(e,t,r,i){for(var s=0;s<i&&!(s+r>=t.length||s>=e.length);++s)t[s+r]=e[s];return s}function qn(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}class $n{constructor(){this._sizePromise=null,this.onread=null}async getSize(){return this._sizePromise??=Promise.resolve(this._retrieveSize())}}class jn extends $n{constructor(e){if(!(e instanceof ArrayBuffer||e instanceof Uint8Array))throw new TypeError("buffer must be an ArrayBuffer or Uint8Array.");super(),this._onreadCalled=!1,this._bytes=e instanceof Uint8Array?e:new Uint8Array(e),this._view=c(this._bytes)}_retrieveSize(){return this._bytes.byteLength}_read(){return this._onreadCalled||(this.onread?.(0,this._bytes.byteLength),this._onreadCalled=!0),{bytes:this._bytes,view:this._view,offset:0}}}class Kn extends $n{constructor(e,t={}){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");if(!t||"object"!=typeof t)throw new TypeError("options must be an object.");if(void 0!==t.maxCacheSize&&(!Number.isInteger(t.maxCacheSize)||t.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");super(),this._readers=new WeakMap,this._blob=e,this._orchestrator=new Zn({maxCacheSize:t.maxCacheSize??8388608,maxWorkerCount:4,runWorker:this._runWorker.bind(this),prefetchProfile:Jn.fileSystem})}_retrieveSize(){const e=this._blob.size;return this._orchestrator.fileSize=e,e}_read(e,t){return this._orchestrator.read(e,t)}async _runWorker(e){let t=this._readers.get(e);for(t||(t=this._blob.slice(e.currentPos).stream().getReader(),this._readers.set(e,t));e.currentPos<e.targetPos&&!e.aborted;){const{done:r,value:i}=await t.read();if(r){if(this._orchestrator.forgetWorker(e),e.currentPos<e.targetPos)throw new Error("Blob reader stopped unexpectedly before all requested data was read.");break}this.onread?.(e.currentPos,e.currentPos+i.length),this._orchestrator.supplyWorkerData(e,i)}}}const Qn=524288;class Yn extends $n{constructor(e,t={}){if("string"!=typeof e&&!(e instanceof URL))throw new TypeError("url must be a string or URL.");if(!t||"object"!=typeof t)throw new TypeError("options must be an object.");if(void 0!==t.requestInit&&(!t.requestInit||"object"!=typeof t.requestInit))throw new TypeError("options.requestInit, when provided, must be an object.");if(void 0!==t.getRetryDelay&&"function"!=typeof t.getRetryDelay)throw new TypeError("options.getRetryDelay, when provided, must be a function.");if(void 0!==t.maxCacheSize&&(!Number.isInteger(t.maxCacheSize)||t.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");super(),this._existingResponses=new WeakMap,this._url=e instanceof URL?e:new URL(e,"undefined"!=typeof location?location.href:void 0),this._options=t,this._getRetryDelay=t.getRetryDelay??(e=>Math.min(2**(e-2),8)),this._orchestrator=new Zn({maxCacheSize:t.maxCacheSize??67108864,maxWorkerCount:2,runWorker:this._runWorker.bind(this),prefetchProfile:Jn.network})}async _retrieveSize(){const e=new AbortController,t=await L(this._url,U(this._options.requestInit??{},{headers:{Range:"bytes=0-"},signal:e.signal}),this._getRetryDelay);if(!t.ok)throw new Error(`Error fetching ${this._url}: ${t.status} ${t.statusText}`);let r,i;if(206===t.status)i=this._getPartialLengthFromRangeResponse(t),r=this._orchestrator.createWorker(0,Qn);else{const e=t.headers.get("Content-Length");if(!e)throw new Error(`HTTP response (status ${t.status}) must surface Content-Length header.`);i=Number(e),r=this._orchestrator.createWorker(0,i),this._orchestrator.options.maxCacheSize=1/0,console.warn("HTTP server did not respond with 206 Partial Content, meaning the entire remote resource now has to be downloaded. For efficient media file streaming across a network, please make sure your server supports range requests.")}return this._orchestrator.fileSize=i,this._existingResponses.set(r,{response:t,abortController:e}),this._orchestrator.runWorker(r),i}_read(e,t){return this._orchestrator.read(e,t)}async _runWorker(t){for(;!t.aborted;){const r=this._existingResponses.get(t);this._existingResponses.delete(t);let i=r?.abortController,s=r?.response;if(i||(i=new AbortController,s=await L(this._url,U(this._options.requestInit??{},{headers:{Range:`bytes=${t.currentPos}-`},signal:i.signal}),this._getRetryDelay)),e(s),!s.ok)throw new Error(`Error fetching ${this._url}: ${s.status} ${s.statusText}`);if(t.currentPos>0&&206!==s.status)throw new Error("HTTP server did not respond with 206 Partial Content to a range request. To enable efficient media file streaming across a network, please make sure your server supports range requests.");const a=this._getPartialLengthFromRangeResponse(s),n=t.targetPos-t.currentPos;if(a<n)throw new Error(`HTTP response unexpectedly too short: Needed at least ${n} bytes, got only ${a}.`);if(!s.body)throw new Error("Missing HTTP response body.");const o=s.body.getReader();for(;;){let e;try{e=await o.read()}catch(e){const t=this._getRetryDelay(1);if(null!==t){console.error("Error while reading response stream. Attempting to resume.",e),await new Promise((e=>setTimeout(e,1e3*t)));break}throw e}const{done:r,value:s}=e;if(r){if(this._orchestrator.forgetWorker(t),t.currentPos<t.targetPos)throw new Error("Response stream reader stopped unexpectedly before all requested data was read.");return}if(this.onread?.(t.currentPos,t.currentPos+s.length),this._orchestrator.supplyWorkerData(t,s),t.currentPos>=t.targetPos||t.aborted)return void i.abort()}}}_getPartialLengthFromRangeResponse(e){const t=e.headers.get("Content-Range");if(t){const e=/\/(\d+)/.exec(t);if(e)return Number(e[1]);throw new Error(`Invalid Content-Range header: ${t}`)}{const t=e.headers.get("Content-Length");if(t)return Number(t);throw new Error("Partial HTTP response (status 206) must surface either Content-Range or Content-Length header.")}}}class Gn extends $n{constructor(t,r={}){if("string"!=typeof t)throw new TypeError("filePath must be a string.");if(!r||"object"!=typeof r)throw new TypeError("options must be an object.");if(void 0!==r.maxCacheSize&&(!Number.isInteger(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");super();let i=null;this._streamSource=new Xn({getSize:async()=>{const e=await import("node:fs/promises");i=await e.open(t,"r");return(await i.stat()).size},read:async(t,r)=>{e(i);const s=on.alloc(r-t);return await i.read(s,0,r-t,t),s},maxCacheSize:r.maxCacheSize,prefetchProfile:"fileSystem"})}_read(e,t){return this._streamSource._read(e,t)}_retrieveSize(){return this._streamSource._retrieveSize()}}class Xn extends $n{constructor(e){if(!e||"object"!=typeof e)throw new TypeError("options must be an object.");if("function"!=typeof e.read)throw new TypeError("options.read must be a function.");if("function"!=typeof e.getSize)throw new TypeError("options.getSize must be a function.");if(void 0!==e.maxCacheSize&&(!Number.isInteger(e.maxCacheSize)||e.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative integer.");if(e.prefetchProfile&&!["none","fileSystem","network"].includes(e.prefetchProfile))throw new TypeError("options.prefetchProfile, when provided, must be one of 'none', 'fileSystem' or 'network'.");super(),this._options=e,this._orchestrator=new Zn({maxCacheSize:e.maxCacheSize??8388608,maxWorkerCount:2,prefetchProfile:Jn[e.prefetchProfile??"none"],runWorker:this._runWorker.bind(this)})}_retrieveSize(){const e=this._options.getSize();if(e instanceof Promise)return e.then((e=>{if(!Number.isInteger(e)||e<0)throw new TypeError("options.getSize must return or resolve to a non-negative integer.");return this._orchestrator.fileSize=e,e}));if(!Number.isInteger(e)||e<0)throw new TypeError("options.getSize must return or resolve to a non-negative integer.");return this._orchestrator.fileSize=e,e}_read(e,t){return this._orchestrator.read(e,t)}async _runWorker(e){for(;e.currentPos<e.targetPos&&!e.aborted;){const t=e.currentPos,r=e.targetPos;let i=this._options.read(e.currentPos,r);if(i instanceof Promise&&(i=await i),i instanceof Uint8Array){if(i.length!==r-e.currentPos)throw new Error(`options.read returned a Uint8Array with unexpected length: Requested ${r-e.currentPos} bytes, but got ${i.length}.`);this.onread?.(e.currentPos,e.currentPos+i.length),this._orchestrator.supplyWorkerData(e,i)}else{if(!(i instanceof ReadableStream))throw new TypeError("options.read must return or resolve to a Uint8Array or a ReadableStream.");{const s=i.getReader();for(;;){const{done:i,value:a}=await s.read();if(i){if(e.currentPos<r)throw new Error(`ReadableStream returned by options.read ended before supplying enough data. Requested ${r-t} bytes, but got ${e.currentPos-t}`);break}if(!(a instanceof Uint8Array))throw new TypeError("ReadableStream returned by options.read must yield Uint8Array chunks.");if(this.onread?.(e.currentPos,e.currentPos+a.length),this._orchestrator.supplyWorkerData(e,a),e.currentPos>=r||e.aborted)break}}}}}}const Jn={none:(e,t)=>({start:e,end:t}),fileSystem:(e,t)=>{const r=65536;return{start:e=Math.floor((e-r)/r)*r,end:t=Math.ceil((t+r)/r)*r}},network:(e,t,r)=>{const i=65536;e=Math.max(0,Math.floor((e-i)/i)*i);for(const i of r){const r=8388608,s=Math.max((i.startPos+i.targetPos)/2,i.targetPos-r);if($(e,t,s,i.targetPos)){const e=i.targetPos-i.startPos,s=Math.ceil((e+1)/r)*r,a=2**Math.ceil(Math.log2(e+1)),n=Math.min(a,s);t=Math.max(t,i.startPos+n)}}return{start:e,end:t=Math.max(t,e+Qn)}}};class Zn{constructor(e){this.options=e,this.fileSize=null,this.nextAge=0,this.workers=[],this.cache=[],this.currentCacheSize=0}read(t,r){e(null!==this.fileSize);const i=this.options.prefetchProfile(t,r,this.workers),s=Math.max(i.start,0),a=Math.min(i.end,this.fileSize);e(s<=t&&r<=a);let n=null;const o=C(this.cache,t,(e=>e.start)),u=-1!==o?this.cache[o]:null;u&&u.start<=t&&r<=u.end&&(u.age=this.nextAge++,n={bytes:u.bytes,view:u.view,offset:u.start});const d=C(this.cache,s,(e=>e.start)),l=n?null:new Uint8Array(r-t);let h=0,m=s;const f=[];if(-1!==d){for(let i=d;i<this.cache.length;i++){const n=this.cache[i];if(n.start>=a)break;if(n.end<=s)continue;const o=Math.max(s,n.start),c=Math.min(a,n.end);if(e(o<=c),m<o&&f.push({start:m,end:o}),m=c,l){const e=Math.max(t,n.start),i=Math.min(r,n.end);if(e<i){const r=e-t;l.set(n.bytes.subarray(e-n.start,i-n.start),r),r===h&&(h=i-t)}}n.age=this.nextAge++}m<a&&f.push({start:m,end:a})}else f.push({start:s,end:a});if(l&&h>=l.length&&(n={bytes:l,view:c(l),offset:t}),0===f.length)return e(n),n;const{promise:p,resolve:g,reject:w}=P(),k=[];for(const e of f){const i=Math.max(t,e.start),s=Math.min(r,e.end);i===e.start&&s===e.end?k.push(e):i<s&&k.push({start:i,end:s})}for(const e of f){const r=l&&{start:t,bytes:l,holes:k,resolve:g,reject:w};let i=!1;for(const t of this.workers){const s=2**17;if($(e.start-s,e.start,t.currentPos,t.targetPos)){t.targetPos=Math.max(t.targetPos,e.end),i=!0,r&&!t.pendingSlices.includes(r)&&t.pendingSlices.push(r),t.running||this.runWorker(t);break}}if(!i){const t=this.createWorker(e.start,e.end);r&&(t.pendingSlices=[r]),this.runWorker(t)}}return n||(e(l),n=p.then((e=>({bytes:e,view:c(e),offset:t})))),n}createWorker(e,t){const r={startPos:e,currentPos:e,targetPos:t,running:!1,aborted:!1,pendingSlices:[],age:this.nextAge++};for(this.workers.push(r);this.workers.length>this.options.maxWorkerCount;){let e=0,t=this.workers[0];for(let r=1;r<this.workers.length;r++){const i=this.workers[r];i.age<t.age&&(e=r,t=i)}if(t.running&&t.pendingSlices.length>0)break;t.aborted=!0,this.workers.splice(e,1)}return r}runWorker(t){e(!t.running),e(t.currentPos<t.targetPos),t.running=!0,t.age=this.nextAge++,this.options.runWorker(t).catch((e=>{if(!(t.pendingSlices.length>0))throw e;t.pendingSlices.forEach((t=>t.reject(e))),t.pendingSlices.length=0})).finally((()=>{t.running=!1}))}supplyWorkerData(e,t){const r=e.currentPos,i=r+t.length;this.insertIntoCache({start:r,end:i,bytes:t,view:c(t),age:this.nextAge++}),e.currentPos+=t.length,e.targetPos=Math.max(e.targetPos,e.currentPos);for(let s=0;s<e.pendingSlices.length;s++){const a=e.pendingSlices[s],n=Math.max(r,a.start),o=Math.min(i,a.start+a.bytes.length);n<o&&a.bytes.set(t.subarray(n-r,o-r),n-a.start);for(let e=0;e<a.holes.length;e++){const t=a.holes[e];r<=t.start&&i>t.start&&(t.start=i),t.end<=t.start&&(a.holes.splice(e,1),e--)}0===a.holes.length&&(a.resolve(a.bytes),e.pendingSlices.splice(s,1),s--)}for(let t=0;t<this.workers.length;t++){const s=this.workers[t];e===s||s.running||$(r,i,s.currentPos,s.targetPos)&&(this.workers.splice(t,1),t--)}}forgetWorker(t){const r=this.workers.indexOf(t);e(-1!==r),this.workers.splice(r,1)}insertIntoCache(t){if(0===this.options.maxCacheSize)return;let r=C(this.cache,t.start,(e=>e.start))+1;if(r>0){const e=this.cache[r-1];if(e.end>=t.end)return;if(e.end>t.start){const i=new Uint8Array(t.end-e.start);i.set(e.bytes,0),i.set(t.bytes,t.start-e.start),this.currentCacheSize+=t.end-e.end,e.bytes=i,e.view=c(i),e.end=t.end,r--,t=e}else this.cache.splice(r,0,t),this.currentCacheSize+=t.bytes.length}else this.cache.splice(r,0,t),this.currentCacheSize+=t.bytes.length;for(let e=r+1;e<this.cache.length;e++){const r=this.cache[e];if(t.end<=r.start)break;if(t.end>=r.end){this.cache.splice(e,1),this.currentCacheSize-=r.bytes.length,e--;continue}const i=new Uint8Array(r.end-t.start);i.set(t.bytes,0),i.set(r.bytes,r.start-t.start),this.currentCacheSize-=t.end-r.start,t.bytes=i,t.view=c(i),t.end=r.end,this.cache.splice(e,1);break}for(;this.currentCacheSize>this.options.maxCacheSize;)if(this.cache.length>1){let e=0,t=this.cache[0];for(let r=1;r<this.cache.length;r++){const i=this.cache[r];i.age<t.age&&(e=r,t=i)}this.cache.splice(e,1),this.currentCacheSize-=t.bytes.length}else{const t=this.cache[0];e(t.bytes.length>this.options.maxCacheSize),t.bytes=t.bytes.slice(0,this.options.maxCacheSize),t.view=c(t.bytes),t.end=t.start+t.bytes.length,this.currentCacheSize=t.bytes.length}}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class eo extends ss{constructor(e){super(e),this.moovSlice=null,this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.fragments=[],this.currentFragment=null,this.fragmentLookupMutex=new y,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map((e=>e.computeDuration())));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.tracks.map((e=>e.inputTrack))}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map((e=>e.inputTrack.getCodecParameterString())));return Or({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some((e=>"video"===e.info?.type)),hasAudio:this.tracks.some((e=>"audio"===e.info?.type)),codecStrings:e.filter(Boolean)})}readMetadata(){return this.metadataPromise??=(async()=>{let t=0;for(;t<this.reader.fileSize;){let e=this.reader.requestSliceRange(t,8,ti);if(e instanceof Promise&&(e=await e),!e)break;const r=t,i=ri(e);if(!i)break;if("ftyp"===i.name){const t=ei(e,4);this.isQuickTime="qt  "===t}else if("moov"===i.name){let t=this.reader.requestSlice(e.filePos,i.contentSize);if(t instanceof Promise&&(t=await t),!t)break;this.moovSlice=t,this.readContiguousBoxes(this.moovSlice);for(const e of this.tracks){const t=e.editListPreviousSegmentDurations/this.movieTimescale;e.editListOffset-=Math.round(t*e.timescale)}break}t=r+i.totalSize}if(this.isFragmented){let t=this.reader.requestSlice(this.reader.fileSize-4,4);t instanceof Promise&&(t=await t),e(t);const r=Kr(t),i=this.reader.fileSize-r;if(i>=0&&i<=this.reader.fileSize-ti){let e=this.reader.requestSliceRange(i,8,ti);if(e instanceof Promise&&(e=await e),e){const t=ri(e);if(t&&"mfra"===t.name){let r=this.reader.requestSlice(e.filePos,t.contentSize);r instanceof Promise&&(r=await r),r&&this.readContiguousBoxes(r)}}}}})()}getSampleTableForTrack(t){if(t.sampleTable)return t.sampleTable;const i={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};t.sampleTable=i,e(this.moovSlice);const s=this.moovSlice.slice(t.sampleTableByteOffset);this.currentTrack=t,this.traverseBox(s),this.currentTrack=null;if("audio"===t.info?.type&&t.info.codec&&K.includes(t.info.codec)&&0===i.sampleCompositionTimeOffsets.length){e("audio"===t.info?.type);const s=fe(t.info.codec),a=[],n=[];for(let e=0;e<i.sampleToChunk.length;e++){const o=i.sampleToChunk[e],c=i.sampleToChunk[e+1],u=(c?c.startChunkIndex:i.chunkOffsets.length)-o.startChunkIndex;for(let e=0;e<u;e++){const c=o.startSampleIndex+e*o.samplesPerChunk,u=c+o.samplesPerChunk,d=C(i.sampleTimingEntries,c,(e=>e.startIndex)),l=i.sampleTimingEntries[d],h=C(i.sampleTimingEntries,u,(e=>e.startIndex)),m=i.sampleTimingEntries[h],f=l.startDecodeTimestamp+(c-l.startIndex)*l.delta,p=m.startDecodeTimestamp+(u-m.startIndex)*m.delta-f,g=r(a);g&&g.delta===p?g.count++:a.push({startIndex:o.startChunkIndex+e,startDecodeTimestamp:f,count:1,delta:p});const w=o.samplesPerChunk*s.sampleSize*t.info.numberOfChannels;n.push(w)}o.startSampleIndex=o.startChunkIndex,o.samplesPerChunk=1}i.sampleTimingEntries=a,i.sampleSizes=n}if(i.sampleCompositionTimeOffsets.length>0){i.presentationTimestamps=[];for(const e of i.sampleTimingEntries)for(let t=0;t<e.count;t++)i.presentationTimestamps.push({presentationTimestamp:e.startDecodeTimestamp+t*e.delta,sampleIndex:e.startIndex+t});for(const e of i.sampleCompositionTimeOffsets)for(let t=0;t<e.count;t++){const r=e.startIndex+t,s=i.presentationTimestamps[r];s&&(s.presentationTimestamp+=e.offset)}i.presentationTimestamps.sort(((e,t)=>e.presentationTimestamp-t.presentationTimestamp)),i.presentationTimestampIndexMap=Array(i.presentationTimestamps.length).fill(-1);for(let e=0;e<i.presentationTimestamps.length;e++)i.presentationTimestampIndexMap[i.presentationTimestamps[e].sampleIndex]=e}return i}async readFragment(t){let r=this.reader.requestSliceRange(t,8,ti);r instanceof Promise&&(r=await r),e(r);const i=ri(r);e("moof"===i?.name);let s=this.reader.requestSlice(t,i.totalSize);s instanceof Promise&&(s=await s),e(s),this.traverseBox(s);const a=v(this.fragments,t,(e=>e.moofOffset));e(-1!==a);const n=this.fragments[a];e(n.moofOffset===t);for(const[r,i]of n.trackData){if(i.startTimestampIsFinal)continue;const s=this.tracks.find((e=>e.id===r));let a=0,n=null,o=null;const c=C(s.fragments,t-1,(e=>e.moofOffset));-1!==c&&(n=s.fragments[c],o=n,a=n.moofOffset+n.moofSize);let u=0===a;for(;a<=t-8;){if(n?.nextFragment)n=n.nextFragment,a=n.moofOffset+n.moofSize;else{let e=this.reader.requestSliceRange(a,8,ti);if(e instanceof Promise&&(e=await e),!e)break;const t=a,r=ri(e);if(!r)break;if("moof"===r.name){const e=v(this.fragments,t,(e=>e.moofOffset));let r;r=-1===e?await this.readFragment(t):this.fragments[e],n&&(n.nextFragment=r),n=r,u&&(r.isKnownToBeFirstFragment=!0,u=!1)}a=t+r.totalSize}n&&n.trackData.has(r)&&(o=n)}if(o){const t=o.trackData.get(r);e(t.startTimestampIsFinal),co(i,t.endTimestamp)}i.startTimestampIsFinal=!0}return n}readContiguousBoxes(e){const t=e.filePos;for(;e.filePos-t<=e.length-8;){if(!this.traverseBox(e))break}}traverseBox(i){const a=i.filePos,n=ri(i);if(!n)return!1;const o=i.filePos,c=a+n.totalSize;switch(n.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":case"udta":case"wave":this.readContiguousBoxes(i.slice(o,n.contentSize));break;case"mvhd":{const e=Lr(i);i.skip(3),1===e?(i.skip(16),this.movieTimescale=Kr(i),this.movieDurationInTimescale=Xr(i)):(i.skip(8),this.movieTimescale=Kr(i),this.movieDurationInTimescale=Kr(i))}break;case"trak":{const e={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,internalCodecId:null,name:null,languageCode:A,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[],fragmentsWithKeyFrame:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=e,this.readContiguousBoxes(i.slice(o,n.contentSize)),-1!==e.id&&-1!==e.timescale&&null!==e.info)if("video"===e.info.type&&-1!==e.info.width){const t=e;e.inputTrack=new Ls(new ro(t)),this.tracks.push(e)}else if("audio"===e.info.type&&-1!==e.info.numberOfChannels){const t=e;e.inputTrack=new Ns(new io(t)),this.tracks.push(e)}this.currentTrack=null}break;case"tkhd":{const r=this.currentTrack;e(r);const s=Lr(i);if(!!!(1&qr(i)))break;if(0===s)i.skip(8),r.id=Kr(i),i.skip(4),r.durationInMovieTimescale=Kr(i);else{if(1!==s)throw new Error(`Incorrect track header version ${s}.`);i.skip(16),r.id=Kr(i),i.skip(4),r.durationInMovieTimescale=Xr(i)}i.skip(16);const a=[ii(i),ii(i),si(i),ii(i),ii(i),si(i),ii(i),ii(i),si(i)],n=t(R(uo(a),90));e(0===n||90===n||180===n||270===n),r.rotation=n}break;case"elst":{const t=this.currentTrack;e(t);const r=Lr(i);i.skip(3);let s=!1,a=0;const n=Kr(i);for(let e=0;e<n;e++){const e=1===r?Xr(i):Kr(i),n=1===r?Jr(i):Yr(i),o=ii(i);if(0!==e){if(s){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(-1!==n){if(1!==o){console.warn("Unsupported edit list entry: media rate must be 1.");break}t.editListPreviousSegmentDurations=a,t.editListOffset=n,s=!0}else a+=e}}}break;case"mdhd":{const t=this.currentTrack;e(t);const r=Lr(i);i.skip(3),0===r?(i.skip(8),t.timescale=Kr(i),t.durationInMediaTimescale=Kr(i)):1===r&&(i.skip(16),t.timescale=Kr(i),t.durationInMediaTimescale=Xr(i));let s=Hr(i);if(s>0){t.languageCode="";for(let e=0;e<3;e++)t.languageCode=String.fromCharCode(96+(31&s))+t.languageCode,s>>=5;W(t.languageCode)||(t.languageCode=A)}}break;case"hdlr":{const t=this.currentTrack;e(t),i.skip(8);const r=ei(i,4);"vide"===r?t.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:"soun"===r&&(t.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const t=this.currentTrack;e(t),t.sampleTableByteOffset=a,this.readContiguousBoxes(i.slice(o,n.contentSize))}break;case"stsd":{const t=this.currentTrack;if(e(t),null===t.info||t.sampleTable)break;const r=Lr(i);i.skip(3);const s=Kr(i);for(let e=0;e<s;e++){const e=i.filePos,s=ri(i);if(!s)break;t.internalCodecId=s.name;const a=s.name.toLowerCase();if("video"===t.info.type)"avc1"===a?t.info.codec="avc":"hvc1"===a||"hev1"===a?t.info.codec="hevc":"vp08"===a?t.info.codec="vp8":"vp09"===a?t.info.codec="vp9":"av01"===a?t.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${s.name}').`),i.skip(24),t.info.width=Hr(i),t.info.height=Hr(i),i.skip(50),this.readContiguousBoxes(i.slice(i.filePos,e+s.totalSize-i.filePos));else{"mp4a"===a||("opus"===a?t.info.codec="opus":"flac"===a?t.info.codec="flac":"twos"===a||"sowt"===a||"raw "===a||"in24"===a||"in32"===a||"fl32"===a||"fl64"===a||"lpcm"===a||"ipcm"===a||"fpcm"===a||("ulaw"===a?t.info.codec="ulaw":"alaw"===a?t.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${s.name}').`))),i.skip(8);const n=Hr(i);i.skip(6);let o=Hr(i),c=Hr(i);i.skip(4);let u=Kr(i)/65536;if(0===r&&n>0)if(1===n)i.skip(4),c=8*Kr(i),i.skip(8);else if(2===n){i.skip(4),u=Zr(i),o=Kr(i),i.skip(4),c=Kr(i);const e=Kr(i);if(i.skip(8),"lpcm"===a){const r=c+7>>3,i=Boolean(1&e),s=Boolean(2&e),a=4&e?-1:0;c>0&&c<=64&&(i?32===c&&(t.info.codec=s?"pcm-f32be":"pcm-f32"):a&1<<r-1?1===r?t.info.codec="pcm-s8":2===r?t.info.codec=s?"pcm-s16be":"pcm-s16":3===r?t.info.codec=s?"pcm-s24be":"pcm-s24":4===r&&(t.info.codec=s?"pcm-s32be":"pcm-s32"):1===r&&(t.info.codec="pcm-u8")),null===t.info.codec&&console.warn("Unsupported PCM format.")}}t.info.numberOfChannels=o,t.info.sampleRate=u,"twos"===a?8===c?t.info.codec="pcm-s8":16===c?t.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${c} for codec 'twos'.`),t.info.codec=null):"sowt"===a?8===c?t.info.codec="pcm-s8":16===c?t.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${c} for codec 'sowt'.`),t.info.codec=null):"raw "===a?t.info.codec="pcm-u8":"in24"===a?t.info.codec="pcm-s24be":"in32"===a?t.info.codec="pcm-s32be":"fl32"===a?t.info.codec="pcm-f32be":"fl64"===a?t.info.codec="pcm-f64be":"ipcm"===a?t.info.codec="pcm-s16be":"fpcm"===a&&(t.info.codec="pcm-f32be"),this.readContiguousBoxes(i.slice(i.filePos,e+s.totalSize-i.filePos))}}}break;case"avcC":{const t=this.currentTrack;e(t&&t.info),t.info.codecDescription=Ur(i,n.contentSize)}break;case"hvcC":{const t=this.currentTrack;e(t&&t.info),t.info.codecDescription=Ur(i,n.contentSize)}break;case"vpcC":{const t=this.currentTrack;e(t&&"video"===t.info?.type),i.skip(4);const r=Lr(i),s=Lr(i),a=Lr(i),n=a>>4,o=a>>1&7,c=1&a,u=Lr(i),d=Lr(i),l=Lr(i);t.info.vp9CodecInfo={profile:r,level:s,bitDepth:n,chromaSubsampling:o,videoFullRangeFlag:c,colourPrimaries:u,transferCharacteristics:d,matrixCoefficients:l}}break;case"av1C":{const t=this.currentTrack;e(t&&"video"===t.info?.type),i.skip(1);const r=Lr(i),s=r>>5,a=31&r,n=Lr(i),o=n>>7,c=n>>6&1,u=n>>4&1,d=n>>3&1,l=n>>2&1,h=3&n,m=2===s&&c?n>>5&1?12:10:c?10:8;t.info.av1CodecInfo={profile:s,level:a,tier:o,bitDepth:m,monochrome:u,chromaSubsamplingX:d,chromaSubsamplingY:l,chromaSamplePosition:h}}break;case"colr":{const t=this.currentTrack;e(t&&"video"===t.info?.type);if("nclx"!==ei(i,4))break;const r=Hr(i),s=Hr(i),a=Hr(i),n=Boolean(128&Lr(i));t.info.colorSpace={primaries:m[r],transfer:p[s],matrix:w[a],fullRange:n}}break;case"esds":{const t=this.currentTrack;e(t&&"audio"===t.info?.type),i.skip(4);e(3===Lr(i)),ai(i),i.skip(2);const r=Lr(i),s=!!(64&r),a=!!(32&r);if(!!(128&r)&&i.skip(2),s){const e=Lr(i);i.skip(e)}a&&i.skip(2);e(4===Lr(i));const n=ai(i),o=i.filePos,c=Lr(i);if(64===c||103===c?(t.info.codec="aac",t.info.aacCodecInfo={isMpeg2:103===c}):105===c||107===c?t.info.codec="mp3":221===c?t.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${c}) - discarding track.`),i.skip(12),n>i.filePos-o){e(5===Lr(i));const r=ai(i);if(t.info.codecDescription=Ur(i,r),"aac"===t.info.codec){const e=le(t.info.codecDescription);null!==e.numberOfChannels&&(t.info.numberOfChannels=e.numberOfChannels),null!==e.sampleRate&&(t.info.sampleRate=e.sampleRate)}}}break;case"enda":{const t=this.currentTrack;e(t&&"audio"===t.info?.type);255&Hr(i)&&("pcm-s16be"===t.info.codec?t.info.codec="pcm-s16":"pcm-s24be"===t.info.codec?t.info.codec="pcm-s24":"pcm-s32be"===t.info.codec?t.info.codec="pcm-s32":"pcm-f32be"===t.info.codec?t.info.codec="pcm-f32":"pcm-f64be"===t.info.codec&&(t.info.codec="pcm-f64"))}break;case"pcmC":{const t=this.currentTrack;e(t&&"audio"===t.info?.type),i.skip(4);const r=Lr(i),s=Boolean(1&r),a=Lr(i);"pcm-s16be"===t.info.codec?s?16===a?t.info.codec="pcm-s16":24===a?t.info.codec="pcm-s24":32===a?t.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${a}.`),t.info.codec=null):16===a?t.info.codec="pcm-s16be":24===a?t.info.codec="pcm-s24be":32===a?t.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${a}.`),t.info.codec=null):"pcm-f32be"===t.info.codec&&(s?32===a?t.info.codec="pcm-f32":64===a?t.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${a}.`),t.info.codec=null):32===a?t.info.codec="pcm-f32be":64===a?t.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${a}.`),t.info.codec=null));break}case"dOps":{const t=this.currentTrack;e(t&&"audio"===t.info?.type),i.skip(1);const r=Lr(i),s=Hr(i),a=Kr(i),n=$r(i),o=Lr(i);let c;c=0!==o?Ur(i,2+r):new Uint8Array(0);const u=new Uint8Array(19+c.byteLength),d=new DataView(u.buffer);d.setUint32(0,1332770163,!1),d.setUint32(4,1214603620,!1),d.setUint8(8,1),d.setUint8(9,r),d.setUint16(10,s,!0),d.setUint32(12,a,!0),d.setInt16(16,n,!0),d.setUint8(18,o),u.set(c,19),t.info.codecDescription=u,t.info.numberOfChannels=r,t.info.sampleRate=a}break;case"dfLa":{const t=this.currentTrack;e(t&&"audio"===t.info?.type),i.skip(4);const r=127,s=128,a=i.filePos;for(;i.filePos<c;){const e=Lr(i),a=qr(i);if(0===(e&r)){i.skip(10);const e=Kr(i),r=e>>>12,s=1+(e>>9&7);t.info.sampleRate=r,t.info.numberOfChannels=s,i.skip(20)}else i.skip(a);if(e&s)break}const n=i.filePos;i.filePos=a;const o=Ur(i,n-a),u=new Uint8Array(4+o.byteLength);new DataView(u.buffer).setUint32(0,1716281667,!1),u.set(o,4),t.info.codecDescription=u}break;case"stts":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4);const r=Kr(i);let s=0,a=0;for(let e=0;e<r;e++){const e=Kr(i),r=Kr(i);t.sampleTable.sampleTimingEntries.push({startIndex:s,startDecodeTimestamp:a,count:e,delta:r}),s+=e,a+=e*r}}break;case"ctts":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4);const r=Kr(i);let s=0;for(let e=0;e<r;e++){const e=Kr(i),r=Yr(i);t.sampleTable.sampleCompositionTimeOffsets.push({startIndex:s,count:e,offset:r}),s+=e}}break;case"stsz":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4);const r=Kr(i),s=Kr(i);if(0===r)for(let e=0;e<s;e++){const e=Kr(i);t.sampleTable.sampleSizes.push(e)}else t.sampleTable.sampleSizes.push(r)}break;case"stz2":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4),i.skip(3);const r=Lr(i),a=Kr(i),n=Ur(i,Math.ceil(a*r/8)),o=new s(n);for(let e=0;e<a;e++){const e=o.readBits(r);t.sampleTable.sampleSizes.push(e)}}break;case"stss":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4),t.sampleTable.keySampleIndices=[];const r=Kr(i);for(let e=0;e<r;e++){const e=Kr(i)-1;t.sampleTable.keySampleIndices.push(e)}0!==t.sampleTable.keySampleIndices[0]&&t.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4);const r=Kr(i);for(let e=0;e<r;e++){const e=Kr(i)-1,r=Kr(i),s=Kr(i);t.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:e,samplesPerChunk:r,sampleDescriptionIndex:s})}let s=0;for(let e=0;e<t.sampleTable.sampleToChunk.length;e++)if(t.sampleTable.sampleToChunk[e].startSampleIndex=s,e<t.sampleTable.sampleToChunk.length-1){s+=(t.sampleTable.sampleToChunk[e+1].startChunkIndex-t.sampleTable.sampleToChunk[e].startChunkIndex)*t.sampleTable.sampleToChunk[e].samplesPerChunk}}break;case"stco":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4);const r=Kr(i);for(let e=0;e<r;e++){const e=Kr(i);t.sampleTable.chunkOffsets.push(e)}}break;case"co64":{const t=this.currentTrack;if(e(t),!t.sampleTable)break;i.skip(4);const r=Kr(i);for(let e=0;e<r;e++){const e=Xr(i);t.sampleTable.chunkOffsets.push(e)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(i.slice(o,n.contentSize));break;case"mehd":{const e=Lr(i);i.skip(3);const t=1===e?Xr(i):Kr(i);this.movieDurationInTimescale=t}break;case"trex":{i.skip(4);const e=Kr(i),t=Kr(i),r=Kr(i),s=Kr(i),a=Kr(i);this.fragmentTrackDefaults.push({trackId:e,defaultSampleDescriptionIndex:t,defaultSampleDuration:r,defaultSampleSize:s,defaultSampleFlags:a})}break;case"tfra":{const e=Lr(i);i.skip(3);const t=Kr(i),r=this.tracks.find((e=>e.id===t));if(!r)break;r.fragmentLookupTable=[];const s=Kr(i),a=(12&s)>>2,n=3&s,o=[Lr,Hr,qr,Kr],c=o[(48&s)>>4],u=o[a],d=o[n],l=Kr(i);for(let t=0;t<l;t++){const t=1===e?Xr(i):Kr(i),s=1===e?Xr(i):Kr(i);c(i),u(i),d(i),r.fragmentLookupTable.push({timestamp:t,moofOffset:s})}}break;case"moof":this.currentFragment={moofOffset:a,moofSize:n.totalSize,implicitBaseDataOffset:a,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null,isKnownToBeFirstFragment:!1},this.readContiguousBoxes(i.slice(o,n.contentSize)),x(this.fragments,this.currentFragment,(e=>e.moofOffset));for(const[,e]of this.currentFragment.trackData){const t=e.samples[0],i=r(e.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,t.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,i.byteOffset+i.byteSize)}this.currentFragment=null;break;case"traf":if(e(this.currentFragment),this.readContiguousBoxes(i.slice(o,n.contentSize)),this.currentTrack){const t=this.currentFragment.trackData.get(this.currentTrack.id);if(t){x(this.currentTrack.fragments,this.currentFragment,(e=>e.moofOffset));null!==t.firstKeyFrameTimestamp&&x(this.currentTrack.fragmentsWithKeyFrame,this.currentFragment,(e=>e.moofOffset));const{currentFragmentState:r}=this.currentTrack;e(r),null!==r.startTimestamp&&(co(t,r.startTimestamp),t.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{e(this.currentFragment),i.skip(1);const t=qr(i),r=Boolean(1&t),s=Boolean(2&t),a=Boolean(8&t),n=Boolean(16&t),o=Boolean(32&t),c=Boolean(65536&t),u=Boolean(131072&t),d=Kr(i),l=this.tracks.find((e=>e.id===d));if(!l)break;const h=this.fragmentTrackDefaults.find((e=>e.trackId===d));this.currentTrack=l,l.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:h?.defaultSampleDescriptionIndex??null,defaultSampleDuration:h?.defaultSampleDuration??null,defaultSampleSize:h?.defaultSampleSize??null,defaultSampleFlags:h?.defaultSampleFlags??null,startTimestamp:null},r?l.currentFragmentState.baseDataOffset=Xr(i):u&&(l.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),s&&(l.currentFragmentState.sampleDescriptionIndex=Kr(i)),a&&(l.currentFragmentState.defaultSampleDuration=Kr(i)),n&&(l.currentFragmentState.defaultSampleSize=Kr(i)),o&&(l.currentFragmentState.defaultSampleFlags=Kr(i)),c&&(l.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const t=this.currentTrack;if(!t)break;e(t.currentFragmentState);const r=Lr(i);i.skip(3);const s=0===r?Kr(i):Xr(i);t.currentFragmentState.startTimestamp=s}break;case"trun":{const t=this.currentTrack;if(!t)break;if(e(this.currentFragment),e(t.currentFragmentState),this.currentFragment.trackData.has(t.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const s=Lr(i),a=qr(i),n=Boolean(1&a),o=Boolean(4&a),c=Boolean(256&a),u=Boolean(512&a),d=Boolean(1024&a),l=Boolean(2048&a),h=Kr(i);let m=t.currentFragmentState.baseDataOffset;n&&(m+=Yr(i));let f=null;o&&(f=Kr(i));let p=m;if(0===h){this.currentFragment.implicitBaseDataOffset=p;break}let g=0;const w={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(t.id,w);for(let r=0;r<h;r++){let a,n,o;c?a=Kr(i):(e(null!==t.currentFragmentState.defaultSampleDuration),a=t.currentFragmentState.defaultSampleDuration),u?n=Kr(i):(e(null!==t.currentFragmentState.defaultSampleSize),n=t.currentFragmentState.defaultSampleSize),d?o=Kr(i):(e(null!==t.currentFragmentState.defaultSampleFlags),o=t.currentFragmentState.defaultSampleFlags),0===r&&null!==f&&(o=f);let h=0;l&&(h=0===s?Kr(i):Yr(i));const m=!(65536&o);w.samples.push({presentationTimestamp:g+h,duration:a,byteOffset:p,byteSize:n,isKeyFrame:m}),p+=n,g+=a}w.presentationTimestamps=w.samples.map(((e,t)=>({presentationTimestamp:e.presentationTimestamp,sampleIndex:t}))).sort(((e,t)=>e.presentationTimestamp-t.presentationTimestamp));for(let e=0;e<w.presentationTimestamps.length;e++){const t=w.presentationTimestamps[e],r=w.samples[t.sampleIndex];if(null===w.firstKeyFrameTimestamp&&r.isKeyFrame&&(w.firstKeyFrameTimestamp=r.presentationTimestamp),e<w.presentationTimestamps.length-1){const i=w.presentationTimestamps[e+1];r.duration=i.presentationTimestamp-t.presentationTimestamp}}const k=w.samples[w.presentationTimestamps[0].sampleIndex],b=w.samples[r(w.presentationTimestamps).sampleIndex];w.startTimestamp=k.presentationTimestamp,w.endTimestamp=b.presentationTimestamp+b.duration,this.currentFragment.implicitBaseDataOffset=p}break;case"Â©nam":case"name":if(!this.currentTrack)break;this.currentTrack.name=u.decode(Ur(i,n.contentSize))}return i.filePos=c,!0}}class to{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.internalCodecId}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return e?.timestamp??0}async getFirstPacket(e){const t=await this.fetchPacketForSampleIndex(0,e);return t||!this.internalTrack.demuxer.isFragmented?t:this.performFragmentedLookup((()=>{const e=this.internalTrack.demuxer.fragments[0]??null;if(e?.isKnownToBeFirstFragment){let t=e;for(;t;){if(t.trackData.get(this.internalTrack.id))return{fragmentIndex:v(this.internalTrack.fragments,t.moofOffset,(e=>e.moofOffset)),sampleIndex:0,correctSampleFound:!0};t=t.nextFragment}}return{fragmentIndex:-1,sampleIndex:-1,correctSampleFound:!1}}),-1/0,1/0,e)}mapTimestampIntoTimescale(e){return D(e*this.internalTrack.timescale,14)+this.internalTrack.editListOffset}async getPacket(e,t){const r=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=so(i,r),a=await this.fetchPacketForSampleIndex(s,t);return lo(i)&&this.internalTrack.demuxer.isFragmented?this.performFragmentedLookup((()=>this.findSampleInFragmentsForTimestamp(r)),r,r,t):a}async getNextPacket(t,r){const i=this.packetToSampleIndex.get(t);if(void 0!==i)return this.fetchPacketForSampleIndex(i+1,r);const s=this.packetToFragmentLocation.get(t);if(void 0===s)throw new Error("Packet was not created from this track.");const a=s.fragment.trackData.get(this.internalTrack.id),n=v(this.internalTrack.fragments,s.fragment.moofOffset,(e=>e.moofOffset));return e(-1!==n),this.performFragmentedLookup((()=>{if(s.sampleIndex+1<a.samples.length)return{fragmentIndex:n,sampleIndex:s.sampleIndex+1,correctSampleFound:!0};{let t=s.fragment;for(;t.nextFragment;){t=t.nextFragment;if(t.trackData.get(this.internalTrack.id)){const r=v(this.internalTrack.fragments,t.moofOffset,(e=>e.moofOffset));return e(-1!==r),{fragmentIndex:r,sampleIndex:0,correctSampleFound:!0}}}return{fragmentIndex:n,sampleIndex:-1,correctSampleFound:!1}}}),-1/0,1/0,r)}async getKeyPacket(e,t){const r=this.mapTimestampIntoTimescale(e),i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=so(i,r),a=-1===s?-1:no(i,s),n=await this.fetchPacketForSampleIndex(a,t);return lo(i)&&this.internalTrack.demuxer.isFragmented?this.performFragmentedLookup((()=>this.findKeySampleInFragmentsForTimestamp(r)),r,r,t):n}async getNextKeyPacket(t,r){const i=this.packetToSampleIndex.get(t);if(void 0!==i){const e=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),t=oo(e,i);return this.fetchPacketForSampleIndex(t,r)}const s=this.packetToFragmentLocation.get(t);if(void 0===s)throw new Error("Packet was not created from this track.");const a=s.fragment.trackData.get(this.internalTrack.id),n=v(this.internalTrack.fragments,s.fragment.moofOffset,(e=>e.moofOffset));return e(-1!==n),this.performFragmentedLookup((()=>{const t=a.samples.findIndex(((e,t)=>e.isKeyFrame&&t>s.sampleIndex));if(-1!==t)return{fragmentIndex:n,sampleIndex:t,correctSampleFound:!0};{let t=s.fragment;for(;t.nextFragment;){t=t.nextFragment;const r=t.trackData.get(this.internalTrack.id);if(r&&null!==r.firstKeyFrameTimestamp){const i=v(this.internalTrack.fragments,t.moofOffset,(e=>e.moofOffset));e(-1!==i);const s=r.samples.findIndex((e=>e.isKeyFrame));return e(-1!==s),{fragmentIndex:i,sampleIndex:s,correctSampleFound:!0}}}return{fragmentIndex:n,sampleIndex:-1,correctSampleFound:!1}}}),-1/0,1/0,r)}async fetchPacketForSampleIndex(t,r){if(-1===t)return null;const i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=ao(i,t);if(!s)return null;let a;if(r.metadataOnly)a=ps;else{let t=this.internalTrack.demuxer.reader.requestSlice(s.sampleOffset,s.sampleSize);t instanceof Promise&&(t=await t),e(t),a=Ur(t,s.sampleSize)}const n=(s.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=s.duration/this.internalTrack.timescale,c=new gs(a,s.isKeyFrame?"key":"delta",n,o,t,s.sampleSize);return this.packetToSampleIndex.set(c,t),c}async fetchPacketInFragment(t,r,i){if(-1===r)return null;const s=t.trackData.get(this.internalTrack.id).samples[r];let a;if(e(s),i.metadataOnly)a=ps;else{let t=this.internalTrack.demuxer.reader.requestSlice(s.byteOffset,s.byteSize);t instanceof Promise&&(t=await t),e(t),a=Ur(t,s.byteSize)}const n=(s.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=s.duration/this.internalTrack.timescale,c=new gs(a,s.isKeyFrame?"key":"delta",n,o,t.moofOffset+r,s.byteSize);return this.packetToFragmentLocation.set(c,{fragment:t,sampleIndex:r}),c}findSampleInFragmentsForTimestamp(t){const r=C(this.internalTrack.fragments,t,(e=>e.trackData.get(this.internalTrack.id).startTimestamp));let i=-1,s=!1;if(-1!==r){const a=this.internalTrack.fragments[r].trackData.get(this.internalTrack.id),n=C(a.presentationTimestamps,t,(e=>e.presentationTimestamp));e(-1!==n),i=a.presentationTimestamps[n].sampleIndex,s=t<a.endTimestamp}return{fragmentIndex:r,sampleIndex:i,correctSampleFound:s}}findKeySampleInFragmentsForTimestamp(t){const r=C(this.internalTrack.fragmentsWithKeyFrame,t,(e=>e.trackData.get(this.internalTrack.id).startTimestamp));let i=-1,s=-1,a=!1;if(-1!==r){const n=this.internalTrack.fragmentsWithKeyFrame[r];i=v(this.internalTrack.fragments,n.moofOffset,(e=>e.moofOffset)),e(-1!==i);const o=n.trackData.get(this.internalTrack.id),c=E(o.presentationTimestamps,(e=>o.samples[e.sampleIndex].isKeyFrame&&e.presentationTimestamp<=t));e(-1!==c);s=o.presentationTimestamps[c].sampleIndex,a=t<o.endTimestamp}return{fragmentIndex:i,sampleIndex:s,correctSampleFound:a}}async performFragmentedLookup(e,t,r,i){const s=this.internalTrack.demuxer,a=await s.fragmentLookupMutex.acquire();try{const{fragmentIndex:a,sampleIndex:n,correctSampleFound:o}=e();if(o){const e=this.internalTrack.fragments[a];return this.fetchPacketInFragment(e,n,i)}let c=null,u=a,d=n;const l=this.internalTrack.fragmentLookupTable?C(this.internalTrack.fragmentLookupTable,t,(e=>e.timestamp)):-1,h=-1!==l?this.internalTrack.fragmentLookupTable[l]:null;let m,f=!1;if(-1===a)m=h?.moofOffset??0,f=0===m;else{const e=this.internalTrack.fragments[a];!h||e.moofOffset>=h.moofOffset?(m=e.moofOffset+e.moofSize,c=e):m=h.moofOffset}for(;m<s.reader.fileSize;){if(c){const e=c.trackData.get(this.internalTrack.id);if(e&&e.startTimestamp>r)break;if(c.nextFragment){m=c.nextFragment.moofOffset+c.nextFragment.moofSize,c=c.nextFragment;continue}}let t=s.reader.requestSliceRange(m,8,ti);if(t instanceof Promise&&(t=await t),!t)break;const a=m,n=ri(t);if(!n)break;if("moof"===n.name){const t=v(s.fragments,a,(e=>e.moofOffset));let r;r=-1===t?await s.readFragment(a):s.fragments[t],c&&(c.nextFragment=r),c=r,f&&(r.isKnownToBeFirstFragment=!0,f=!1);const{fragmentIndex:n,sampleIndex:o,correctSampleFound:l}=e();if(l){const e=this.internalTrack.fragments[n];return this.fetchPacketInFragment(e,o,i)}-1!==n&&(u=n,d=o)}m=a+n.totalSize}const p=-1!==u?this.internalTrack.fragments[u]:null;if(h&&(!p||p.moofOffset<h.moofOffset)){const t=this.internalTrack.fragmentLookupTable[l-1],s=t?.timestamp??-1/0;return this.performFragmentedLookup(e,s,r,i)}return p?this.fetchPacketInFragment(p,d,i):null}finally{a()}}}class ro extends to{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{if("vp9"!==this.internalTrack.info.codec||this.internalTrack.info.vp9CodecInfo){if("av1"===this.internalTrack.info.codec&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&rt(e.data)}}else{const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&et(e.data)}return{codec:ne(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class io extends to{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:ce(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const so=(e,t)=>{if(e.presentationTimestamps){const r=C(e.presentationTimestamps,t,(e=>e.presentationTimestamp));return-1===r?-1:e.presentationTimestamps[r].sampleIndex}{const r=C(e.sampleTimingEntries,t,(e=>e.startDecodeTimestamp));if(-1===r)return-1;const i=e.sampleTimingEntries[r];return i.startIndex+Math.min(Math.floor((t-i.startDecodeTimestamp)/i.delta),i.count-1)}},ao=(t,r)=>{const i=C(t.sampleTimingEntries,r,(e=>e.startIndex)),s=t.sampleTimingEntries[i];if(!s||s.startIndex+s.count<=r)return null;let a=s.startDecodeTimestamp+(r-s.startIndex)*s.delta;const n=C(t.sampleCompositionTimeOffsets,r,(e=>e.startIndex)),o=t.sampleCompositionTimeOffsets[n];o&&r-o.startIndex<o.count&&(a+=o.offset);const c=t.sampleSizes[Math.min(r,t.sampleSizes.length-1)],u=C(t.sampleToChunk,r,(e=>e.startSampleIndex)),d=t.sampleToChunk[u];e(d);const l=d.startChunkIndex+Math.floor((r-d.startSampleIndex)/d.samplesPerChunk),h=t.chunkOffsets[l],m=d.startSampleIndex+(l-d.startChunkIndex)*d.samplesPerChunk;let f=0,p=h;if(1===t.sampleSizes.length)p+=c*(r-m),f+=c*d.samplesPerChunk;else for(let e=m;e<m+d.samplesPerChunk;e++){const i=t.sampleSizes[e];e<r&&(p+=i),f+=i}let g=s.delta;if(t.presentationTimestamps){const i=t.presentationTimestampIndexMap[r];if(e(void 0!==i),i<t.presentationTimestamps.length-1){g=t.presentationTimestamps[i+1].presentationTimestamp-a}}return{presentationTimestamp:a,duration:g,sampleOffset:p,sampleSize:c,chunkOffset:h,chunkSize:f,isKeyFrame:!t.keySampleIndices||-1!==v(t.keySampleIndices,r,(e=>e))}},no=(e,t)=>{if(!e.keySampleIndices)return t;const r=C(e.keySampleIndices,t,(e=>e));return e.keySampleIndices[r]??-1},oo=(e,t)=>{if(!e.keySampleIndices)return t+1;const r=C(e.keySampleIndices,t,(e=>e));return e.keySampleIndices[r+1]??-1},co=(e,t)=>{e.startTimestamp+=t,e.endTimestamp+=t;for(const r of e.samples)r.presentationTimestamp+=t;for(const r of e.presentationTimestamps)r.presentationTimestamp+=t},uo=e=>{const[t,,,r]=e,i=Math.hypot(t,r),s=t/i,a=r/i,n=-Math.atan2(a,s)*(180/Math.PI);return Number.isFinite(n)?n:0},lo=e=>0===e.sampleSizes.length;
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
var ho;!function(e){e[e.None=0]="None",e[e.Xiph=1]="Xiph",e[e.FixedSize=2]="FixedSize",e[e.Ebml=3]="Ebml"}(ho||(ho={}));const mo=[{id:fi.SeekHead,flag:"seekHeadSeen"},{id:fi.Info,flag:"infoSeen"},{id:fi.Tracks,flag:"tracksSeen"},{id:fi.Cues,flag:"cuesSeen"}],fo=10485760;class po extends ss{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentCueTime=null,this.isWebM=!1,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map((e=>e.computeDuration())));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.segments.flatMap((e=>e.tracks.map((e=>e.inputTrack))))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),t=await Promise.all(e.map((e=>e.getCodecParameterString())));return Ai({isWebM:this.isWebM,hasVideo:this.segments.some((e=>e.tracks.some((e=>"video"===e.info?.type)))),hasAudio:this.segments.some((e=>e.tracks.some((e=>"audio"===e.info?.type)))),codecStrings:t.filter(Boolean)})}readMetadata(){return this.readMetadataPromise??=(async()=>{let e=0;for(;e<this.reader.fileSize;){let t=this.reader.requestSliceRange(e,2,Ti);if(t instanceof Promise&&(t=await t),!t)break;const i=_i(t);if(!i)break;const s=i.id;let a=i.size;const n=t.filePos;if(s===fi.EBML){Fi(a);let e=this.reader.requestSlice(n,a);if(e instanceof Promise&&(e=await e),!e)break;this.readContiguousElements(e)}else if(s===fi.Segment){if(await this.readSegment(n,a),null===a)break}else if(s===fi.Cluster){if(null===a){a=(await Bi(this.reader,n,wi,this.reader.fileSize)??this.reader.fileSize)-n}const e=r(this.segments);e&&(e.elementEndPos=n+a)}Fi(a),e=n+a}})()}async readSegment(t,r){this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:t,elementEndPos:null===r?await this.input.source.getSize():t+r,clusterSeekStartPos:t,clusters:[],clusterLookupMutex:new y},this.segments.push(this.currentSegment);let i=0,s=!1;for(;i<this.currentSegment.elementEndPos;){let e=this.reader.requestSliceRange(i,2,Ti);if(e instanceof Promise&&(e=await e),!e)break;const t=i,r=_i(e);if(!r||!gi.includes(r.id)){const e=await Mi(this.reader,t,gi,Math.min(this.currentSegment.elementEndPos,t+fo));if(e){i=e;continue}break}const{id:a,size:n}=r,o=e.filePos,c=mo.findIndex((e=>e.id===a));if(-1!==c){const e=mo[c].flag;this.currentSegment[e]=!0,Fi(n);let t=this.reader.requestSlice(o,n);t instanceof Promise&&(t=await t),t&&this.readContiguousElements(t)}else a===fi.Cluster&&(s||(s=!0,this.currentSegment.clusterSeekStartPos=t));if(null!==n&&(i=o+n),this.currentSegment.infoSeen&&this.currentSegment.tracksSeen&&this.currentSegment.cuesSeen)break;if(this.currentSegment.seekHeadSeen){let e=this.currentSegment.infoSeen,t=this.currentSegment.tracksSeen,r=this.currentSegment.cuesSeen;for(const i of this.currentSegment.seekEntries)i.id===fi.Info?e=!0:i.id===fi.Tracks?t=!0:i.id===fi.Cues&&(r=!0);if(e&&t&&r)break}if(null===n)break}if(!s){const e=this.currentSegment.seekEntries.find((e=>e.id===fi.Cluster));this.currentSegment.clusterSeekStartPos=e?t+e.segmentPosition:i}this.currentSegment.seekEntries.sort(((e,t)=>e.segmentPosition-t.segmentPosition));for(const e of this.currentSegment.seekEntries){const r=mo.find((t=>t.id===e.id));if(!r)continue;if(this.currentSegment[r.flag])continue;let i=this.reader.requestSliceRange(t+e.segmentPosition,2,Ti);if(i instanceof Promise&&(i=await i),!i)continue;const s=_i(i);if(!s)continue;const{id:a,size:n}=s;if(a!==r.id)continue;Fi(n),this.currentSegment[r.flag]=!0;let o=this.reader.requestSlice(i.filePos,n);o instanceof Promise&&(o=await o),o&&this.readContiguousElements(o)}-1===this.currentSegment.timestampScale&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e3),this.currentSegment.tracks.sort(((e,t)=>Number(t.isDefault)-Number(e.isDefault))),this.currentSegment.cuePoints.sort(((e,t)=>e.clusterPosition-t.clusterPosition));const a=this.currentSegment.tracks.map((e=>e.id)),n=new Set;let o=null,c=null;for(const t of this.currentSegment.cuePoints){if(t.clusterPosition!==o){for(const t of n){e(c);this.currentSegment.tracks.find((e=>e.id===t)).cuePoints.push(c)}for(const e of a)n.add(e)}if(c=t,!n.has(t.trackId))continue;this.currentSegment.tracks.find((e=>e.id===t.trackId)).cuePoints.push(t),n.delete(t.trackId),o=t.clusterPosition}for(const t of n){e(c);this.currentSegment.tracks.find((e=>e.id===t)).cuePoints.push(c)}for(const e of this.currentSegment.tracks)e.cuePoints.sort(((e,t)=>e.time-t.time));this.currentSegment=null}async readCluster(t,i){let s=this.reader.requestSliceRange(t,2,Ti);s instanceof Promise&&(s=await s),e(s);const a=t,n=_i(s);e(n);const o=n.id;let c=n.size;const u=s.filePos;if(null===c){c=(await Bi(this.reader,u,wi,i.elementEndPos)??i.elementEndPos)-u}e(o===fi.Cluster);let d=this.reader.requestSlice(u,c);d instanceof Promise&&(d=await d);const l={elementStartPos:a,elementEndPos:u+c,dataStartPos:u,timestamp:-1,trackData:new Map,nextCluster:null,isKnownToBeFirstCluster:!1};this.currentCluster=l,d&&this.readContiguousElements(d);for(const[t,s]of l.trackData){const a=i.tracks.find((e=>e.id===t))??null;e(s.blocks.length>0);let n=!1,o=!1;for(let e=0;e<s.blocks.length;e++){const t=s.blocks[e];t.timestamp+=l.timestamp,n||=t.referencedTimestamps.length>0,o||=t.lacing!==ho.None}n&&(s.blocks=bo(s.blocks)),s.presentationTimestamps=s.blocks.map(((e,t)=>({timestamp:e.timestamp,blockIndex:t}))).sort(((e,t)=>e.timestamp-t.timestamp));for(let e=0;e<s.presentationTimestamps.length;e++){const t=s.presentationTimestamps[e],r=s.blocks[t.blockIndex];if(null===s.firstKeyFrameTimestamp&&r.isKeyFrame&&(s.firstKeyFrameTimestamp=r.timestamp),e<s.presentationTimestamps.length-1){const t=s.presentationTimestamps[e+1];r.duration=t.timestamp-r.timestamp}else 0===r.duration&&null!=a?.defaultDuration&&r.lacing===ho.None&&(r.duration=a.defaultDuration)}o&&(this.expandLacedBlocks(s.blocks,a),s.presentationTimestamps=s.blocks.map(((e,t)=>({timestamp:e.timestamp,blockIndex:t}))).sort(((e,t)=>e.timestamp-t.timestamp)));const c=s.blocks[s.presentationTimestamps[0].blockIndex],u=s.blocks[r(s.presentationTimestamps).blockIndex];if(s.startTimestamp=c.timestamp,s.endTimestamp=u.timestamp+u.duration,a){x(a.clusters,l,(e=>e.elementStartPos));null!==s.firstKeyFrameTimestamp&&x(a.clustersWithKeyFrame,l,(e=>e.elementStartPos))}}return x(i.clusters,l,(e=>e.elementStartPos)),this.currentCluster=null,l}getTrackDataInCluster(e,t){let r=e.trackData.get(t);return r||(r={startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(t,r)),r}expandLacedBlocks(t,r){for(let i=0;i<t.length;i++){const s=t[i];if(s.lacing===ho.None)continue;const a=Vr.tempFromBytes(s.data),n=[],o=Lr(a)+1;switch(s.lacing){case ho.Xiph:{let e=0;for(let t=0;t<o-1;t++){let t=0;for(;a.bufferPos<a.length;){const r=Lr(a);if(t+=r,r<255){n.push(t),e+=t;break}}}n.push(a.length-(a.bufferPos+e))}break;case ho.FixedSize:{const e=a.length-1,t=Math.floor(e/o);for(let e=0;e<o;e++)n.push(t)}break;case ho.Ebml:{const t=vi(a);e(null!==t);let r=t;n.push(r);let i=r;for(let t=1;t<o-1;t++){const t=a.bufferPos,s=vi(a);e(null!==s);r+=s-((1<<7*(a.bufferPos-t)-1)-1),n.push(r),i+=r}n.push(a.length-(a.bufferPos+i))}break;default:e(!1)}e(n.length===o),t.splice(i,1);for(let e=0;e<o;e++){const c=n[e],u=Ur(a,c),d=s.duration||o*(r?.defaultDuration??0),l=s.timestamp+d*e/o,h=d/o;t.splice(i+e,0,{timestamp:l,duration:h,isKeyFrame:s.isKeyFrame,referencedTimestamps:s.referencedTimestamps,data:u,lacing:ho.None})}i+=o,i--}}readContiguousElements(e){const t=e.filePos;for(;e.filePos-t<=e.length-2;){if(!this.traverseElement(e))break}}traverseElement(r){const i=_i(r);if(!i)return!1;const{id:s,size:a}=i,n=r.filePos;switch(Fi(a),s){case fi.DocType:this.isWebM="webm"===Ei(r,a);break;case fi.Seek:{if(!this.currentSegment)break;const e={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(e),this.readContiguousElements(r.slice(n,a)),-1!==e.id&&-1!==e.segmentPosition||this.currentSegment.seekEntries.pop()}break;case fi.SeekID:{const e=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!e)break;e.id=Ci(r,a)}break;case fi.SeekPosition:{const e=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!e)break;e.segmentPosition=Ci(r,a)}break;case fi.TimestampScale:if(!this.currentSegment)break;this.currentSegment.timestampScale=Ci(r,a),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale;break;case fi.Duration:if(!this.currentSegment)break;this.currentSegment.duration=Ii(r,a);break;case fi.TrackEntry:if(!this.currentSegment)break;if(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusters:[],clustersWithKeyFrame:[],cuePoints:[],isDefault:!1,inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,name:null,languageCode:A,info:null},this.readContiguousElements(r.slice(n,a)),this.currentTrack&&-1!==this.currentTrack.id&&this.currentTrack.codecId&&this.currentTrack.info){const e=this.currentTrack.codecId.indexOf("/"),t=-1===e?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,e);if("video"===this.currentTrack.info.type&&-1!==this.currentTrack.info.width&&-1!==this.currentTrack.info.height){this.currentTrack.codecId===zi.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===zi.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):t===zi.vp8?this.currentTrack.info.codec="vp8":t===zi.vp9?this.currentTrack.info.codec="vp9":t===zi.av1&&(this.currentTrack.info.codec="av1");const e=this.currentTrack,r=new Ls(new wo(e));this.currentTrack.inputTrack=r,this.currentSegment.tracks.push(this.currentTrack)}else if("audio"===this.currentTrack.info.type&&-1!==this.currentTrack.info.numberOfChannels&&-1!==this.currentTrack.info.sampleRate){t===zi.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2")},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===zi.mp3?this.currentTrack.info.codec="mp3":t===zi.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):t===zi.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):t===zi.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):"A_PCM/INT/LIT"===this.currentTrack.codecId?8===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-u8":16===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-s16":24===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-s24":32===this.currentTrack.info.bitDepth&&(this.currentTrack.info.codec="pcm-s32"):"A_PCM/INT/BIG"===this.currentTrack.codecId?8===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-u8":16===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-s16be":24===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-s24be":32===this.currentTrack.info.bitDepth&&(this.currentTrack.info.codec="pcm-s32be"):"A_PCM/FLOAT/IEEE"===this.currentTrack.codecId&&(32===this.currentTrack.info.bitDepth?this.currentTrack.info.codec="pcm-f32":64===this.currentTrack.info.bitDepth&&(this.currentTrack.info.codec="pcm-f64"));const e=this.currentTrack,r=new Ns(new ko(e));this.currentTrack.inputTrack=r,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null;break;case fi.TrackNumber:if(!this.currentTrack)break;this.currentTrack.id=Ci(r,a);break;case fi.TrackType:{if(!this.currentTrack)break;const e=Ci(r,a);1===e?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null}:2===e&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case fi.FlagEnabled:if(!this.currentTrack)break;Ci(r,a)||(this.currentSegment.tracks.pop(),this.currentTrack=null);break;case fi.FlagDefault:if(!this.currentTrack)break;this.currentTrack.isDefault=!!Ci(r,a);break;case fi.CodecID:if(!this.currentTrack)break;this.currentTrack.codecId=Ei(r,a);break;case fi.CodecPrivate:if(!this.currentTrack)break;this.currentTrack.codecPrivate=Ur(r,a);break;case fi.DefaultDuration:if(!this.currentTrack)break;this.currentTrack.defaultDuration=this.currentTrack.segment.timestampFactor*Ci(r,a)/1e9;break;case fi.Name:if(!this.currentTrack)break;this.currentTrack.name=((e,t)=>{const r=Ur(e,t);let i=0;for(;i<t&&0!==r[i];)i+=1;return u.decode(r.subarray(0,i))})(r,a);break;case fi.Language:if(!this.currentTrack)break;if(this.currentTrack.languageCode!==A)break;this.currentTrack.languageCode=Ei(r,a),W(this.currentTrack.languageCode)||(this.currentTrack.languageCode=A);break;case fi.LanguageBCP47:{if(!this.currentTrack)break;const e=Ei(r,a).split("-")[0];this.currentTrack.languageCode=e||A}break;case fi.Video:if("video"!==this.currentTrack?.info?.type)break;this.readContiguousElements(r.slice(n,a));break;case fi.PixelWidth:if("video"!==this.currentTrack?.info?.type)break;this.currentTrack.info.width=Ci(r,a);break;case fi.PixelHeight:if("video"!==this.currentTrack?.info?.type)break;this.currentTrack.info.height=Ci(r,a);break;case fi.Colour:if("video"!==this.currentTrack?.info?.type)break;this.currentTrack.info.colorSpace={},this.readContiguousElements(r.slice(n,a));break;case fi.MatrixCoefficients:{if("video"!==this.currentTrack?.info?.type||!this.currentTrack.info.colorSpace)break;const e=Ci(r,a),t=w[e]??null;this.currentTrack.info.colorSpace.matrix=t}break;case fi.Range:if("video"!==this.currentTrack?.info?.type||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=2===Ci(r,a);break;case fi.TransferCharacteristics:{if("video"!==this.currentTrack?.info?.type||!this.currentTrack.info.colorSpace)break;const e=Ci(r,a),t=p[e]??null;this.currentTrack.info.colorSpace.transfer=t}break;case fi.Primaries:{if("video"!==this.currentTrack?.info?.type||!this.currentTrack.info.colorSpace)break;const e=Ci(r,a),t=m[e]??null;this.currentTrack.info.colorSpace.primaries=t}break;case fi.Projection:if("video"!==this.currentTrack?.info?.type)break;this.readContiguousElements(r.slice(n,a));break;case fi.ProjectionPoseRoll:{if("video"!==this.currentTrack?.info?.type)break;const e=-Ii(r,a);try{this.currentTrack.info.rotation=t(e)}catch{}}break;case fi.Audio:if("audio"!==this.currentTrack?.info?.type)break;this.readContiguousElements(r.slice(n,a));break;case fi.SamplingFrequency:if("audio"!==this.currentTrack?.info?.type)break;this.currentTrack.info.sampleRate=Ii(r,a);break;case fi.Channels:if("audio"!==this.currentTrack?.info?.type)break;this.currentTrack.info.numberOfChannels=Ci(r,a);break;case fi.BitDepth:if("audio"!==this.currentTrack?.info?.type)break;this.currentTrack.info.bitDepth=Ci(r,a);break;case fi.CuePoint:if(!this.currentSegment)break;this.readContiguousElements(r.slice(n,a)),this.currentCueTime=null;break;case fi.CueTime:this.currentCueTime=Ci(r,a);break;case fi.CueTrackPositions:{if(null===this.currentCueTime)break;e(this.currentSegment);const t={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(t),this.readContiguousElements(r.slice(n,a)),-1!==t.trackId&&-1!==t.clusterPosition||this.currentSegment.cuePoints.pop()}break;case fi.CueTrack:{const e=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!e)break;e.trackId=Ci(r,a)}break;case fi.CueClusterPosition:{const t=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!t)break;e(this.currentSegment),t.clusterPosition=this.currentSegment.dataStartPos+Ci(r,a)}break;case fi.Timestamp:if(!this.currentCluster)break;this.currentCluster.timestamp=Ci(r,a);break;case fi.SimpleBlock:{if(!this.currentCluster)break;const e=vi(r);if(null===e)break;const t=$r(r),i=Lr(r),s=!!(128&i),o=i>>1&3;this.getTrackDataInCluster(this.currentCluster,e).blocks.push({timestamp:t,duration:0,isKeyFrame:s,referencedTimestamps:[],data:Ur(r,a-(r.filePos-n)),lacing:o})}break;case fi.BlockGroup:if(!this.currentCluster)break;if(this.readContiguousElements(r.slice(n,a)),this.currentBlock){for(let e=0;e<this.currentBlock.referencedTimestamps.length;e++)this.currentBlock.referencedTimestamps[e]+=this.currentBlock.timestamp;this.currentBlock=null}break;case fi.Block:{if(!this.currentCluster)break;const e=vi(r);if(null===e)break;const t=$r(r),i=Lr(r)>>1&3,s=this.getTrackDataInCluster(this.currentCluster,e);this.currentBlock={timestamp:t,duration:0,isKeyFrame:!0,referencedTimestamps:[],data:Ur(r,a-(r.filePos-n)),lacing:i},s.blocks.push(this.currentBlock)}break;case fi.BlockDuration:if(!this.currentBlock)break;this.currentBlock.duration=Ci(r,a);break;case fi.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1;const e=((e,t)=>{let r=Ci(e,t);return r&1<<8*t-1&&(r-=2**(8*t)),r})(r,a);this.currentBlock.referencedTimestamps.push(e)}}return r.filePos=n+a,!0}}class go{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.codecId}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){const e=await this.getFirstPacket({metadataOnly:!0});return e?.timestamp??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}async getFirstPacket(e){return this.performClusterLookup((()=>{const e=this.internalTrack.segment.clusters[0]??null;if(e?.isKnownToBeFirstCluster){let t=e;for(;t;){if(t.trackData.get(this.internalTrack.id))return{clusterIndex:v(this.internalTrack.clusters,t.elementStartPos,(e=>e.elementStartPos)),blockIndex:0,correctBlockFound:!0};t=t.nextCluster}}return{clusterIndex:-1,blockIndex:-1,correctBlockFound:!1}}),-1/0,1/0,e)}intoTimescale(e){return D(e*this.internalTrack.segment.timestampFactor,14)}async getPacket(e,t){const r=this.intoTimescale(e);return this.performClusterLookup((()=>this.findBlockInClustersForTimestamp(r)),r,r,t)}async getNextPacket(t,r){const i=this.packetToClusterLocation.get(t);if(void 0===i)throw new Error("Packet was not created from this track.");const s=i.cluster.trackData.get(this.internalTrack.id),a=v(this.internalTrack.clusters,i.cluster.elementStartPos,(e=>e.elementStartPos));return e(-1!==a),this.performClusterLookup((()=>{if(i.blockIndex+1<s.blocks.length)return{clusterIndex:a,blockIndex:i.blockIndex+1,correctBlockFound:!0};{let t=i.cluster;for(;t.nextCluster;){t=t.nextCluster;if(t.trackData.get(this.internalTrack.id)){const r=v(this.internalTrack.clusters,t.elementStartPos,(e=>e.elementStartPos));return e(-1!==r),{clusterIndex:r,blockIndex:0,correctBlockFound:!0}}}return{clusterIndex:a,blockIndex:-1,correctBlockFound:!1}}}),-1/0,1/0,r)}async getKeyPacket(e,t){const r=this.intoTimescale(e);return this.performClusterLookup((()=>this.findKeyBlockInClustersForTimestamp(r)),r,r,t)}async getNextKeyPacket(t,r){const i=this.packetToClusterLocation.get(t);if(void 0===i)throw new Error("Packet was not created from this track.");const s=i.cluster.trackData.get(this.internalTrack.id),a=v(this.internalTrack.clusters,i.cluster.elementStartPos,(e=>e.elementStartPos));return e(-1!==a),this.performClusterLookup((()=>{const t=s.blocks.findIndex(((e,t)=>e.isKeyFrame&&t>i.blockIndex));if(-1!==t)return{clusterIndex:a,blockIndex:t,correctBlockFound:!0};{let t=i.cluster;for(;t.nextCluster;){t=t.nextCluster;const r=t.trackData.get(this.internalTrack.id);if(r&&null!==r.firstKeyFrameTimestamp){const i=v(this.internalTrack.clusters,t.elementStartPos,(e=>e.elementStartPos));e(-1!==i);const s=r.blocks.findIndex((e=>e.isKeyFrame));return e(-1!==s),{clusterIndex:i,blockIndex:s,correctBlockFound:!0}}}return{clusterIndex:a,blockIndex:-1,correctBlockFound:!1}}}),-1/0,1/0,r)}async fetchPacketInCluster(t,r,i){if(-1===r)return null;const s=t.trackData.get(this.internalTrack.id).blocks[r];e(s);const a=i.metadataOnly?ps:s.data,n=s.timestamp/this.internalTrack.segment.timestampFactor,o=s.duration/this.internalTrack.segment.timestampFactor,c=new gs(a,s.isKeyFrame?"key":"delta",n,o,t.dataStartPos+r,s.data.byteLength);return this.packetToClusterLocation.set(c,{cluster:t,blockIndex:r}),c}findBlockInClustersForTimestamp(t){const r=C(this.internalTrack.clusters,t,(e=>e.trackData.get(this.internalTrack.id).startTimestamp));let i=-1,s=!1;if(-1!==r){const a=this.internalTrack.clusters[r].trackData.get(this.internalTrack.id),n=C(a.presentationTimestamps,t,(e=>e.timestamp));e(-1!==n),i=a.presentationTimestamps[n].blockIndex,s=t<a.endTimestamp}return{clusterIndex:r,blockIndex:i,correctBlockFound:s}}findKeyBlockInClustersForTimestamp(t){const r=C(this.internalTrack.clustersWithKeyFrame,t,(e=>e.trackData.get(this.internalTrack.id).firstKeyFrameTimestamp));let i=-1,s=-1,a=!1;if(-1!==r){const n=this.internalTrack.clustersWithKeyFrame[r];i=v(this.internalTrack.clusters,n.elementStartPos,(e=>e.elementStartPos)),e(-1!==i);const o=n.trackData.get(this.internalTrack.id),c=E(o.presentationTimestamps,(e=>o.blocks[e.blockIndex].isKeyFrame&&e.timestamp<=t));e(-1!==c);s=o.presentationTimestamps[c].blockIndex,a=t<o.endTimestamp}return{clusterIndex:i,blockIndex:s,correctBlockFound:a}}async performClusterLookup(t,r,i,s){const{demuxer:a,segment:n}=this.internalTrack,o=await n.clusterLookupMutex.acquire();try{const{clusterIndex:o,blockIndex:c,correctBlockFound:u}=t();if(u){const e=this.internalTrack.clusters[o];return this.fetchPacketInCluster(e,c,s)}let d=null,l=o,h=c;const m=C(this.internalTrack.cuePoints,r,(e=>e.time)),f=-1!==m?this.internalTrack.cuePoints[m]:null;let p,g=!1;if(-1===o)p=f?.clusterPosition??n.clusterSeekStartPos,g=p===n.clusterSeekStartPos;else{const e=this.internalTrack.clusters[o];!f||e.elementStartPos>=f.clusterPosition?(p=e.elementEndPos,d=e):p=f.clusterPosition}for(;p<=n.elementEndPos-2;){if(d){const e=d.trackData.get(this.internalTrack.id);if(e&&e.startTimestamp>i)break;if(d.nextCluster){p=d.nextCluster.elementEndPos,d=d.nextCluster;continue}}let r=a.reader.requestSliceRange(p,2,Ti);if(r instanceof Promise&&(r=await r),!r)break;const o=p,c=_i(r);if(!c||!gi.includes(c.id)){const e=await Mi(a.reader,o,gi,Math.min(n.elementEndPos,o+fo));if(e){p=e;continue}break}const u=c.id;let m=c.size;const f=r.filePos;if(u===fi.Cluster){const e=v(n.clusters,o,(e=>e.elementStartPos));let r;r=-1===e?await a.readCluster(o,n):n.clusters[e],d&&(d.nextCluster=r),d=r,g&&(r.isKnownToBeFirstCluster=!0,g=!1);const{clusterIndex:i,blockIndex:c,correctBlockFound:u}=t();if(u){const e=this.internalTrack.clusters[i];return this.fetchPacketInCluster(e,c,s)}-1!==i&&(l=i,h=c)}if(null===m){if(u===fi.Cluster)e(d),m=d.elementEndPos-f;else{m=(await Bi(a.reader,f,wi,n.elementEndPos)??n.elementEndPos)-f}const t=f+m;if(t>n.elementEndPos-2)break;{let e=a.reader.requestSliceRange(t,2,Ti);if(e instanceof Promise&&(e=await e),!e)break;if(xi(e)===fi.Segment){n.elementEndPos=t;break}}}p=f+m}const w=-1!==l?this.internalTrack.clusters[l]:null;if(f&&(!w||w.elementStartPos<f.clusterPosition)){const e=this.internalTrack.cuePoints[m-1],r=e?.time??-1/0;return this.performClusterLookup(t,r,i,s)}return w?this.fetchPacketInCluster(w,h,s):null}finally{o()}}}class wo extends go{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{let e=null;return("vp9"===this.internalTrack.info.codec||"av1"===this.internalTrack.info.codec||"avc"===this.internalTrack.info.codec&&!this.internalTrack.info.codecDescription||"hevc"===this.internalTrack.info.codec&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:ne({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcCodecInfo:"avc"===this.internalTrack.info.codec&&e?qe(e.data):null,hevcCodecInfo:"hevc"===this.internalTrack.info.codec&&e?je(e.data):null,vp9CodecInfo:"vp9"===this.internalTrack.info.codec&&e?et(e.data):null,av1CodecInfo:"av1"===this.internalTrack.info.codec&&e?rt(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class ko extends go{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:ce({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const bo=e=>{const t=new Map;for(let r=0;r<e.length;r++){const i=e[r];t.set(i.timestamp,i)}const r=new Set,i=[],s=e=>{if(!r.has(e)){r.add(e);for(let r=0;r<e.referencedTimestamps.length;r++){const i=e.referencedTimestamps[r],a=t.get(i);a&&s(a)}i.push(e)}};for(let t=0;t<e.length;t++)s(e[t]);return i},yo=e=>{if("ID3"!==ei(e,3))return e.skip(-3),null;e.skip(3);return{size:So(Kr(e))}},To=async(e,t,r)=>{let i=t;for(;i<r;){let t=e.requestSlice(i,4);if(t instanceof Promise&&(t=await t),!t)break;const r=Kr(t),s=$i(r,e.fileSize-i);if(s.header)return{header:s.header,startPos:i};i+=s.bytesAdvanced}return null},So=e=>{let t=2130706432,r=0;for(;0!==t;)r>>=1,r|=e&t,t>>=8;return r};
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class vo extends ss{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new y,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&this.lastLoadedPos<this.reader.fileSize;)await this.advanceReader();e(this.firstFrameHeader),this.tracks=[new Ns(new Co(this))]})()}async advanceReader(){if(0===this.lastLoadedPos){let e=this.reader.requestSlice(0,10);if(e instanceof Promise&&(e=await e),!e)return void(this.lastSampleLoaded=!0);const t=yo(e);t&&(this.lastLoadedPos+=10+t.size)}const t=this.lastLoadedPos,r=await To(this.reader,t,this.reader.fileSize);if(!r)return void(this.lastSampleLoaded=!0);const i=r.header;this.lastLoadedPos=r.startPos+i.totalSize-1;const s=qi(i.mpegVersionId,i.channel);let a=this.reader.requestSlice(t+s,4);a instanceof Promise&&(a=await a),e(a);const n=Kr(a);if(n===Li||n===Ni)return;this.firstFrameHeader||(this.firstFrameHeader=i);const o=i.audioSamplesInFrame/i.sampleRate,c={timestamp:this.nextTimestampInSamples/i.sampleRate,duration:o,dataStart:t,dataSize:i.totalSize};this.loadedSamples.push(c),this.nextTimestampInSamples+=i.audioSamplesInFrame}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const t=this.tracks[0];return e(t),t.computeDuration()}}class Co{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return e(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return A}getCodec(){return"mp3"}getInternalCodecId(){return null}getNumberOfChannels(){return e(this.demuxer.firstFrameHeader),3===this.demuxer.firstFrameHeader.channel?1:2}getSampleRate(){return e(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}async getDecoderConfig(){return e(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:3===this.demuxer.firstFrameHeader.channel?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}async getPacketAtIndex(t,r){if(-1===t)return null;const i=this.demuxer.loadedSamples[t];if(!i)return null;let s;if(r.metadataOnly)s=ps;else{let t=this.demuxer.reader.requestSlice(i.dataStart,i.dataSize);t instanceof Promise&&(t=await t),e(t),s=Ur(t,i.dataSize)}return new gs(s,"key",i.timestamp,i.duration,t,i.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,t){const r=await this.demuxer.readingMutex.acquire();try{const r=v(this.demuxer.loadedSamples,e.timestamp,(e=>e.timestamp));if(-1===r)throw new Error("Packet was not created from this track.");const i=r+1;for(;i>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(i,t)}finally{r()}}async getPacket(e,t){const r=await this.demuxer.readingMutex.acquire();try{for(;;){const r=C(this.demuxer.loadedSamples,e,(e=>e.timestamp));if(-1===r&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(r,t);if(r>=0&&r+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(r,t);await this.demuxer.advanceReader()}}finally{r()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class xo extends ss{constructor(e){super(e),this.metadataPromise=null,this.bitstreams=[],this.tracks=[],this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;e<=this.reader.fileSize-Zi;){let t=this.reader.requestSliceRange(e,Zi,es);if(t instanceof Promise&&(t=await t),!t)break;const r=ts(t);if(!r)break;if(!!!(2&r.headerType))break;this.bitstreams.push({serialNumber:r.serialNumber,bosPage:r,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),e=r.headerStartPos+r.totalSize}for(const e of this.bitstreams){const t=await this.readPacket(e.bosPage,0);t&&(t.data.byteLength>=7&&1===t.data[0]&&118===t.data[1]&&111===t.data[2]&&114===t.data[3]&&98===t.data[4]&&105===t.data[5]&&115===t.data[6]?await this.readVorbisMetadata(t,e):t.data.byteLength>=8&&79===t.data[0]&&112===t.data[1]&&117===t.data[2]&&115===t.data[3]&&72===t.data[4]&&101===t.data[5]&&97===t.data[6]&&100===t.data[7]&&await this.readOpusMetadata(t,e),null!==e.codecInfo.codec&&this.tracks.push(new Ns(new Po(e,this))))}})()}async readVorbisMetadata(e,t){let r=await this.findNextPacketStart(e);if(!r)return;const i=await this.readPacket(r.startPage,r.startSegmentIndex);if(!i)return;if(r=await this.findNextPacketStart(i),!r)return;const s=await this.readPacket(r.startPage,r.startSegmentIndex);if(!s)return;if(3!==i.data[0]||5!==s.data[0])return;const a=[],n=e=>{for(;a.push(Math.min(255,e)),!(e<255);)e-=255};n(e.data.length),n(i.data.length);const o=new Uint8Array(1+a.length+e.data.length+i.data.length+s.data.length);o[0]=a.length,o.set(a,1),o.set(e.data,1+a.length),o.set(i.data,1+a.length+e.data.length),o.set(s.data,1+a.length+e.data.length+i.data.length),t.codecInfo.codec="vorbis",t.description=o,t.lastMetadataPacket=s;const u=c(e.data);t.numberOfChannels=u.getUint8(11),t.sampleRate=u.getUint32(12,!0);const d=u.getUint8(28);t.codecInfo.vorbisInfo={blocksizes:[1<<(15&d),1<<(d>>4)],modeBlockflags:at(s.data).modeBlockflags}}async readOpusMetadata(e,t){const r=await this.findNextPacketStart(e);if(!r)return;const i=await this.readPacket(r.startPage,r.startSegmentIndex);if(!i)return;t.codecInfo.codec="opus",t.description=e.data,t.lastMetadataPacket=i;const s=it(e.data);t.numberOfChannels=s.outputChannelCount,t.sampleRate=s.inputSampleRate,t.codecInfo.opusInfo={preSkip:s.preSkip}}async readPacket(t,r){e(r<t.lacingValues.length);let i=0;for(let e=0;e<r;e++)i+=t.lacingValues[e];let s=t,a=i,n=r;const o=[];e:for(;;){let r=this.reader.requestSlice(s.dataStartPos,s.dataSize);r instanceof Promise&&(r=await r),e(r);const c=Ur(r,s.dataSize);for(;;){if(n===s.lacingValues.length){o.push(c.subarray(i,a));break}const e=s.lacingValues[n];if(a+=e,e<255){o.push(c.subarray(i,a));break e}n++}let u=s.headerStartPos+s.totalSize;for(;;){if(u>this.reader.fileSize-Zi)return null;let e=this.reader.requestSliceRange(u,Zi,es);if(e instanceof Promise&&(e=await e),!e)return null;const r=ts(e);if(!r)return null;if(s=r,s.serialNumber===t.serialNumber)break;u=s.headerStartPos+s.totalSize}i=0,a=0,n=0}const c=o.reduce(((e,t)=>e+t.length),0),u=new Uint8Array(c);let d=0;for(let e=0;e<o.length;e++){const t=o[e];u.set(t,d),d+=t.length}return{data:u,endPage:s,endSegmentIndex:n}}async findNextPacketStart(e){if(e.endSegmentIndex<e.endPage.lacingValues.length-1)return{startPage:e.endPage,startSegmentIndex:e.endSegmentIndex+1};if(!!(4&e.endPage.headerType))return null;let t=e.endPage.headerStartPos+e.endPage.totalSize;for(;;){if(t>=this.reader.fileSize-Zi)return null;let r=this.reader.requestSliceRange(t,Zi,es);if(r instanceof Promise&&(r=await r),!r)return null;const i=ts(r);if(!i)return null;if(i.serialNumber===e.endPage.serialNumber)return{startPage:i,startSegmentIndex:0};t=i.headerStartPos+i.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map((e=>e.getCodecParameterString())));return Ji({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map((e=>e.computeDuration())));return Math.max(0,...t)}}class Po{constructor(e,t){this.bitstream=e,this.demuxer=t,this.encodedPacketToMetadata=new WeakMap,this.internalSampleRate="opus"===e.codecInfo.codec?he:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}getInternalCodecId(){return null}async getDecoderConfig(){return e(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getName(){return null}getLanguageCode(){return A}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}granulePositionToTimestampInSamples(t){return"opus"===this.bitstream.codecInfo.codec?(e(this.bitstream.codecInfo.opusInfo),t-this.bitstream.codecInfo.opusInfo.preSkip):t}createEncodedPacketFromOggPacket(e,t,r){if(!e)return null;const{durationInSamples:i,vorbisBlockSize:s}=Xi(e.data,this.bitstream.codecInfo,t.vorbisLastBlocksize),a=new gs(r.metadataOnly?ps:e.data,"key",Math.max(0,t.timestampInSamples)/this.internalSampleRate,i/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(a,{packet:e,timestampInSamples:t.timestampInSamples,durationInSamples:i,vorbisBlockSize:s}),a}async getFirstPacket(t){e(this.bitstream.lastMetadataPacket);const r=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!r)return null;let i=0;"opus"===this.bitstream.codecInfo.codec&&(e(this.bitstream.codecInfo.opusInfo),i-=this.bitstream.codecInfo.opusInfo.preSkip);const s=await this.demuxer.readPacket(r.startPage,r.startSegmentIndex);return this.createEncodedPacketFromOggPacket(s,{timestampInSamples:i,vorbisLastBlocksize:null},t)}async getNextPacket(e,t){const r=this.encodedPacketToMetadata.get(e);if(!r)throw new Error("Packet was not created from this track.");const i=await this.demuxer.findNextPacketStart(r.packet);if(!i)return null;const s=r.timestampInSamples+r.durationInSamples,a=await this.demuxer.readPacket(i.startPage,i.startSegmentIndex);return this.createEncodedPacketFromOggPacket(a,{timestampInSamples:s,vorbisLastBlocksize:r.vorbisBlockSize},t)}async getPacket(t,r){const i=D(t*this.internalSampleRate,14);if(0===i)return this.getFirstPacket(r);if(i<0)return null;e(this.bitstream.lastMetadataPacket);const s=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!s)return null;let a=s.startPage,n=this.demuxer.reader.fileSize;const o=[a];e:for(;a.headerStartPos+a.totalSize<n;){const t=a.headerStartPos,r=Math.floor((t+n)/2);let s=r;for(;;){const t=Math.min(s+65307,n-Zi);let c=this.demuxer.reader.requestSlice(s,t-s);c instanceof Promise&&(c=await c),e(c);if(!rs(c,t)){n=r+Zi;continue e}let u=this.demuxer.reader.requestSliceRange(c.filePos,Zi,es);u instanceof Promise&&(u=await u),e(u);const d=ts(u);e(d);let l=!1;if(d.serialNumber===this.bitstream.serialNumber)l=!0;else{let t=this.demuxer.reader.requestSlice(d.headerStartPos,d.totalSize);t instanceof Promise&&(t=await t),e(t);const r=Ur(t,d.totalSize);l=Gi(r)===d.checksum}if(!l){s=d.headerStartPos+4;continue}if(l&&d.serialNumber!==this.bitstream.serialNumber){s=d.headerStartPos+d.totalSize;continue}if(!(-1===d.granulePosition)){this.granulePositionToTimestampInSamples(d.granulePosition)>i?n=d.headerStartPos:(a=d,o.push(d));continue e}s=d.headerStartPos+d.totalSize}}let c=s.startPage;for(const e of o){if(e.granulePosition===a.granulePosition)break;(!c||e.headerStartPos>c.headerStartPos)&&(c=e)}let u=c;const d=[u];for(;u.serialNumber!==this.bitstream.serialNumber||u.granulePosition!==a.granulePosition;){const t=u.headerStartPos+u.totalSize;let r=this.demuxer.reader.requestSliceRange(t,Zi,es);r instanceof Promise&&(r=await r),e(r);const i=ts(r);e(i),u=i,u.serialNumber===this.bitstream.serialNumber&&d.push(u)}e(-1!==u.granulePosition);let l,h,m=null,f=u,p=0;if(u.headerStartPos===s.startPage.headerStartPos)l=this.granulePositionToTimestampInSamples(0),h=!0,m=0;else{l=0,h=!1;for(let e=u.lacingValues.length-1;e>=0;e--){if(u.lacingValues[e]<255){m=e+1;break}}if(null===m)throw new Error("Invalid page with granule position: no packets end on this page.");p=m-1;const t={data:ps,endPage:f,endSegmentIndex:p};if(await this.demuxer.findNextPacketStart(t)){const t=Eo(d,u,m);e(t);const r=_o(d,t.page,t.segmentIndex);r&&(u=r.page,m=r.segmentIndex)}else for(;;){const e=Eo(d,u,m);if(!e)break;const t=_o(d,e.page,e.segmentIndex);if(!t)break;if(u=t.page,m=t.segmentIndex,e.page.headerStartPos!==f.headerStartPos){f=e.page,p=e.segmentIndex;break}}}let g=null,w=null;for(;null!==u;){e(null!==m);const t=await this.demuxer.readPacket(u,m);if(!t)break;if(!(u.headerStartPos===s.startPage.headerStartPos&&m<s.startSegmentIndex)){let s=this.createEncodedPacketFromOggPacket(t,{timestampInSamples:l,vorbisLastBlocksize:w?.vorbisBlockSize??null},r);e(s);let a=this.encodedPacketToMetadata.get(s);if(e(a),h||t.endPage.headerStartPos!==f.headerStartPos||t.endSegmentIndex!==p?l+=a.durationInSamples:(l=this.granulePositionToTimestampInSamples(u.granulePosition),h=!0,s=this.createEncodedPacketFromOggPacket(t,{timestampInSamples:l-a.durationInSamples,vorbisLastBlocksize:w?.vorbisBlockSize??null},r),e(s),a=this.encodedPacketToMetadata.get(s),e(a)),g=s,w=a,h&&(Math.max(l,0)>i||Math.max(a.timestampInSamples,0)===i))break}const a=await this.demuxer.findNextPacketStart(t);if(!a)break;u=a.startPage,m=a.startSegmentIndex}return g}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}const _o=(t,r,i)=>{let s=r,a=i;e:for(;;){for(a--;a>=0;a--){if(s.lacingValues[a]<255){a++;break e}}e(-1===a);if(!(1&s.headerType)){a=0;break}const r=_(t,(e=>e.headerStartPos<s.headerStartPos));if(!r)return null;s=r,a=s.lacingValues.length}if(e(-1!==a),a===s.lacingValues.length){const r=t[t.indexOf(s)+1];e(r),s=r,a=0}return{page:s,segmentIndex:a}},Eo=(e,t,r)=>{if(r>0)return{page:t,segmentIndex:r-1};const i=_(e,(e=>e.headerStartPos<t.headerStartPos));return i?{page:i,segmentIndex:i.lacingValues.length-1}:null},Io=e=>{const t=e.filePos,r=Ur(e,9),i=new s(r);if(4095!==i.readBits(12))return null;i.skipBits(1);if(0!==i.readBits(2))return null;const a=i.readBits(1),n=i.readBits(2)+1,o=i.readBits(4);if(15===o)return null;i.skipBits(1);const c=i.readBits(3);if(0===c)throw new Error("ADTS frames with channel configuration 0 are not supported.");i.skipBits(1),i.skipBits(1),i.skipBits(1),i.skipBits(1);const u=i.readBits(13);i.skipBits(11);const d=i.readBits(2)+1;if(1!==d)throw new Error("ADTS frames with more than one AAC frame are not supported.");let l=null;return 1===a?e.filePos-=2:l=i.readBits(16),{objectType:n,samplingFrequencyIndex:o,channelConfiguration:c,frameLength:u,numberOfAacFrames:d,crcCheck:l,startPos:t}},Bo=1024;class Mo extends ss{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new y,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();e(this.firstFrameHeader),this.tracks=[new Ns(new zo(this))]})()}async advanceReader(){let t=this.reader.requestSliceRange(this.lastLoadedPos,7,9);if(t instanceof Promise&&(t=await t),!t)return void(this.lastSampleLoaded=!0);const r=Io(t);if(!r)return void(this.lastSampleLoaded=!0);if(r.startPos+r.frameLength>this.reader.fileSize)return void(this.lastSampleLoaded=!0);this.firstFrameHeader||(this.firstFrameHeader=r);const i=ue[r.samplingFrequencyIndex];e(void 0!==i);const s=Bo/i,a=r.crcCheck?9:7,n={timestamp:this.nextTimestampInSamples/i,duration:s,dataStart:r.startPos+a,dataSize:r.frameLength-a};this.loadedSamples.push(n),this.nextTimestampInSamples+=Bo,this.lastLoadedPos=r.startPos+r.frameLength}async getMimeType(){return"audio/aac"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const t=this.tracks[0];return e(t),t.computeDuration()}}class zo{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return this.getSampleRate()/Bo}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return A}getCodec(){return"aac"}getInternalCodecId(){return e(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.objectType}getNumberOfChannels(){e(this.demuxer.firstFrameHeader);const t=de[this.demuxer.firstFrameHeader.channelConfiguration];return e(void 0!==t),t}getSampleRate(){e(this.demuxer.firstFrameHeader);const t=ue[this.demuxer.firstFrameHeader.samplingFrequencyIndex];return e(void 0!==t),t}async getDecoderConfig(){e(this.demuxer.firstFrameHeader);const t=new Uint8Array(3),r=new s(t),{objectType:i,samplingFrequencyIndex:a,channelConfiguration:n}=this.demuxer.firstFrameHeader;return i>31?(r.writeBits(5,31),r.writeBits(6,i-32)):r.writeBits(5,i),r.writeBits(4,a),r.writeBits(4,n),{codec:`mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,numberOfChannels:this.getNumberOfChannels(),sampleRate:this.getSampleRate(),description:t.subarray(0,Math.ceil((r.pos-1)/8))}}async getPacketAtIndex(t,r){if(-1===t)return null;const i=this.demuxer.loadedSamples[t];if(!i)return null;let s;if(r.metadataOnly)s=ps;else{let t=this.demuxer.reader.requestSlice(i.dataStart,i.dataSize);t instanceof Promise&&(t=await t),e(t),s=Ur(t,i.dataSize)}return new gs(s,"key",i.timestamp,i.duration,t,i.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,t){const r=await this.demuxer.readingMutex.acquire();try{const r=v(this.demuxer.loadedSamples,e.timestamp,(e=>e.timestamp));if(-1===r)throw new Error("Packet was not created from this track.");const i=r+1;for(;i>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(i,t)}finally{r()}}async getPacket(e,t){const r=await this.demuxer.readingMutex.acquire();try{for(;;){const r=C(this.demuxer.loadedSamples,e,(e=>e.timestamp));if(-1===r&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(r,t);if(r>=0&&r+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(r,t);await this.demuxer.advanceReader()}}finally{r()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */class Fo{}class Ao extends Fo{async _getMajorBrand(e){let t=e._reader.requestSlice(0,12);if(t instanceof Promise&&(t=await t),!t)return null;t.skip(4);return"ftyp"!==ei(t,4)?null:ei(t,4)}_createDemuxer(e){return new eo(e)}}class Do extends Ao{async _canReadInput(e){const t=await this._getMajorBrand(e);return!!t&&"qt  "!==t}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class Ro extends Ao{async _canReadInput(e){return"qt  "===await this._getMajorBrand(e)}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class Oo extends Fo{async isSupportedEBMLOfDocType(e,t){let r=e._reader.requestSlice(0,Ti);if(r instanceof Promise&&(r=await r),!r)return!1;const i=Si(r);if(null===i)return!1;if(i<1||i>8)return!1;if(Ci(r,i)!==fi.EBML)return!1;const s=Pi(r);if(null===s)return!1;let a=e._reader.requestSlice(r.filePos,s);if(a instanceof Promise&&(a=await a),!a)return!1;const n=r.filePos;for(;a.filePos<=n+s-2;){const e=_i(a);if(!e)break;const{id:r,size:i}=e,s=a.filePos;if(null===i)return!1;switch(r){case fi.EBMLVersion:if(1!==Ci(a,i))return!1;break;case fi.EBMLReadVersion:if(1!==Ci(a,i))return!1;break;case fi.DocType:if(Ei(a,i)!==t)return!1;break;case fi.DocTypeVersion:if(Ci(a,i)>4)return!1}a.filePos=s+i}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new po(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class Wo extends Oo{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class Vo extends Fo{async _canReadInput(e){let t=e._reader.requestSlice(0,10);if(t instanceof Promise&&(t=await t),!t)return!1;let r=0;const i=yo(t);i&&(r=t.filePos+i.size);const s=await To(e._reader,r,r+4096);if(!s)return!1;if(i)return!0;r=s.startPos+=s.header.totalSize;const a=await To(e._reader,r,r+4);if(!a)return!1;const n=s.header,o=a.header;return n.channel===o.channel&&n.sampleRate===o.sampleRate}_createDemuxer(e){return new vo(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class Uo extends Fo{async _canReadInput(e){let t=e._reader.requestSlice(0,12);if(t instanceof Promise&&(t=await t),!t)return!1;const r=ei(t,4);if("RIFF"!==r&&"RIFX"!==r&&"RF64"!==r)return!1;t.skip(4);return"WAVE"===ei(t,4)}_createDemuxer(e){return new qs(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class Lo extends Fo{async _canReadInput(e){let t=e._reader.requestSlice(0,4);return t instanceof Promise&&(t=await t),!!t&&"OggS"===ei(t,4)}_createDemuxer(e){return new xo(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}const No=new Do,Ho=new Ro,qo=new Oo,$o=new Wo,jo=new Vo,Ko=new Uo,Qo=new Lo,Yo=[No,Ho,qo,$o,Ko,Qo,jo,new class extends Fo{async _canReadInput(e){let t=e._reader.requestSliceRange(0,7,9);if(t instanceof Promise&&(t=await t),!t)return!1;const r=Io(t);if(!r)return!1;if(t=e._reader.requestSliceRange(r.frameLength,7,9),t instanceof Promise&&(t=await t),!t)return!1;const i=Io(t);return!!i&&(r.objectType===i.objectType&&r.samplingFrequencyIndex===i.samplingFrequencyIndex&&r.channelConfiguration===i.channelConfiguration)}_createDemuxer(e){return new Mo(e)}get name(){return"ADTS"}get mimeType(){return"audio/aac"}}];
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
class Go{constructor(e){if(this._demuxerPromise=null,this._format=null,!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some((e=>!(e instanceof Fo))))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof $n))throw new TypeError("options.source must be a Source.");this._formats=e.formats,this._source=e.source,this._reader=new Wr(e.source)}_getDemuxer(){return this._demuxerPromise??=(async()=>{this._reader.fileSize=await this._source.getSize();for(const e of this._formats){if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this)}throw new Error("Input has an unsupported or unrecognizable format.")})()}get source(){return this._source}async getFormat(){return await this._getDemuxer(),e(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter((e=>e.isVideoTrack()))}async getPrimaryVideoTrack(){return(await this.getTracks()).find((e=>e.isVideoTrack()))??null}async getAudioTracks(){return(await this.getTracks()).filter((e=>e.isAudioTrack()))}async getPrimaryAudioTrack(){return(await this.getTracks()).find((e=>e.isAudioTrack()))??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}}
/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */const Xo=e=>{if(void 0!==e&&(!e||"object"!=typeof e))throw new TypeError("options.video, when provided, must be an object.");if(void 0!==e?.discard&&"boolean"!=typeof e.discard)throw new TypeError("options.video.discard, when provided, must be a boolean.");if(void 0!==e?.forceTranscode&&"boolean"!=typeof e.forceTranscode)throw new TypeError("options.video.forceTranscode, when provided, must be a boolean.");if(void 0!==e?.codec&&!j.includes(e.codec))throw new TypeError(`options.video.codec, when provided, must be one of: ${j.join(", ")}.`);if(void 0!==e?.bitrate&&!(e.bitrate instanceof ge)&&(!Number.isInteger(e.bitrate)||e.bitrate<=0))throw new TypeError("options.video.bitrate, when provided, must be a positive integer or a quality.");if(void 0!==e?.width&&(!Number.isInteger(e.width)||e.width<=0))throw new TypeError("options.video.width, when provided, must be a positive integer.");if(void 0!==e?.height&&(!Number.isInteger(e.height)||e.height<=0))throw new TypeError("options.video.height, when provided, must be a positive integer.");if(void 0!==e?.fit&&!["fill","contain","cover"].includes(e.fit))throw new TypeError('options.video.fit, when provided, must be one of "fill", "contain", or "cover".');if(void 0!==e?.width&&void 0!==e.height&&void 0===e.fit)throw new TypeError("When both options.video.width and options.video.height are provided, options.video.fit must also be provided.");if(void 0!==e?.rotate&&![0,90,180,270].includes(e.rotate))throw new TypeError("options.video.rotate, when provided, must be 0, 90, 180 or 270.");if(void 0!==e?.frameRate&&(!Number.isFinite(e.frameRate)||e.frameRate<=0))throw new TypeError("options.video.frameRate, when provided, must be a finite positive number.")},Jo=e=>{if(void 0!==e&&(!e||"object"!=typeof e))throw new TypeError("options.audio, when provided, must be an object.");if(void 0!==e?.discard&&"boolean"!=typeof e.discard)throw new TypeError("options.audio.discard, when provided, must be a boolean.");if(void 0!==e?.forceTranscode&&"boolean"!=typeof e.forceTranscode)throw new TypeError("options.audio.forceTranscode, when provided, must be a boolean.");if(void 0!==e?.codec&&!Y.includes(e.codec))throw new TypeError(`options.audio.codec, when provided, must be one of: ${Y.join(", ")}.`);if(void 0!==e?.bitrate&&!(e.bitrate instanceof ge)&&(!Number.isInteger(e.bitrate)||e.bitrate<=0))throw new TypeError("options.audio.bitrate, when provided, must be a positive integer or a quality.");if(void 0!==e?.numberOfChannels&&(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels<=0))throw new TypeError("options.audio.numberOfChannels, when provided, must be a positive integer.");if(void 0!==e?.sampleRate&&(!Number.isInteger(e.sampleRate)||e.sampleRate<=0))throw new TypeError("options.audio.sampleRate, when provided, must be a positive integer.")},Zo=48e3;class ec{static async init(e){const t=new ec(e);return await t._init(),t}constructor(e){if(this._addedCounts={video:0,audio:0,subtitle:0},this._totalTrackCount=0,this._trackPromises=[],this._executed=!1,this._synchronizer=new tc,this._totalDuration=null,this._maxTimestamps=new Map,this._canceled=!1,this.onProgress=void 0,this._computeProgress=!1,this._lastProgress=0,this.utilizedTracks=[],this.discardedTracks=[],!e||"object"!=typeof e)throw new TypeError("options must be an object.");if(!(e.input instanceof Go))throw new TypeError("options.input must be an Input.");if(!(e.output instanceof $a))throw new TypeError("options.output must be an Output.");if(e.output._tracks.length>0||"pending"!==e.output.state)throw new TypeError("options.output must be fresh: no tracks added and not started.");if("function"!=typeof e.video&&Xo(e.video),"function"!=typeof e.audio&&Jo(e.audio),void 0!==e.trim&&(!e.trim||"object"!=typeof e.trim))throw new TypeError("options.trim, when provided, must be an object.");if(void 0!==e.trim?.start&&(!Number.isFinite(e.trim.start)||e.trim.start<0))throw new TypeError("options.trim.start, when provided, must be a non-negative number.");if(void 0!==e.trim?.end&&(!Number.isFinite(e.trim.end)||e.trim.end<0))throw new TypeError("options.trim.end, when provided, must be a non-negative number.");if(void 0!==e.trim?.start&&void 0!==e.trim.end&&e.trim.start>=e.trim.end)throw new TypeError("options.trim.start must be less than options.trim.end.");this._options=e,this.input=e.input,this.output=e.output,this._startTimestamp=e.trim?.start??0,this._endTimestamp=e.trim?.end??1/0;const{promise:t,resolve:r}=P();this._started=t,this._start=r}async _init(){const t=await this.input.getTracks(),r=this.output.format.getSupportedTrackCounts();let i=1,s=1;for(const a of t){let t;a.isVideoTrack()?this._options.video&&("function"==typeof this._options.video?(t=await this._options.video(a,i),Xo(t),i++):t=this._options.video):a.isAudioTrack()?this._options.audio&&("function"==typeof this._options.audio?(t=await this._options.audio(a,s),Jo(t),s++):t=this._options.audio):e(!1),t?.discard?this.discardedTracks.push({track:a,reason:"discarded_by_user"}):this._totalTrackCount!==r.total.max?this._addedCounts[a.type]!==r[a.type].max?a.isVideoTrack()?await this._processVideoTrack(a,t??{}):a.isAudioTrack()&&await this._processAudioTrack(a,t??{}):this.discardedTracks.push({track:a,reason:"max_track_count_of_type_reached"}):this.discardedTracks.push({track:a,reason:"max_track_count_reached"})}const a=this.discardedTracks.filter((e=>"discarded_by_user"!==e.reason));a.length>0&&console.warn("Some tracks had to be discarded from the conversion:",a)}async execute(){if(this._executed)throw new Error("Conversion cannot be executed twice.");this._executed=!0,this.onProgress&&(this._computeProgress=!0,this._totalDuration=Math.min(await this.input.computeDuration()-this._startTimestamp,this._endTimestamp-this._startTimestamp),this.onProgress?.(0)),await this.output.start(),this._start();try{await Promise.all(this._trackPromises)}catch(e){throw this._canceled||this.cancel(),e}this._canceled&&await new Promise((()=>{})),await this.output.finalize(),this._computeProgress&&this.onProgress?.(1)}async cancel(){"finalizing"!==this.output.state&&"finalized"!==this.output.state&&(this._canceled?console.warn("Conversion already canceled."):(this._canceled=!0,await this.output.cancel()))}async _processVideoTrack(r,i){const s=r.codec;if(!s)return void this.discardedTracks.push({track:r,reason:"unknown_source_codec"});let a;const n=t(r.rotation+(i.rotate??0)),o=this.output.format.supportsVideoRotationMetadata,[c,u]=n%180==0?[r.codedWidth,r.codedHeight]:[r.codedHeight,r.codedWidth];let d=c,l=u;const h=d/l,m=e=>2*Math.ceil(e/2);void 0!==i.width&&void 0===i.height?(d=m(i.width),l=m(Math.round(d/h))):void 0===i.width&&void 0!==i.height?(l=m(i.height),d=m(Math.round(l*h))):void 0!==i.width&&void 0!==i.height&&(d=m(i.width),l=m(i.height));const f=await r.getFirstTimestamp(),p=!!i.forceTranscode||this._startTimestamp>0||f<0||!!i.frameRate,g=d!==c||l!==u||0!==n&&!o;let w=this.output.format.getSupportedVideoCodecs();if(p||i.bitrate||g||!w.includes(s)||i.codec&&i.codec!==s){if(!await r.canDecode())return void this.discardedTracks.push({track:r,reason:"undecodable_source_codec"});i.codec&&(w=w.filter((e=>e===i.codec)));const t=i.bitrate??ye,s=await ba(w,{width:d,height:l,bitrate:t});if(!s)return void this.discardedTracks.push({track:r,reason:"no_encodable_target_codec"});const o={codec:s,bitrate:t,sizeChangeBehavior:i.fit??"passThrough",onEncodedPacket:e=>this._reportProgress(r.id,e.timestamp+e.duration)},c=new Pa(o);a=c,g?this._trackPromises.push((async()=>{await this._started;const t=new Ds(r,{width:d,height:l,fit:i.fit??"fill",rotation:n,poolSize:1}).canvases(this._startTimestamp,this._endTimestamp),s=i.frameRate;let a=null,o=null,u=null;const h=async t=>{e(a),e(void 0!==s);const r=Math.round((t-o)*s);for(let e=1;e<r;e++){const t=new ws(a,{timestamp:o+e/s,duration:1/s});await c.add(t)}};for await(const{canvas:e,timestamp:i,duration:n}of t){if(this._synchronizer.shouldWait(r.id,i)&&await this._synchronizer.wait(i),this._canceled)return;let t=Math.max(i-this._startTimestamp,0);if(u=t+n,void 0!==s){const r=Math.floor(t*s)/s;if(null!==a){if(r<=o){a=e,o=r;continue}await h(r)}t=r}const d=new ws(e,{timestamp:t,duration:void 0!==s?1/s:n});await c.add(d),void 0!==s?(a=e,o=t):d.close()}a&&(e(null!==u),e(void 0!==s),await h(Math.floor(u*s)/s)),c.close(),this._synchronizer.closeTrack(r.id)})()):this._trackPromises.push((async()=>{await this._started;const t=new As(r),s=i.frameRate;let a=null,n=null,o=null;const u=async t=>{e(a),e(void 0!==s);const r=Math.round((t-n)*s);for(let e=1;e<r;e++)a.setTimestamp(n+e/s),a.setDuration(1/s),await c.add(a);a.close()};for await(const e of t.samples(this._startTimestamp,this._endTimestamp)){if(this._synchronizer.shouldWait(r.id,e.timestamp)&&await this._synchronizer.wait(e.timestamp),this._canceled)return void a?.close();let t=Math.max(e.timestamp-this._startTimestamp,0);if(o=t+e.duration,void 0!==s){const r=Math.floor(t*s)/s;if(null!==a){if(r<=n){a.close(),a=e,n=r;continue}await u(r)}t=r,e.setDuration(1/s)}e.setTimestamp(t),await c.add(e),void 0!==s?(a=e,n=t):e.close()}a&&(e(null!==o),e(void 0!==s),await u(Math.floor(o*s)/s)),c.close(),this._synchronizer.closeTrack(r.id)})())}else{const e=new Ca(s);a=e,this._trackPromises.push((async()=>{await this._started;const t=new Is(r),i={decoderConfig:await r.getDecoderConfig()??void 0},s=Number.isFinite(this._endTimestamp)?await t.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const a of t.packets(void 0,s,{verifyKeyPackets:!0})){if(this._synchronizer.shouldWait(r.id,a.timestamp)&&await this._synchronizer.wait(a.timestamp),this._canceled)return;await e.add(a,i),this._reportProgress(r.id,a.timestamp+a.duration)}e.close(),this._synchronizer.closeTrack(r.id)})())}this.output.addVideoTrack(a,{frameRate:i.frameRate,languageCode:W(r.languageCode)?r.languageCode:void 0,name:r.name??void 0,rotation:g?0:n}),this._addedCounts.video++,this._totalTrackCount++,this.utilizedTracks.push(r)}async _processAudioTrack(e,t){const r=e.codec;if(!r)return void this.discardedTracks.push({track:e,reason:"unknown_source_codec"});let i;const s=e.numberOfChannels,a=e.sampleRate,n=await e.getFirstTimestamp();let o=t.numberOfChannels??s,c=t.sampleRate??a,u=o!==s||c!==a||this._startTimestamp>0||n<0,d=this.output.format.getSupportedAudioCodecs();if(t.forceTranscode||t.bitrate||u||!d.includes(r)||t.codec&&t.codec!==r){if(!await e.canDecode())return void this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});let r=null;t.codec&&(d=d.filter((e=>e===t.codec)));const s=t.bitrate??ye,a=await wa(d,{numberOfChannels:o,sampleRate:c,bitrate:s});if(a.some((e=>Q.includes(e)))||!d.some((e=>Q.includes(e)))||2===o&&c===Zo)r=a[0]??null;else{const e=(await wa(d,{numberOfChannels:2,sampleRate:Zo,bitrate:s})).find((e=>Q.includes(e)));e&&(u=!0,r=e,o=2,c=Zo)}if(null===r)return void this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});if(u)i=this._resampleAudio(e,r,o,c,s);else{const t=new za({codec:r,bitrate:s,onEncodedPacket:t=>this._reportProgress(e.id,t.timestamp+t.duration)});i=t,this._trackPromises.push((async()=>{await this._started;const r=new Ws(e);for await(const i of r.samples(void 0,this._endTimestamp)){if(this._synchronizer.shouldWait(e.id,i.timestamp)&&await this._synchronizer.wait(i.timestamp),this._canceled)return;await t.add(i),i.close()}t.close(),this._synchronizer.closeTrack(e.id)})())}}else{const t=new Ba(r);i=t,this._trackPromises.push((async()=>{await this._started;const r=new Is(e),i={decoderConfig:await e.getDecoderConfig()??void 0},s=Number.isFinite(this._endTimestamp)?await r.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const a of r.packets(void 0,s)){if(this._synchronizer.shouldWait(e.id,a.timestamp)&&await this._synchronizer.wait(a.timestamp),this._canceled)return;await t.add(a,i),this._reportProgress(e.id,a.timestamp+a.duration)}t.close(),this._synchronizer.closeTrack(e.id)})())}this.output.addAudioTrack(i,{languageCode:W(e.languageCode)?e.languageCode:void 0,name:e.name??void 0}),this._addedCounts.audio++,this._totalTrackCount++,this.utilizedTracks.push(e)}_resampleAudio(e,t,r,i,s){const a=new za({codec:t,bitrate:s,onEncodedPacket:t=>this._reportProgress(e.id,t.timestamp+t.duration)});return this._trackPromises.push((async()=>{await this._started;const t=new rc({sourceNumberOfChannels:e.numberOfChannels,sourceSampleRate:e.sampleRate,targetNumberOfChannels:r,targetSampleRate:i,startTime:this._startTimestamp,endTime:this._endTimestamp,onSample:e=>a.add(e)}),s=new Ws(e).samples(this._startTimestamp,this._endTimestamp);for await(const r of s){if(this._synchronizer.shouldWait(e.id,r.timestamp)&&await this._synchronizer.wait(r.timestamp),this._canceled)return;await t.add(r)}await t.finalize(),a.close(),this._synchronizer.closeTrack(e.id)})()),a}_reportProgress(t,r){if(!this._computeProgress)return;e(null!==this._totalDuration),this._maxTimestamps.set(t,Math.max(r,this._maxTimestamps.get(t)??-1/0));let i=0;for(const[,e]of this._maxTimestamps)i+=e;const s=i/this._totalTrackCount,a=F(s/this._totalDuration,0,1);a!==this._lastProgress&&(this._lastProgress=a,this.onProgress?.(a))}}class tc{constructor(){this.maxTimestamps=new Map,this.resolvers=[]}computeMinAndMaybeResolve(){let e=1/0;for(const[,t]of this.maxTimestamps)e=Math.min(e,t);for(let t=0;t<this.resolvers.length;t++){const r=this.resolvers[t];r.timestamp-e<5&&(r.resolve(),this.resolvers.splice(t,1),t--)}return e}shouldWait(e,t){this.maxTimestamps.set(e,Math.max(t,this.maxTimestamps.get(e)??-1/0));return t-this.computeMinAndMaybeResolve()>=5}wait(e){const{promise:t,resolve:r}=P();return this.resolvers.push({timestamp:e,resolve:r}),t}closeTrack(e){this.maxTimestamps.delete(e),this.computeMinAndMaybeResolve()}}class rc{constructor(e){this.sourceSampleRate=e.sourceSampleRate,this.targetSampleRate=e.targetSampleRate,this.sourceNumberOfChannels=e.sourceNumberOfChannels,this.targetNumberOfChannels=e.targetNumberOfChannels,this.startTime=e.startTime,this.endTime=e.endTime,this.onSample=e.onSample,this.bufferSizeInFrames=Math.floor(5*this.targetSampleRate),this.bufferSizeInSamples=this.bufferSizeInFrames*this.targetNumberOfChannels,this.outputBuffer=new Float32Array(this.bufferSizeInSamples),this.bufferStartFrame=0,this.maxWrittenFrame=-1,this.setupChannelMixer(),this.tempSourceBuffer=new Float32Array(this.sourceSampleRate*this.sourceNumberOfChannels)}setupChannelMixer(){const e=this.sourceNumberOfChannels,t=this.targetNumberOfChannels;this.channelMixer=1===e&&2===t?(t,r)=>t[r*e]:1===e&&4===t?(t,r,i)=>t[r*e]*+(i<2):1===e&&6===t?(t,r,i)=>t[r*e]*+(2===i):2===e&&1===t?(t,r)=>{const i=r*e;return.5*(t[i]+t[i+1])}:2===e&&4===t||2===e&&6===t?(t,r,i)=>t[r*e+i]*+(i<2):4===e&&1===t?(t,r)=>{const i=r*e;return.25*(t[i]+t[i+1]+t[i+2]+t[i+3])}:4===e&&2===t?(t,r,i)=>{const s=r*e;return.5*(t[s+i]+t[s+i+2])}:4===e&&6===t?(t,r,i)=>{const s=r*e;return i<2?t[s+i]:2===i||3===i?0:t[s+i-2]}:6===e&&1===t?(t,r)=>{const i=r*e;return Math.SQRT1_2*(t[i]+t[i+1])+t[i+2]+.5*(t[i+4]+t[i+5])}:6===e&&2===t?(t,r,i)=>{const s=r*e;return t[s+i]+Math.SQRT1_2*(t[s+2]+t[s+i+4])}:6===e&&4===t?(t,r,i)=>{const s=r*e;return i<2?t[s+i]+Math.SQRT1_2*t[s+2]:t[s+i+2]}:(t,r,i)=>i<e?t[r*e+i]:0}ensureTempBufferSize(e){let t=this.tempSourceBuffer.length;for(;t<e;)t*=2;if(t!==this.tempSourceBuffer.length){const e=new Float32Array(t);e.set(this.tempSourceBuffer),this.tempSourceBuffer=e}}async add(t){if(!t||t._closed)return;const r=t.numberOfFrames*t.numberOfChannels;this.ensureTempBufferSize(r);const i=t.allocationSize({planeIndex:0,format:"f32"}),s=new Float32Array(this.tempSourceBuffer.buffer,0,i/4);t.copyTo(s,{planeIndex:0,format:"f32"});const a=t.timestamp-this.startTime,n=t.numberOfFrames/this.sourceSampleRate,o=Math.min(a+n,this.endTime-this.startTime),c=Math.floor(a*this.targetSampleRate),u=Math.ceil(o*this.targetSampleRate);for(let r=c;r<u;r++){if(r<this.bufferStartFrame)continue;for(;r>=this.bufferStartFrame+this.bufferSizeInFrames;)await this.finalizeCurrentBuffer(),this.bufferStartFrame+=this.bufferSizeInFrames;const i=r-this.bufferStartFrame;e(i<this.bufferSizeInFrames);const n=(r/this.targetSampleRate-a)*this.sourceSampleRate,o=Math.floor(n),c=Math.ceil(n),u=n-o;for(let e=0;e<this.targetNumberOfChannels;e++){let r=0,a=0;o>=0&&o<t.numberOfFrames&&(r=this.channelMixer(s,o,e)),c>=0&&c<t.numberOfFrames&&(a=this.channelMixer(s,c,e));const n=r+u*(a-r),d=i*this.targetNumberOfChannels+e;this.outputBuffer[d]+=n}this.maxWrittenFrame=Math.max(this.maxWrittenFrame,i)}}async finalizeCurrentBuffer(){if(this.maxWrittenFrame<0)return;const e=(this.maxWrittenFrame+1)*this.targetNumberOfChannels,t=new Float32Array(e);t.set(this.outputBuffer.subarray(0,e));const r=this.bufferStartFrame/this.targetSampleRate,i=new ys({format:"f32",sampleRate:this.targetSampleRate,numberOfChannels:this.targetNumberOfChannels,timestamp:r,data:t});await this.onSample(i),this.outputBuffer.fill(0),this.maxWrittenFrame=-1}finalize(){return this.finalizeCurrentBuffer()}}export{Yo as ALL_FORMATS,Ha as ALL_TRACK_TYPES,Y as AUDIO_CODECS,sa as AdtsOutputFormat,Vs as AudioBufferSink,Fa as AudioBufferSource,ys as AudioSample,Ws as AudioSampleSink,za as AudioSampleSource,Ia as AudioSource,Ms as BaseMediaSampleSink,Kn as BlobSource,jn as BufferSource,Dr as BufferTarget,Ds as CanvasSink,_a as CanvasSource,ec as Conversion,ns as CustomAudioDecoder,cs as CustomAudioEncoder,as as CustomVideoDecoder,os as CustomVideoEncoder,Ba as EncodedAudioPacketSource,gs as EncodedPacket,Is as EncodedPacketSink,Ca as EncodedVideoPacketSource,Gn as FilePathSource,Go as Input,Ns as InputAudioTrack,Fo as InputFormat,Us as InputTrack,Ls as InputVideoTrack,Ao as IsobmffInputFormat,Gs as IsobmffOutputFormat,qo as MATROSKA,jo as MP3,No as MP4,Oo as MatroskaInputFormat,Sa as MediaSource,Aa as MediaStreamAudioTrackSource,Ea as MediaStreamVideoTrackSource,Zs as MkvOutputFormat,Js as MovOutputFormat,Vo as Mp3InputFormat,ta as Mp3OutputFormat,Do as Mp4InputFormat,Xs as Mp4OutputFormat,Q as NON_PCM_AUDIO_CODECS,Qo as OGG,Lo as OggInputFormat,ia as OggOutputFormat,$a as Output,Ys as OutputFormat,K as PCM_AUDIO_CODECS,Ho as QTFF,ye as QUALITY_HIGH,ke as QUALITY_LOW,be as QUALITY_MEDIUM,Te as QUALITY_VERY_HIGH,we as QUALITY_VERY_LOW,ge as Quality,Ro as QuickTimeInputFormat,G as SUBTITLE_CODECS,$n as Source,Xn as StreamSource,Rr as StreamTarget,La as SubtitleSource,Ar as Target,Na as TextSubtitleSource,Yn as UrlSource,j as VIDEO_CODECS,ws as VideoSample,As as VideoSampleSink,Pa as VideoSampleSource,va as VideoSource,Ko as WAVE,$o as WEBM,ra as WavOutputFormat,Uo as WaveInputFormat,Wo as WebMInputFormat,ea as WebMOutputFormat,la as canEncode,ma as canEncodeAudio,fa as canEncodeSubtitles,ha as canEncodeVideo,wa as getEncodableAudioCodecs,pa as getEncodableCodecs,ka as getEncodableSubtitleCodecs,ga as getEncodableVideoCodecs,ya as getFirstEncodableAudioCodec,Ta as getFirstEncodableSubtitleCodec,ba as getFirstEncodableVideoCodec,ms as registerDecoder,fs as registerEncoder};export default null;
//# sourceMappingURL=/sm/14394bf143ea7a90a6ccd9210ff2b68c2cd13750a80a3fd8702ccc44600acac1.map