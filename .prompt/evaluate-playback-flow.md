# 视频预览核心：连续播放与流畅度评估（全链路版）

请按照 **数据流向（从生产到消费）** 的严格顺序，对 Studio 编辑器的连续播放能力进行深度代码审计。分析上游的生产策略如何制约或支持下游的流畅播放。

## 第一阶段：生产者（数据源头）
*评估数据的“体质”。如果源头数据结构不合理，下游再优化也无法挽救。*

### 1. 编码策略 (Encoding Strategy)
- **文件：** `src/extensions/offscreen-main.ts`
- **审计点：**
    - **GOP (关键帧间隔)：** 检查 WebCodecs配置。GOP 是多少秒？
        - *影响：* GOP 越大，压缩率越高，但在时间轴上 Seek 或跳跃播放时的“预卷解码（Pre-roll decode）”耗时就越长，导致卡顿。
    - **码率控制：** 是否有针对 4K 文本内容的码率冗余设置？

### 2. 写入与存储结构 (Persistence & Chunking)
- **文件：** `src/extensions/opfs-writer.ts`
- **审计点：**
    - **写入碎片化：** 检查 `write` 调用频率。是“一帧一写”还是“缓冲批量写”？
        - *影响：* 过于频繁的小块写入（如每 16ms 写 50KB）会导致 OPFS 文件物理碎片化，大幅增加读取端的 IOPS 压力。
    - **索引精度：** `index.jsonl` 的时间戳记录是否精确？是否按顺序单调递增？

---

## 第二阶段：消费者（播放与渲染）
*评估数据“搬运”与“重建”的效率。*

### 3. 读取管道 (Read Pipeline)
- **文件：** `src/lib/workers/opfs-reader-worker.ts`
- **审计点：**
    - **IO 策略适配：** 读取逻辑是否针对上述“写入策略”进行了补偿？（例如：如果写入很碎，读取是否做了合并？）
    - **预读机制 (Pre-fetching)：** 是否存在“双缓冲”或“滑动窗口”机制？当播放器渲染第 T 秒时，Worker 是否正在后台加载 T+2 秒的数据？
    - **并发控制：** 是否存在多个读取请求排队阻塞主线程的情况？

### 4. 播放调度 (Playback Scheduling)
- **文件：** `src/routes/studio/+page.svelte`
- **审计点：**
    - **时钟源：** 播放循环是基于 `requestAnimationFrame` 还是系统时间差？如何处理录制视频的 VFR（可变帧率）特性？
    - **音画同步：** 当视频解码落后于音频时，是否有“追赶（Catch-up）”或“跳帧”逻辑？

### 5. 解码与合成 (Decoding & Composition)
- **文件：** `src/lib/components/VideoPreviewComposite.svelte`
- **审计点：**
    - **解码队列深度：** `VideoDecoder.decode()` 的调用速率是否受到 `limit` 限制？避免解码器内部缓冲溢出。
    - **对象生命周期：** `VideoFrame` 是否在 Canvas 绘制后立即 `close()`？这是长时间播放不崩溃的关键。

---

## 第三阶段：综合输出

请基于以上流程式分析，提供：

1.  **瓶颈定位表：** 明确指出当前链路中**最窄**的一环（是 GOP 太大？写入太碎？还是读取无缓冲？）。
2.  **全链路优化方案：**
    - **生产端建议：**（如：将 GOP 限制为 2 秒，启用 1MB 的写入 Buffer）。
    - **消费端建议：**（如：实现 3 秒的预读 Ring Buffer）。
3.  **极限场景预测：** 在 4K/60FPS 下，当前的架构还能支撑多久的连续播放而不 OOM（内存溢出）？
